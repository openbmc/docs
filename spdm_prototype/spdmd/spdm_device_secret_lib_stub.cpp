/**
 *  Copyright Notice:
 *  Copyright 2021-2024 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link:
 *https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

/** @file
 * SPDM common library.
 * It follows the SPDM Specification.
 **/

extern "C"
{
// clang-format off
#include "hal/library/responder/asymsignlib.h"
#include "hal/library/responder/csrlib.h"
#include "hal/library/responder/measlib.h"
#include "hal/library/responder/key_pair_info.h"
#include "hal/library/responder/psklib.h"
#include "hal/library/responder/setcertlib.h"
#include "hal/library/requester/reqasymsignlib.h"
#include "hal/library/requester/psklib.h"
// clang-format on

#if LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP
libspdm_return_t libspdm_measurement_collection(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */,
    uint8_t /* measurement_specification */,
    uint32_t /* measurement_hash_algo */, uint8_t /* mesurements_index */,
    uint8_t /* request_attribute */, uint8_t* /* content_changed */,
    uint8_t* /* device_measurement_count */, void* /* device_measurement */,
    size_t* /* device_measurement_size */)
{
    return LIBSPDM_STATUS_UNSUPPORTED_CAP;
}

bool libspdm_measurement_opaque_data(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */,
    uint8_t /* measurement_specification */,
    uint32_t /* measurement_hash_algo */, uint8_t /* measurement_index */,
    uint8_t /* request_attribute */, void* /* opaque_data */,
    size_t* /* opaque_data_size */)
{
    return false;
}

bool libspdm_generate_measurement_summary_hash(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */, uint32_t /* base_hash_algo */,
    uint8_t /* measurement_specification */,
    uint32_t /* measurement_hash_algo */,
    uint8_t /* measurement_summary_hash_type */,
    uint8_t* /* measurement_summary_hash */,
    uint32_t /* measurement_summary_hash_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP
bool libspdm_challenge_opaque_data(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */, uint8_t /* slot_id */,
    uint8_t* /* measurement_summary_hash */,
    size_t /* measurement_summary_hash_size */, void* /* opaque_data */,
    size_t* /* opaque_data_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP
bool libspdm_encap_challenge_opaque_data(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */, uint8_t /* slot_id */,
    uint8_t* /* measurement_summary_hash */,
    size_t /* measurement_summary_hash_size */, void* /* opaque_data */,
    size_t* /* opaque_data_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_MEL_CAP
/*Collect the measurement extension log.*/
bool libspdm_measurement_extension_log_collection(
    void* /* spdm_context */, uint8_t /* mel_specification */,
    uint8_t /* measurement_specification */,
    uint32_t /* measurement_hash_algo */, void** /* spdm_mel */,
    size_t* /* spdm_mel_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MEL_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
bool libspdm_requester_data_sign(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */, uint8_t /* op_code */,
    uint16_t /* req_base_asym_alg */, uint32_t /* base_hash_algo */,
    bool /* is_data_hash */, const uint8_t* /* message */,
    size_t /* message_size */, uint8_t* /* signature */, size_t* /* sig_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP */

bool libspdm_responder_data_sign(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    spdm_version_number_t /* spdm_version */, uint8_t /* op_code */,
    uint32_t /* base_asym_algo */, uint32_t /* base_hash_algo */,
    bool /* is_data_hash */, const uint8_t* /* message */,
    size_t /* message_size */, uint8_t* /* signature */, size_t* /* sig_size */)
{
    return false;
}

#if LIBSPDM_ENABLE_CAPABILITY_PSK_CAP
bool libspdm_psk_handshake_secret_hkdf_expand(
    spdm_version_number_t /* spdm_version */, uint32_t /* base_hash_algo */,
    const uint8_t* /* psk_hint */, size_t /* psk_hint_size */,
    const uint8_t* /* info */, size_t /* info_size */, uint8_t* /* out */,
    size_t /* out_size */)
{
    return false;
}

bool libspdm_psk_master_secret_hkdf_expand(
    spdm_version_number_t /* spdm_version */, uint32_t /* base_hash_algo */,
    const uint8_t* /* psk_hint */, size_t /* psk_hint_size */,
    const uint8_t* /* info */, size_t /* info_size */, uint8_t* /* out */,
    size_t /* out_size */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_PSK_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP
bool libspdm_is_in_trusted_environment(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */
#endif
)
{
    return false;
}

bool libspdm_write_certificate_to_nvm(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    uint8_t /* slot_id */, const void* /* cert_chain */,
    size_t /* cert_chain_size */, uint32_t /* base_hash_algo */,
    uint32_t /* base_asym_algo */
#if LIBSPDM_SET_CERT_CSR_PARAMS
    ,
    bool* /* need_reset */, bool* /* is_busy */
#endif                            /* LIBSPDM_SET_CERT_CSR_PARAMS */
)
{
    return false;
}

#endif /* LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_CSR_CAP
bool libspdm_gen_csr(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    uint32_t /* base_hash_algo */, uint32_t /* base_asym_algo */,
    bool* /* need_reset */, const void* /* request */,
    size_t /* request_size */, uint8_t* /* requester_info */,
    size_t /* requester_info_length */, uint8_t* /* opaque_data */,
    uint16_t /* opaque_data_length */, size_t* /* csr_len */,
    uint8_t* /* csr_pointer */, bool /* is_device_cert_model */
#if LIBSPDM_SET_CERT_CSR_PARAMS
    ,
    bool* /* is_busy */, bool* /* unexpected_request */
#endif
)
{
    return false;
}

#if LIBSPDM_ENABLE_CAPABILITY_CSR_CAP_EX
bool libspdm_gen_csr_ex(
#if LIBSPDM_HAL_PASS_SPDM_CONTEXT
    void* /* spdm_context */,
#endif
    uint32_t /* base_hash_algo */, uint32_t /* base_asym_algo */,
    bool* /* need_reset */, const void* /* request */,
    size_t /* request_size */, uint8_t* /* requester_info */,
    size_t /* requester_info_length */, uint8_t* /* opaque_data */,
    uint16_t /* opaque_data_length */, size_t* /* csr_len */,
    uint8_t* /* csr_pointer */, uint8_t /* req_cert_model */,
    uint8_t* /* csr_tracking_tag */, uint8_t /* req_key_pair_id */,
    bool /* overwrite */
#if LIBSPDM_SET_CERT_CSR_PARAMS
    ,
    bool* /* is_busy */, bool* /* unexpected_request */
#endif
)
{
    return false;
}
#endif /*LIBSPDM_ENABLE_CAPABILITY_CSR_CAP_EX*/
#endif /* LIBSPDM_ENABLE_CAPABILITY_CSR_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_EVENT_CAP
bool libspdm_event_get_types(void* /* spdm_context */,
                             spdm_version_number_t /* spdm_version */,
                             uint32_t /* session_id */,
                             void* /* supported_event_groups_list */,
                             uint32_t* /* supported_event_groups_list_len */,
                             uint8_t* /* event_group_count */)
{
    return false;
}

bool libspdm_event_subscribe(void* /* spdm_context */,
                             spdm_version_number_t /* spdm_version */,
                             uint32_t /* session_id */,
                             uint8_t /* subscribe_type */,
                             uint8_t /* subscribe_event_group_count */,
                             uint32_t /* subscribe_list_len */,
                             const void* /* subscribe_list */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_EVENT_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_GET_KEY_PAIR_INFO_CAP

/**
 * read the key pair info of the key_pair_id.
 *
 * @param  spdm_context               A pointer to the SPDM context.
 * @param  key_pair_id                Indicate which key pair ID's information
 *to retrieve.
 *
 * @param  capabilities               Indicate the capabilities of the requested
 *key pairs.
 * @param  key_usage_capabilities     Indicate the key usages the responder
 *allows.
 * @param  current_key_usage          Indicate the currently configured key
 *usage for the requested key pairs ID.
 * @param  asym_algo_capabilities     Indicate the asymmetric algorithms the
 *Responder supports for this key pair ID.
 * @param  current_asym_algo          Indicate the currently configured
 *asymmetric algorithm for this key pair ID.
 * @param  assoc_cert_slot_mask       This field is a bit mask representing the
 *currently associated certificate slots.
 * @param  public_key_info_len        On input, indicate the size in bytes of
 *the destination buffer to store. On output, indicate the size in bytes of the
 *public_key_info. It can be NULL, if public_key_info is not required.
 * @param  public_key_info            A pointer to a destination buffer to store
 *the public_key_info. It can be NULL, if public_key_info is not required.
 *
 * @retval true  get key pair info successfully.
 * @retval false get key pair info failed.
 **/
bool libspdm_read_key_pair_info(
    void* /* spdm_context */, uint8_t /* key_pair_id */,
    uint16_t* /* capabilities */, uint16_t* /* key_usage_capabilities */,
    uint16_t* /* current_key_usage */, uint32_t* /* asym_algo_capabilities */,
    uint32_t* /* current_asym_algo */, uint8_t* /* assoc_cert_slot_mask */,
    uint16_t* /* public_key_info_len */, uint8_t* /* public_key_info */)
{
    return false;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_GET_KEY_PAIR_INFO_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_SET_KEY_PAIR_INFO_CAP
bool libspdm_write_key_pair_info(void* /* spdm_context */,
                                 uint8_t /* key_pair_id */,
                                 uint8_t /* operation */,
                                 uint16_t /* desired_key_usage */,
                                 uint32_t /* desired_asym_algo */,
                                 uint8_t /* desired_assoc_cert_slot_mask */,
                                 bool* /* need_reset */)
{
    return false;
}
#endif /* #if LIBSPDM_ENABLE_CAPABILITY_SET_KEY_PAIR_INFO_CAP */

#ifdef LIBSPDM_ENABLE_CAPABILITY_ENDPOINT_INFO_CAP
libspdm_return_t libspdm_generate_device_endpoint_info(
    void* /* spdm_context */, uint8_t /* sub_code */,
    uint8_t /* request_attributes */, uint32_t* /* endpoint_info_size */,
    void* /* endpoint_info */)
{
    return LIBSPDM_STATUS_UNSUPPORTED_CAP;
}
#endif /* #if LIBSPDM_ENABLE_CAPABILITY_ENDPOINT_INFO_CAP */
}
