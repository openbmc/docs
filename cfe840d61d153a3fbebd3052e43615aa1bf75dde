{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ab0231a1_4254b796",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-17T17:03:22Z",
      "side": 1,
      "message": "Add you aswell üëç",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33c0a260_697dafc9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-18T12:36:37Z",
      "side": 1,
      "message": "Hi Alexander, thanks for adding the design doc. After some discussion with Jeremy I\u0027ve tried to zoom the discussion out a little further.",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82a6d97b_741439ed",
        "filename": "designs/uart-mux-support.md",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-18T12:36:37Z",
      "side": 1,
      "message": "So I think it might be best if we add a \"Considerations\" section somewhere, either as a `### Considerations` header under `## Background and References` or possibly its own `## Considerations` section before `## Requirements`.\n\nWhat I think is important to cover in \"Considerations\" is that we have a number of choices to make. The following is the result of me stepping back to analyze the options, along with some discussion with Jeremy:\n\n1. What does the \"connection endpoint\" (Unix domain socket, DBus object) represent? This could be either:\n 1. The TTY device exposed by Linux\n 2. The desired downstream mux port\n2. How the mux state is controlled. We might control it by any of:\n 1. An out-of-band command (e.g. via a DBus method that\u0027s somehow associated with the connection endpoint\n 2. An in-band command (e.g. introducing an SSH-style escape-sequence)\n 3. Selecting the mux port based on the endpoint to which the user has connected\n3. The circumstances under which we allow the mux state to be changed\n 1. Active connections prevents the mux state from being changed\n 2. The mux state can always change but will terminate any existing conflicting connections\n 3. The mux state can always change and has no impact on existing conflicting connections\n4. Whether we want the data stream on a given connection to represent:\n 1. The console IO regardless of the mux state\n 2. The console IO isolated to a specific mux port\n\nThere are constraints on some combinations of these. For instance:\n\n5. If the connection endpoint represents the TTY device exposed by Linux (1.1) then we can\u0027t select the mux port based on the endpoint to which the user has connected (2.3) as we simply don\u0027t have the information required\n6. If the connection endpoint represents the desired downstream mux port (1.2) then it doesn\u0027t make sense to implement support for an in-band command to change the mux state (2.2) as it\u0027s a violation of the abstraction\n7. If the connection endpoint represents the desired downstream mux port (1.2) then it can\u0027t provide the console IO of another mux port (4.1) as that\u0027s contrary to the definition.\n\nWith these in mind we end up with the following table of design options:\n\n| ID | Connection Endpoint (1) | Mux Control Defined By (2) | Mux Control Policy (3) | Stream Data (4) |\n|----|-------------------------|----------------------------|------------------------|------------------|\n| A | TTY (1.1) | Out-of-band command (2.1)  | Active connections prevent mux change (3.1) | Isolated (4.2) |\n| B | TTY | Out-of-band command | Mux change with disconnections (3.2) | Isolated |\n| C | TTY | Out-of-band command | Mux change without disconnections | Multiplexed (4.1) |\n| D | TTY | In-band command (2.2) | Mux change never denied | Multiplexed |\n| E | Mux port (1.2) | Connection-based (2.3) | Conflicting connections prevent mux change (3.1) | Isolated |\n| F | Mux port | Connection-based | Mux change with disconnections | Isolated |\n| G | Mux port | Connection-based | Mux change without disconnections | Isolated |\n| H | Mux port | Out-of-band command | Conflicting connections prevent mux change | Isolated |\n| I | Mux port | Out-of-band command | Mux change with disconnections | Isolated |\n| J | Mux port | Out-of-band command | Mux change without disconnections | Isolated |\n\n---\n\nTo help shape the choices here, we have the existing behaviours of obmc-console [discussed on the PDI patch](https://gerrit.openbmc.org/c/openbmc/phosphor-dbus-interfaces/+/71878/comment/dd34b099_66dbc49e/):\n\n8. We already have support for concurrent console server instances\n9. Concurrent console support is implemented as one obmc-console-server process per Linux TTY device\n10. As each Linux TTY device is paired with its obmc-console-server process, each obmc-console-server DBus connection needs a unique name\n11. We use the unique console-ids to name global resources, including both the DBus connection and the instance\u0027s unix domain socket.\n\nAs in the linked discussion, given the `console-id` value really represents what\u0027s at the remote end of the BMC\u0027s TTY device for regular unmuxed consoles it stands to reason that we should probably continue this strategy for muxed consoles. Taking this approach avoids adding a new endpoint ABI to obmc-console and eliminates design options A-D inclusive.\n\nFurther, on the basis of frustrating behaviour in the face of lingering network connections, preventing mux changes on the grounds of an existing connection seems like a bad path forward.\n\nThis leaves us with design options F, G, I, and J, which are differentiated by how the mux is switched and its effect on already-connected clients.\n\nConcentrating on how the mux is switched for the moment, discussions until now have largely focused on the \"out-of-band command\" approach. This is also reflected in the final requirement below and was the motivation for writing this design document, as one way or another we\u0027ll need to add support to affected applications such as bmcweb and phosphor-net-ipmid (I think I said phosphor-host-ipmid elsewhere, but that\u0027s not quite right). Some further discussion followed about implementation approaches and trade-offs on the PDI patch, and is touched on below in the split vs unified DBus tree section. I think it\u0027s reasonable to say there are some complications here.\n\nBy contrast we can consider the alternative: We make the mux state reflect the endpoint of the most recent connection. This has the benefit of functioning for both the Unix domain socket and the DBus interface with no further effort. Neither bmcweb nor phosphor-net-ipmid need be patched, nor their maintainers bothered. This also eliminates the complications mentioned above as there\u0027s no need for the additional DBus interface.\n\nThis choice constrains us to design options F and G, but also gives us a hint as to how to pick between F and G.\n\nF and G are differentiated by whether or not we drop connections on endpoints that are not the endpoint selected by the mux. I\u0027ve gone back and forth about that previously[[1](https://gerrit.openbmc.org/c/openbmc/obmc-console/+/71228/comment/62a5fce9_60c3ad3e/)][[2](https://gerrit.openbmc.org/c/openbmc/obmc-console/+/71867/comment/756f0abe_5ebe8d66/)] but I think I\u0027ve settled on the argument that _not_ disconnecting clients is effectively a worse implementation of design option C, which we\u0027ve also eliminated anyway. It\u0027s worse than C because instead of 1 connection we will have approximately N connections for N mux ports, (N - 1) of which are idle. Not only that, but the (N - 1) connections are effectively zombies, as they have no way to switch the mux back to their associated port without establishing yet another connection. It follows that if we\u0027re establishing a subsequent connection in order to switch the mux we may as well disconnect the existing session, in which case it might as well have been disconnected when the mux switched away (which also saves resources).\n\nThese arguments combined eliminate all but option F, which seems to sit at a pretty neat nexus point in terms of both existing ABI, desired behaviour, and implementation complexity.\n\nWhat are your thoughts on this reasoning? Are there use-cases that we need to account for that might affect some of the trade-offs?\n\n(also, apologies for another wall of text).",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a747550_0be69edd",
        "filename": "designs/uart-mux-support.md",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-18T16:44:32Z",
      "side": 1,
      "message": "Added the \"Considerations\" Section to the markdown. I\u0027m not too familiar with gerrit but is it possible for you to push new revision to this change, even if i started it originally?\nSince it\u0027s a collaboration effort.\n\nFor your conclusions, i\u0027m not sure if mux control should be this implicit.\n\nImagine for example a BIC update process is in progress and the mux has been switched to log the output of whatever the BIC is printing. \nNow somone starts a new connection to the Host uart and the mux is switched,\nlosing whatever the BIC would have printed.\n\nSo for some application to log any output it needs to \n- open a connection \n- re-open that connection in case it gets disconnected\n\nI imagine during normal operation there would be some policy which would select a console based on some events. Like power control or firmware update. \n\nSo the logfiles would always contain what\u0027s deemed \u0027useful\u0027 to have at a given time.\n\nIt will be easier to implement to just have a dbus method or property to achieve this, instead of other processes having to open and keep-alive a connection.\n\n\nThen there is the issue of override by the user. In both cases (external or implicit mux control), the user should have priority over system policy.\n\nBut the user should also be allowed to \u0027follow\u0027 system policy. \n\nimaginary example:\n\nBIC boot, then CPLD boot, then Host boot.\n\nAt each stage, we want to see the respective output.\nEven if BIC continues to print, at some point we want to switch to Host UART.\n\nSo maybe there could be another special console with a console-id derived from the kernel tty device, where a connection to this uart automatically receives everything,\nno matter the mux state.\n\nThis way, the user can connect to this special console and see everything, and the system policy can control the mux explicitly.\n\n\nAnyways, this is all perhaps content for a future extension.\nFor now this special console may not be needed. It would work similar to /dev/tty0 in linux which always points to the active console (or so i heard).\n\n\nI would also be fine with the implicit mux control but not sure if the disconnection would be handled well by all the programs.\n\nIf there is no further feedback from others i can also just add your conclusions\nin a section to document how we arrived at the conclusion.",
      "parentUuid": "82a6d97b_741439ed",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a9ef58f_e3b195a2",
        "filename": "designs/uart-mux-support.md",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-19T00:32:18Z",
      "side": 1,
      "message": "\u003e I\u0027m not too familiar with gerrit but is it possible for you to push new revision to this change, even if i started it originally? Since it\u0027s a collaboration effort.\n\nYeah, I can do that, that\u0027s no problem at all.\n\n\u003e For your conclusions, i\u0027m not sure if mux control should be this implicit.\n\nThanks for the examples and thoughts that follow. Let me find a way to integrate them into the text.",
      "parentUuid": "2a747550_0be69edd",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05c1a037_647550ac",
        "filename": "designs/uart-mux-support.md",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-19T03:25:10Z",
      "side": 1,
      "message": "Okay, I\u0027ve tried to make your examples slightly less specific and have added some discussion. Let me know what you think.",
      "parentUuid": "8a9ef58f_e3b195a2",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8b053dbc_2738b92b",
        "filename": "designs/uart-mux-support.md",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-19T08:43:57Z",
      "side": 1,
      "message": "Hi Andrew,\n\nThanks for providing the detailed overview. The connection based mux control can work out for the interactive use-case and can also be made to work for the logging use case.\n\nThe point about the additional implementation required in other projects is **very convincing**. \n\n\nFor the unified vs split tree, we can go with the unified tree if that\u0027s what you prefer. The split tree would also work since there would be nothing new in the tree.\n\nIt\u0027s mainly a question of what to expose to other projects initially. So i\u0027m fine to do the unified tree.\n\nIn that case, we do not need to have an extra dbus interface or any changes to phosphor-dbus-interfaces, is this correct?\n\n\n\u003e TODO: Rejig the sections below after review feedback on the above\n\nAs we agree on the mux control mechanism to be connection based, i leave the next revision up to you if that\u0027s ok.",
      "parentUuid": "05c1a037_647550ac",
      "revId": "cfe840d61d153a3fbebd3052e43615aa1bf75dde",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}