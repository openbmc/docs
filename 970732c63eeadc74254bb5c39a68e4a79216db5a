{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0923989e_e545c763",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "Hi Chris, thanks again for the updates. I\u0027ve got a couple of comments regarding formatting and an outstanding community query on integrating devicetree support directly into EM, but other than that it\u0027s starting to feel sensible.\n\nHowever, can you please mark old conversations that we\u0027ve worked through as resolved so it\u0027s clear we\u0027re making progress?",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efb4633f_267a3e16",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-11-28T23:07:20Z",
      "side": 1,
      "message": "Apologies for being fairly late to the party here -- I *think* I\u0027ve read or at least skimmed through all the discussion that\u0027s taken place here (hopefully I haven\u0027t missed something where my thoughts here have already been addressed) but: to take a step back for a moment, it seems like there are two relatively independent aspects in consideration here:\n\n - how to retrieve hardware ID data from where it\u0027s stored\n - the format of that data and how to parse it into useful metadata fields\n \nThe problem at hand is that HPE hardware does non-standard things for both.\n\nLooking at the existing state of things, E-M\u0027s fru-device daemon only supports the standard IPMI FRU data format, but it *is* capable of retrieving that data via different means (manual userspace I2C transactions, reading from an eeprom file provided by a kernel driver, or from a regular file in `/etc`).  In a hypothetical world in which HPE systems still had their hardware ID data stored in the secure element but did so in the standard IPMI FRU format, I think the approach to take would be to create a means to plumb that data into the existing fru-device daemon.\n\nLooking at the other side, in another hypothetical in which HPE systems used the same proprietary data format they do but stored it in a standard I2C eeprom, I\u0027d be inclined to just add some logic to fru-device to make it able to recognize and parse the alternate format -- in fact, while it\u0027s been a bit dormant for a while, I\u0027ve actually made some efforts on that front previously (for a different format, obviously): https://gerrit.openbmc.org/c/openbmc/entity-manager/+/49341\n\nSo given the above, what I\u0027m wondering is if we could just make fru-device handle it itself, without introducing any new daemons or the like.  I guess my open question would be:\n\n - Is the access channel to the secure element only available during the early boot phase, or can the HW ID data still be retrieved once Linux is up and running on the BMC?\n   - If the latter, would it be feasible to create a driver that would expose that data as a file in a way similar to how I2C eeprom data is exposed in sysfs?\n   - If the former, could we just have u-boot drop the entire blob into a designated FDT node?\n\n - Does the proprietary data format preclude having an open-source parser for it?",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f6902ba_012ea715",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-28T23:18:39Z",
      "side": 1,
      "message": "\u003e Is the access channel to the secure element only available during the early boot phase, or can the HW ID data still be retrieved once Linux is up and running on the BMC?\n\nI hadn\u0027t got a direct answer to that by my inferred answer was \"no\", but it\u0027s not clear to me why it\u0027s \"no\" (maybe some e.g. TrustZone-style separation of privileged hardware?). Clarification of the mechanics would be a good addition to the document.\n\n\u003e If the former, could we just have u-boot drop the entire blob into a designated FDT node?\n\nI think that\u0027s where things are at now? There was also discussion about exposing the mentioned reserved memory via Linux, but it seems that\u0027s not preserved long enough in the boot process? It\u0027s not clear to me whether that is a requirement, a constraint, or some kind of engineering decision that might have more flexibility.\n\n\u003e Does the proprietary data format preclude having an open-source parser for it?\n\nI think that\u0027s in their u-boot fork that transforms the data in the reserved memory into attributes in the devicetree.",
      "parentUuid": "efb4633f_267a3e16",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9848b274_87164c11",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-11-29T00:56:55Z",
      "side": 1,
      "message": "\u003e\u003e could we just have u-boot drop the entire blob into a designated FDT node?\n\u003e\n\u003e I think that\u0027s where things are at now? \n\nHmm, I had thought the current idea was to have u-boot parse it and create per-field FDT nodes for things like model \u0026 serial number?  (i.e. what\u0027s described in lines 46-47 of the current version of the doc)  What I meant was to just leave it in its original un-parsed binary form to pass it through to linux (and thus its userspace) and let a parser in fru-device extract the needed fields from that.\n\n\u003e I think that\u0027s in their u-boot fork that transforms the data in the reserved memory into attributes in the devicetree.\n\nAh, yes, and looking back at lines 42-44 that would seem to imply that an open-source parser for the proprietary format is indeed OK.",
      "parentUuid": "6f6902ba_012ea715",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3d33e6e_4463e72a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-29T01:04:51Z",
      "side": 1,
      "message": "\u003e What I meant was to just leave it in its original un-parsed binary form to pass it through to linux (and thus its userspace) and let a parser in fru-device extract the needed fields from that.\n\nAh, so that feels a little abusive of devicetree. However we did dive down a related path in attempting to expose the reserved memory containing the data. But again, that didn\u0027t seem possible for some reason, though it wasn\u0027t clear why not and whether that could be changed:\n\nhttps://gerrit.openbmc.org/c/openbmc/docs/+/65678/comment/514b891b_6b4246c5/\n\nI asked Chris to add that discussion to the `Alternatives Considered` section.",
      "parentUuid": "9848b274_87164c11",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb653483_66045b49",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "Cleaning up some old resolved comments threads, and replying to a few others. (More replies to some comments coming after this update)",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df509b01_c73c0f02",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0923989e_e545c763",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34fb3726_2790e4db",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T22:14:34Z",
      "side": 1,
      "message": "\u003e I\u0027m wondering is if we could just make fru-device handle it itself, without introducing any new daemons or the like\n\nInterestingly, the very first thing I submitted on this topic was a block of code proposed for FRU-Device that could read from \u0027arbitrary paths in the filesystem\u0027 (but the HPE-example usage was setup to read HPE data from inside the device-tree/chosen node).\n\n\nI called it a \u0027managed FRU\u0027 at the time (got pushback on that name), but we\u0027ll probably turn it into a separate daemon and call it something else once a design doc is accepted, at the code here is modified where needed to fit the \u0027new\u0027 design.\n\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/65669\n   \nOne of the bigger pushbacks was on the idea that 1 daemon should be responsible for only 1 channel, and that FRU-Device is aimed at EEPROM over I2C reads (with a coding-convenience exception for reading an EEPROM blob from a location in the OS filesystem).\n\n-------------\n\n\u003eIs the access channel to the secure element only available during the early boot phase, or can the HW ID data still be retrieved once Linux is up and running on the BMC?\n\nThe secure element storing the data is not directly accessible by BMC. An HPE bootloader runs before u-Boot, accesses the secure element, and uses a predetermined location in RAM to pass the data along for pickup by u-Boot code.\n \nThe location in RAM is not protected, so there\u0027s no guarantee of the contents after u-Boot\u0027s stage finishes and the rest of the boot process begins (even though it *theoretically* should be unchanged in the short term).\n \n -----------------------\n \n\u003eDoes the proprietary data format preclude having an open-source parser for it?\n \nThe parser is open source and can be found in HPE\u0027s forked u-boot code @ https://github.com/HewlettPackard/gxp-uboot/\n \n -----------------------------\n \n\u003eThere was also discussion about exposing the mentioned reserved memory via Linux, but it seems that\u0027s not preserved long enough in the boot process? It\u0027s not clear to me whether that is a requirement, a constraint, or some kind of engineering decision that might have more flexibility.\n\nAs my current understanding goes, we can reserve memory via u-Boot making modifications to the flat device-tree, but we can\u0027t define data to populate that memory space from there. \n\nAs I understand it, by the time the modified flat device tree has been consumed by the kernel and the memory is actually reserved, we don\u0027t have guarantees that the RAM location u-Boot would have read from hasn\u0027t been overwritten (though it\u0027s \"probably\" fine).",
      "parentUuid": "a3d33e6e_4463e72a",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e6878e5_68140074",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-12-03T23:34:40Z",
      "side": 1,
      "message": "\u003e The secure element storing the data is not directly accessible by BMC. An HPE bootloader runs before u-Boot, accesses the secure element\n\nYou keep stating this and not explaining the mechanics of it. How does this isolation work? What is it that prevents u-boot from accessing the secure element? How does the HPE bootloader talk to the secure element? Is it attached via I2C? SPI? 1W? A bunch of stuff here is unclear and I think that lack of clarity is preventing us from providing further feedback.\n\n\u003e and uses a predetermined location in RAM to pass the data along for pickup by u-Boot code.\n\u003e\n\u003e The location in RAM is not protected, so there\u0027s no guarantee of the contents after u-Boot\u0027s stage finishes and the rest of the boot process begins (even though it theoretically should be unchanged in the short term).\n\nI\u0027m going to poke at this claim a bit more. u-boot has the ability to reserve chunks of memory for various reasons. You can find a bunch of related code in https://github.com/HewlettPackard/gxp-uboot/blob/v2020.10-gxp-openbmc/common/board_f.c by searching `reserve_`. I think it\u0027s possible to make this all line up so we can expose the data to userspace under linux via reserved memory.\n\n\u003e As my current understanding goes, we can reserve memory via u-Boot making modifications to the flat device-tree, but we can\u0027t define data to populate that memory space from there. \n\nBut if you define the reserved memory region as the region that\u0027s already populated by the HPE bootloader, then there\u0027s no need to populate it, as it\u0027s already populated. However, if for some reason they need to be different locations, then it should just be a `memcpy()`?",
      "parentUuid": "34fb3726_2790e4db",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4270a28_8bc9acee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-04T15:30:29Z",
      "side": 1,
      "message": "The poking is definitely appreciated! \n\nIt had not occurred to me that it would be possible to mark an already-populated space in RAM as \u0027reserved\u0027 and then read from it after boot. I think I\u0027d just assumed the reservation process would wipe the memory clear during boot.\n\nWe\u0027ll do some experimenting and then I\u0027ll get back to you on this. \n\nTo confirm-- assuming using reserved memory path works out and we can dump a blob, then have a daemon (hosted in Entity-Manager, I still assume) parse the HPE format -- is this strongly preferred over using device-tree model and serial-number paths?\n\nI feel like device-tree/model and /serial-number make sense in a \"maybe other entities might have a use for this\" kind of way -- but at the same time, maybe establishing a pathway for reserved memory reads could be just as useful... I think I\u0027ll leave it up to more experienced folks to offer guidance here 😊\n\nI\u0027ll also ask around for the level of detail re: secure element access you\u0027re asking about. Off the top of my head, I believe a proprietary driver that HPE doesn\u0027t own is involved in communicating with the secure element. I believe the driver is authorized for release in HPE\u0027s bootblock, but not elsewhere. I\u0027ll have to ask about the specific communication channel used.",
      "parentUuid": "2e6878e5_68140074",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "940c5ff7_fb6fdc70",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-12-04T22:58:02Z",
      "side": 1,
      "message": "\u003e We\u0027ll do some experimenting and then I\u0027ll get back to you on this. \n\nGreat, thanks for continuing to iterate on this with us. It\u0027s a great example of how working with upstream should work (though it\u0027s often squashed by competing pressures).\n\n\u003e To confirm-- assuming using reserved memory path works out and we can dump a blob, then have a daemon (hosted in Entity-Manager, I still assume) parse the HPE format -- is this strongly preferred over using device-tree model and serial-number paths?\n\nReally it depends on the other information. There\u0027s no harm in duplicating the model and serial number data between the devicetree and the blob, but shoving arbitrary data into the devicetree doesn\u0027t immediately sit well with me. It\u0027s not an opaque data transport, it\u0027s a well-defined data structure (with schemas) for describing undiscoverable hardware.\n\n\u003e I\u0027ll also ask around for the level of detail re: secure element access you\u0027re asking about.\n\nThanks for continuing to work with us on this as well 😊",
      "parentUuid": "c4270a28_8bc9acee",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "848cb1fc_db7e9f4b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-12-05T15:12:38Z",
      "side": 1,
      "message": "While any memory can be marked reserved, there are some considerations if you want to relocate the block before passing to the Linux kernel.    Normally U-Boot places itself at the top of RAM (there is a variable to adjust this limit).  In addition you need linear memory for the fit, the kernel and initramfs (or other initrd) copied from the fit.  The kernel decompressor allocates the full kernel image and stack, and then invokes the kernel itself.  The other consideration is that the kernel will allocate memory in at least page chunks, and groups binary pairs up to at least the large page size, so having at least page alignment is good.",
      "parentUuid": "940c5ff7_fb6fdc70",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c46915eb_990a0b89",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-05T20:22:24Z",
      "side": 1,
      "message": "I very much appreciate the time you guys are taking to offer so much detailed guidance on this -- even the dead ends have a very helpful learning experience (that I\u0027ll definitely be aiming to pass along :)\n\n\u003eThere\u0027s no harm in duplicating the model and serial number data between the devicetree and the blob, but shoving arbitrary data into the devicetree doesn\u0027t immediately sit well with me\n\nWhat would folks think about a daemon for reading in \u0027model\u0027 and \u0027serial-number\u0027 from device-tree, then separately pulling additional data from reserved memory through a reserved-memory daemon later on? (reserved memory experimentation is ongoing).\n\nIn this scenario, this doc would be probably be updated to remove discussion of plans to add additional HW ID data through a \u0027baseboard\u0027 (working name) device-tree node, and to instead refer to a different (future) doc for reading additional HW ID data from reserved-memory.\n\nThe \u0027model\u0027 string is the big thing we need to ID HPE platforms, and the rest of the stuff is generally just \u0027would be nice to display in UI someday\u0027 data that we\u0027re not too worried about yet.\n\nAn additional detail I\u0027ve recently discovered is that the \u0027model\u0027 value we\u0027re currently looking to rely on for HPE platform IDs actually comes from a separate (CPLD-based memory) device than the rest of the HW ID blob comes from; the HPE u-Boot code just originally grouped the output together under device-tree/chosen as a hidden implementation detail.\n\nThat said, I don\u0027t think BMC needs to be \u0027aware\u0027 of the origins of the model value if it\u0027s just getting it from the standard device-tree/model path.\n\nWhat do you folks think?",
      "parentUuid": "848cb1fc_db7e9f4b",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e71ca59_e9f6952c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-05T21:15:06Z",
      "side": 1,
      "message": "Also - I\u0027ve confirmed that what I said previously about Secure Element communication was correct - the bootloader\u0027s communication with it relies on a 3rd party driver, and there are solid restrictions on how drivers that communicate with the SE can be released.",
      "parentUuid": "c46915eb_990a0b89",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be63ddd3_f1c860b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-12-06T23:47:30Z",
      "side": 1,
      "message": "\u003e Also - I\u0027ve confirmed that what I said previously about Secure Element communication was correct - the bootloader\u0027s communication with it relies on a 3rd party driver, and there are solid restrictions on how drivers that communicate with the SE can be released.\n\nCan you please add this explanation to the text - it\u0027s useful to know we have more of a political constraint and than a technical constraint.\n\n\u003e What would folks think about a daemon for reading in \u0027model\u0027 and \u0027serial-number\u0027 from device-tree, then separately pulling additional data from reserved memory through a reserved-memory daemon later on? (reserved memory experimentation is ongoing).\n\nThat sounds like a reasonable solution to me. For what it\u0027s worth IBM already does something similar (search for `IBMCompatibleSystem` - thought I think Matt Spinler is moving them away from that towards a generic `Compatible` interface)\"\n\n\u003e An additional detail I\u0027ve recently discovered is that the \u0027model\u0027 value we\u0027re currently looking to rely on for HPE platform IDs actually comes from a separate (CPLD-based memory) device than the rest of the HW ID blob comes from; the HPE u-Boot code just originally grouped the output together under device-tree/chosen as a hidden implementation detail.\n\nPlease also integrate this note into the text.\n\n\u003e That said, I don\u0027t think BMC needs to be \u0027aware\u0027 of the origins of the model value if it\u0027s just getting it from the standard device-tree/model path.\n\nAgreed. However, please make sure the details are in this document so in the future we can understand how we came to whatever decisions we make.",
      "parentUuid": "7e71ca59_e9f6952c",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70e71b34_dba55dca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2023-12-07T22:22:20Z",
      "side": 1,
      "message": "There is an xyz.openbmc_project.Inventory.Decorator.Compatible interface that is meant to hold things like model values, but it holds an array of values similar to how the device tree compatible stuff, and I\u0027m not sure if entity-manager can probe on an array value.",
      "parentUuid": "be63ddd3_f1c860b5",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94f235a7_070934f8",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 44,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "Can we add the discussion about exposing the reserved memory under Linux to the \"Alternatives Considered\" section?",
      "range": {
        "startLine": 42,
        "startChar": 9,
        "endLine": 44,
        "endChar": 48
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1dd061b_b1f87f21",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 44,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "Can do. \n\nThe biggest hurdle as I understand it is that we can define a reserved memory space from inside u-Boot through modifications to the \u0027flat\u0027 device-tree, but I wasn\u0027t able to find discussion of methods to pre-populate that reserved memory with data *before* the flat device-tree is consumed by the kernel.\n\nThere\u0027s nothing protecting the chunk of RAM that our u-Boot code is using as a pickup point, so there\u0027s no solid guarantee of the contents after that point (even though they should in theory be unchanged for at least awhile).",
      "parentUuid": "94f235a7_070934f8",
      "range": {
        "startLine": 42,
        "startChar": 9,
        "endLine": 44,
        "endChar": 48
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a0043b8_38f561ca",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 48,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-11-29T23:36:14Z",
      "side": 1,
      "message": "Have you prototyped such code?  If so, an updated link would be appreciated.",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02f72397_9179ffdc",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 48,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "We\u0027ve tested a proof of concept re: having code in u-boot that alters the contents of device\u0027s tree\u0027s \u0027model\u0027 and \u0027serial-number\u0027 via modifications to the flat device tree, but it hasn\u0027t been posted online yet.\n\nIf/when we agree this path is the way to go, the source that updates \u0027model\u0027 and \u0027serial-number\u0027 will be made available @ https://github.com/HewlettPackard/gxp-uboot/\n\nThe current release outputs a series of properties under device-tree/chosen/",
      "parentUuid": "9a0043b8_38f561ca",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3f49fd6_1041f54f",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 49,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "This link fails to render correctly in the document:\n\nhttps://gerrit.openbmc.org/plugins/gitiles/openbmc/docs/+/970732c63eeadc74254bb5c39a68e4a79216db5a/designs/oem/hpe/hpe_hw_detect_no-fru.md#background-and-references\n\nNote that markdown generally supports \"reference links\" that allow you to separate the URL from the hyperlink markup:\n\nhttps://github.github.com/gfm/#reference-link\n\nYou can do this instead:\n\n```\n... [\u0027model\u0027 and \u0027serial-number,\u0027 which both have well-known paths in the device tree root][dt-spec-chap3-root-node].\n\n[dt-spec-chap3-root-node]: https://github.com/devicetree-org/devicetree-specification/blob/main/source/chapter3-devicenodes.rst#root-node\n```",
      "range": {
        "startLine": 47,
        "startChar": 27,
        "endLine": 49,
        "endChar": 113
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "363cfc6f_0d57e255",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 49,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "Thanks for the tip!",
      "parentUuid": "d3f49fd6_1041f54f",
      "range": {
        "startLine": 47,
        "startChar": 27,
        "endLine": 49,
        "endChar": 113
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "149d5e75_53e1a7c5",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "I\u0027m wondering whether we just glue devicetree probe support directly into EM and save the DBus side of things.\n\nI\u0027ve brought it up on Discord also:\n\nhttps://discord.com/channels/775381525260664832/819741065531359263/1178834869351092254",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7be8515a_7d3a34c4",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-11-29T23:36:14Z",
      "side": 1,
      "message": "As I stated on Discord, this counter proposal needs more details.  How would it work?  Would a board be identified by a compatible string, and specify which sub-nodes (or phandle links) are the slots representing other nodes for other FRUs?  each entity would be expected to restrict itself to properties of that single node?\n\n(similar content in a discord thread forked from above as a proposal)",
      "parentUuid": "149d5e75_53e1a7c5",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efefd645_5812a018",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-30T02:21:18Z",
      "side": 1,
      "message": "Reflecting on it I think exposing a devicetree probe capability opens up opportunities much wider than are necessary to meet HP\u0027s needs. I feel that\u0027s motivating in your questions Milton and is reasonable cause for concern. Maybe we should also reconsider whether injecting the data into the devicetree is the right thing to do at all, but we have been going around on it a bit, and it feels like we\u0027ll get a bit bogged down. Maybe it\u0027s best if we don\u0027t expose the devicetree capability to the EM config files and chug on with the D-Bus probe approach. We could at least contain exploitation of the devicetree more easily that way.",
      "parentUuid": "7be8515a_7d3a34c4",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac95d4e5_f5ceb407",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T22:14:34Z",
      "side": 1,
      "message": "If we\u0027re leaning back towards a specific daemon for reading from device-tree paths, I\u0027m definitely good with that.",
      "parentUuid": "efefd645_5812a018",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f67ab8d_d06abb11",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-12-03T23:34:40Z",
      "side": 1,
      "message": "Okay. Though first I think we need to resolve our revisit of the reserved memory approach above.",
      "parentUuid": "ac95d4e5_f5ceb407",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57c94d4e_17bc569c",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 90,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-04T15:30:29Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8f67ab8d_d06abb11",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 90,
        "endChar": 10
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f45b4523_4075f54d",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 97,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "I wouldn\u0027t say \"written to file paths in ...\" but rather \"exposed as devicetree attributes\"",
      "range": {
        "startLine": 97,
        "startChar": 20,
        "endLine": 97,
        "endChar": 27
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b15e31f_e659d5ae",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 97,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "I\u0027ll do this in the next draft.",
      "parentUuid": "f45b4523_4075f54d",
      "range": {
        "startLine": 97,
        "startChar": 20,
        "endLine": 97,
        "endChar": 27
      },
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3664310_0c24ed18",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-27T23:23:53Z",
      "side": 1,
      "message": "A formatting comment rather than a content comment, but can you make the various cases, the pros and the cons subheaders so we can more easily distinguish them from the properties?\n\n```\n## Alternatives Considered\n\n### All HW ID data is ...\n\n#### Pros\n1. ...\n2. ...\n\n#### Cons\n1. ...\n2. ...\n```\n\nAlso, instead of bullets it\u0027s much more useful to use numbered lists so we can discuss the properties by reference to their number.",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e8a2897_e843e033",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-11-28T23:07:20Z",
      "side": 1,
      "message": "\u003e Also, instead of bullets it\u0027s much more useful to use numbered lists so we can discuss the properties by reference to their number.\n\nNot to get too bikesheddy here, but FWIW I don\u0027t 100% agree there -- IMO numbering is more applicable when there is a particular meaningful order for the items (like steps in a sequence, whereas this is basically just a set with an arbitrary order imposed for the purpose of writing it down).  It also incurs more ancillary book-keeping work if any adjustments are made (adding or removing at anything but the end of the list implies a bunch of renumbering of existing entries).  The markdown feature of allowing you to write just a plain `1.` on every entry and have \"real\" numbers assigned when rendered helps there, but then you kinda defeat the intended purpose here in that you lose the ability to usefully refer to item number N when looking at the un-rendered source (which for me anyway is a pretty large fraction of the time).",
      "parentUuid": "f3664310_0c24ed18",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f37c2ea_6c3a24e0",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-11-28T23:18:39Z",
      "side": 1,
      "message": "It\u0027s less about an ordering and more about a unique identifier. It just happens to be the case that Markdown\u0027s unique identifiers also provide ordering. I also don\u0027t find numbering that much of a burden when there\u0027s only a handful of related elements. I didn\u0027t do a survey to figure out whether I\u0027m in the minority there though 😊",
      "parentUuid": "9e8a2897_e843e033",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e5b5252_eb8990f6",
        "filename": "designs/oem/hpe/hpe_hw_detect_no-fru.md",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-12-01T21:34:11Z",
      "side": 1,
      "message": "I\u0027ll update the formatting here in the next draft.",
      "parentUuid": "3f37c2ea_6c3a24e0",
      "revId": "970732c63eeadc74254bb5c39a68e4a79216db5a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}