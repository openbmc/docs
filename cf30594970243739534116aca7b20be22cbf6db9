{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f21ad0a3_2e01e269",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2026-01-20T18:38:28Z",
      "side": 1,
      "message": "I don\u0027t think you are asking enough maintainers.  Try making these sorts of changes in the MCTP userspace.  Or are we constraining this mandate to repos in the github.com/openbmc namespace?",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 67,
        "endChar": 21
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1774e1ad_3127f911",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:46:33Z",
      "side": 1,
      "message": "We definitely can\u0027t constrain code in repositories outside the openbmc org.",
      "parentUuid": "f21ad0a3_2e01e269",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 67,
        "endChar": 21
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15ce9cb1_e66b414d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:57:44Z",
      "side": 1,
      "message": "I left an example of how you can at least narrow down the file.",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 76,
        "endChar": 25
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1bff5c2_62cb8572",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:57:44Z",
      "side": 1,
      "message": "By not using the bindings, there is still an informal dependency on PDI as the documentation.  It\u0027s just no longer enforced by the compiler.\n\nI think we need to quantify why this \"additional dependency\" matters before this objection holds much weight.  There is already a dependency on sdbusplus; you\u0027re just trading that for phosphor-dbus-interfaces instead.  We already have PDI as a dependency in the flash image, as you said, so this isn\u0027t adding size.  We can pretty trivially support meson subprojects now and cross-repository CI.",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 113,
        "endChar": 58
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15ff3f46_8af50926",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:57:44Z",
      "side": 1,
      "message": "The bindings also support creating an additional `std::optional` or however you want to hold it to instantiate an additional interface at a dbus path.  You don\u0027t _have_ to exclusively use the `object::server\u003c...\u003e` varargs template; that\u0027s just there for ease when you do have a static set.",
      "range": {
        "startLine": 119,
        "startChar": 0,
        "endLine": 124,
        "endChar": 17
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0caafd0_09c006b8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 132,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:57:44Z",
      "side": 1,
      "message": "Didn\u0027t we already agree that PDI is at a minimum the documentation source for all dbus interfaces?  I suspect this is an old objection that is no longer relevant anyhow.",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 132,
        "endChar": 67
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bb7db16_a9b32024",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:57:44Z",
      "side": 1,
      "message": "We don\u0027t leverage versioning and I don\u0027t want to give the impression that we\u0027re starting to go in that path by giving credence to its suggestion in a commit message.\n\nTopic based CI is how dependencies (and breaking API changes) should be handled (https://lore.kernel.org/openbmc/Zv2oBkO0J6OEUvie@heinlein.vulture-banana.ts.net/).  It has been in place for 1.5 years now.\n\nI don\u0027t understand this \"objection\" to begin with.  Changing strings at-will and breaking other repositories silently is somehow ... better?",
      "range": {
        "startLine": 136,
        "startChar": 0,
        "endLine": 140,
        "endChar": 18
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79fd8a1c_eda680bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-08T14:50:00Z",
      "side": 1,
      "message": "Adding all current ToF members + folks who had a strong opinion on the topic to this review",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66c2acd3_44f67336",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2026-01-20T18:38:28Z",
      "side": 1,
      "message": "I appreciate you trying to build consensus on this.  Good luck.\n\nSome open questions I have are:\n\nWould generated headers be a pre-requisite to using a new language, such as Rust or c, or does this only apply to c++?\n\nDo we require generated headers and constants for interfaces provided by projects such as systemd or the mctp userspace?\n\nAre there any scenarios at all where the use of generated headers would not be mandated?",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d00a8148_e38bbdf8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-01-20T18:42:22Z",
      "side": 1,
      "message": "This would imply that:\n1. All services use the same bindings\n2. All services use generated bindings\n\nAnd as a result, the code would not be as searchable.  Today you can search for an interface, and find all places that implement it.  If we rely on generated headers, that\u0027s no longer the case.  Overall, I am against this.",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd5f7c5d_baadc1f7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:46:33Z",
      "side": 1,
      "message": "I\u0027m on-board with this being documented as the overall direction.  I\u0027m not 100% sure this is the right place for it, but I\u0027m also not sure what is a better place.",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c839ba8c_cecfa3d0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:46:33Z",
      "side": 1,
      "message": "Grep-ability is the only concern?\n\n\u003e Today you can search for an interface, and find all places that implement it. If we rely on generated headers, that\u0027s no longer the case.\n\nConsidering we currently have 2 different bindings and 1 preference for manual, this isn\u0027t really the case today.  At least the bindings are mostly self-consistent.\n\nEven if you scope to the manual implementations, this isn\u0027t strictly true.  Taken dbus-sensors:\n\n```\n$ rg \"xyz.openbmc_project.Sensor.Threshold\" -l              \nREADME.md\nsrc/Thresholds.cpp\n```\n\nSo, no I can\u0027t find all cases where thresholds are created because we\u0027ve created a \"library\" or \"utility function\" (or one might say \"manually created binding\") so now I also have to find all the cases where _this_ is used.\n\nThe code is just as \"greppable\" when it comes to the bindings, in my opinion (also in dbus-sensors).  I can see all uses of Leak.Detector:\n```\n$ rg \"xyz.openbmc_project.State.Leak.Detector\"\nsrc/leakdetector/LeakGPIODetector.hpp\n12:#include \u003cxyz/openbmc_project/State/Leak/Detector/aserver.hpp\u003e\n\nsrc/leakdetector/LeakGPIODetector.cpp\n9:#include \u003cxyz/openbmc_project/State/Leak/Detector/aserver.hpp\u003e\n\nsrc/leakdetector/LeakEvents.hpp\n5:#include \u003cxyz/openbmc_project/State/Leak/Detector/client.hpp\u003e\n\nsrc/leakdetector/LeakEvents.cpp\n9:#include \u003cxyz/openbmc_project/State/Leak/Detector/event.hpp\u003e\n```",
      "parentUuid": "d00a8148_e38bbdf8",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7281247_7b281402",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:46:33Z",
      "side": 1,
      "message": "\u003e Would generated headers be a pre-requisite to using a new language, such as Rust or c, or does this only apply to c++?\n\nWell, this was part of the feedback I left on Rust.  I don\u0027t really want to regress there either.  So, yes, my preference would be if we want to use a new language, someone invests the time in generating a binding generator.\n\n\u003e Do we require generated headers and constants for interfaces provided by projects such as systemd or the mctp userspace?\n\nI\u0027m fine with us going either way on those, but my preference would be to tend towards using a binding.  Someone added `phosphor-dbus-interfaces/yaml/org/freedesktop/UPower/Device.interface.yaml` so that they could use the bindings against it, so there\u0027s no reason you can\u0027t make bindings against non-OpenBMC interfaces.",
      "parentUuid": "66c2acd3_44f67336",
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee117640_6be3999d",
        "filename": "CONTRIBUTING.md",
        "patchSetId": 2
      },
      "lineNbr": 393,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2026-01-20T18:44:44Z",
      "side": 1,
      "message": "This rule wouldn\u0027t apply, as it talks about UNNAMED constants.  In the example, integers are used.  The examples here are generally named and are described as part of the API itself.  For example, scripts that hardcode \"/redfish/v1\" or \"https\" would not be covered under this rule.",
      "range": {
        "startLine": 393,
        "startChar": 20,
        "endLine": 393,
        "endChar": 130
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "172c35c4_d97ebe3a",
        "filename": "CONTRIBUTING.md",
        "patchSetId": 2
      },
      "lineNbr": 393,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2026-01-20T21:46:33Z",
      "side": 1,
      "message": "I don\u0027t think the CCG distinguishes between \"named\" and \"unnamed\" contants.\n\n\u003e Enforcement Flag literals in code. Give a pass to 0, 1, nullptr, \\n, \"\", and others on a positive list.\n\nIt says to enforce a flag on all literals and gives an example that the empty string might be [one of the only] on a positive (allow) list.\n\nI agree that `\"/redfish/v1\"` is _probably_ obvious but is it more obvious than `redfish_prefix` is, I guess, a matter of taste preference.  The CCG in my reading says no, but if there were a clang-tidy check for this, there probably would be a \"false positive\" configuration for it and I\u0027d be fine with some \u0027well-known exceptions\u0027 like `\"/redfish/v1\"`.  That doesn\u0027t mean that every static string is fair game though...",
      "parentUuid": "ee117640_6be3999d",
      "range": {
        "startLine": 393,
        "startChar": 20,
        "endLine": 393,
        "endChar": 130
      },
      "revId": "cf30594970243739534116aca7b20be22cbf6db9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}