{
  "comments": [
    {
      "key": {
        "uuid": "5a81b8eb_8255bce8",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 418,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-04T13:41:55Z",
      "side": 1,
      "message": "Please set the \u0027diff width\u0027 in preferences to a value larger than 80 columns to be able to view this ascii diagram.",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e60495f5_6ec888cf",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-08T08:39:48Z",
      "side": 1,
      "message": "why? So far we are using Phosphor-software-manager to do the update? Any specific reason for bmcweb to directly communicate with PLDMd?\nNote: \nThis will cause certain limitations\n1. Full image update level support will require changes in bmcweb (relying on phosphor-software-manager will not have this issue)\n2. what if BMC level image verification is required for certain devices?\n\nBasically, irrespective of whether the device uses Pldm or any other methodologies, the update mechanism from BMC must stand same, the diversification etc. must happen in terms of phosphor-software-manager and not in bmcweb.\nE.g. Whether BIOS is updated as normal image or PLDM model, flow from bmcweb must remain the same, and phosphor-software-manager, after doing image verification etc, and based on the header it can direct the required update mechanism (i.e. if it is PLDM request to PLDM daemon).",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7839b2a0_a3031d1c",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-08T08:51:07Z",
      "side": 1,
      "message": "Richard - What is exposed to bmcweb is a D-Bus API. This design is not proposing a change to how bmcweb activates firmware for PLDM images (please see details below in the description section). So, I am not sure I followed your concern. I don\u0027t think there is a guideline/reason that one application must house all varying implementations of a D-Bus API. For eg - bmcweb queries sensors/FRUs via well-known D-BUs APIs. Such sensor/FRU D-Bus objects can be housed by multiple daemons (that\u0027s the whole premise of having standard D-Bus APIs and bmcweb using mapper to find objects). In fact my concern with what you described above is we need phosphor-software-manager to deal with PLDM specifics - I want to avoid that.",
      "parentUuid": "e60495f5_6ec888cf",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cf624ad_9bbd0945",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-08T09:25:37Z",
      "side": 1,
      "message": "Yes it is D-Bus, and technically possible.\nQuestion is why ? how we will handle full image update in that case? Does bmcweb takes care of individual update?",
      "parentUuid": "7839b2a0_a3031d1c",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a4713b86_1ba13e58",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-08T09:30:15Z",
      "side": 1,
      "message": "\u003e Yes it is D-Bus, and technically possible. Question is why?\nI\u0027m not sure I am following. Can you elaborate the context?\n\nI\u0027m not seeing the benefit of an additional D-Bus layer that phosphor-software-manager and PLDM would need to talk to each other.",
      "parentUuid": "1cf624ad_9bbd0945",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8b47aea_6efd2446",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-08T13:20:56Z",
      "side": 1,
      "message": "I agree with Deepak.  I donâ€™t think it is unreasonable for multiple applications to host the Update dbus functions.  We already have two implementations (one for BMC and one for Power host firmware).  This is just another one.",
      "parentUuid": "a4713b86_1ba13e58",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf49ef67_79f3e322",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-09T08:27:24Z",
      "side": 1,
      "message": "@Sumanth or @Richard - please elaborate on how you think we\u0027d want phosphor-software-manager to interact with pldm daemon - what does the D-Bus API look like? Based on that, I can capture that as an alternate design option and we can discuss and document pros/cons and then we can converge on one approach.",
      "parentUuid": "d8b47aea_6efd2446",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8af9b74_fc68bbb8",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-10T06:41:54Z",
      "side": 1,
      "message": "@Deepak- Agree with your flow on the pldmd and bmcweb on FirmwareInventory flow. \n\nHowever, for the update flow, we think having the \"item manager\" functionality implemented in phosphor-software-manager would provide different BMC vendors to handle the update package the way they deem fit, and pldmd would still have the \"item updater\" functionality. Ex - A PLDM update package can be a signed one. Signature verification can be done in phosphor-software-manager. Phosphor-software-manager could also probe and find out the type of update package sent down by the user using some sort of meta-data like manifest file or probing into image headers.[Image could BMC/BIOS or others like PLDM/PSU/CPLD].\n\nIn the case of PLDM, we have a notion of IMAGE SET versioning. The PLDM update package could have multiple components targeted for multiple FDs (described in figure 6 of the spec). A typical use case could be A NIC vendor providing a single PLDM update package for different SKUs of a single generation of cards; the update package would have different component images targeting different FDs (that may or may not be in the server). The IMAGE SET version could be a good candidate for the phosphor-software-manager\u0027s version interface, and p-s-m could also host the update package\u0027s activation and activation-progress interface. The bmcweb user ,who initiated the update package, could get overall progress wrt to the entire bundle\u0027s update status.\n\nThus, in short, p-s-m can take care of vendor specific implementations like signature verification and host the version interface (based on the IMAGE SET version for pldm update package),activation and activation progress interface, and then place the PLDM only update package in a staging area (/tmp/images/pldm may be) which is compliant to Figure 6 in the spec. It could proceed to make a method call (from fwupd script ot any other mechanism) to pldmd with filepath of the PLDM only update package (if required, we could also pass the d-bus service name/object who is hosting the activation, activation-progress interfaces). \n\nFor pldmd, the update package is self descriptive and would be able to parse the headers and findout the intendent recipient of the update package (using the Device descriptors area) and then proceed with the update flow. It can update the activation state and progress interfaces hosted by p-s-m accordingly.\n\nThe advantage with this method is that pldmd would remain pure \"protocol\" daemon and customizations required by different vendors do not creep into pldmd.",
      "parentUuid": "cf49ef67_79f3e322",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28e96b6b_a3b6b77d",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 444,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-10T08:30:35Z",
      "side": 1,
      "message": "@Sumanth - I understand what you\u0027re saying, but there are other ways to solve this problem:\n\n\u003e  pldmd would remain pure \"protocol\" daemon and customizations required by different vendors do not creep into pldmd.\nFor eg, we could come up with an image sign verification D-Bus API that p-s-m or something else can implement.\n\nWe have examples of separate process handling software management on their own - openpower PNOR and PSU code mgr. My concerns with the alternate approach are:\n- p-s-m needs to know about specific firmware update packages format, or we need to come up with additional manifest files and image purpose fields and p-s-m needs to know and maintain information that a certain image was PSU/BIOS/PLDM, etc.\n- Every item updater must provide/implement a D-Bus API for p-s-m to call into, at least to kick start activation and provide information about the objects implementing the version interface, activation interface, progress interface, etc.\n- Since pldm will not own the activation objects, creating associations with inventory objects becomes complex. We would need to provide more details on how the D-Bus APIs would look like.\n- while this approach claims that p-s-m is doing the imagemanager, in reality that image and version management has to be done by pldmd as well (for things like downstream devices).",
      "parentUuid": "a8af9b74_fc68bbb8",
      "range": {
        "startLine": 444,
        "startChar": 36,
        "endLine": 444,
        "endChar": 60
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdddc27f_2df3381a",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 475,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-08T13:20:56Z",
      "side": 1,
      "message": "How will PLDM know if an uploaded update image is applicable to a managed FD?  This is one big gap in our Software dbus interfaces that Iâ€™d like to solve.  I donâ€™t like the current enumerations and continuing to add to them.  Maybe we can discuss on Discord what thought Iâ€™ve already put into it.",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9dd9322_43547097",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 475,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-08T16:37:59Z",
      "side": 1,
      "message": "My thought (noted in 3e and 4 below) was to come up with a D-Bus interface that is something like xyz.openbmc_project.Software.ImageTarget (or a better name) that provides at least one property - the staging area of an image. The PLDM daemon would monitor one such staging area.\n\nPLDM could implement an /xyz/openbmc_project/software/pldm_imaget_target with the staging area set to /tmp/images/pldm. The BMC code udpate could host an /xyz/openbmc_project/software/bmc_image_target. The webserver could from this API make corresponding HTTP push targets.\n\nWe might have to deal with a case where the user pushes a \u0027single image\u0027 package to the BMC. In this scenario we might need bmcweb or some other entity to split the singe image and copy contained images into relevant staging areas.\n\nI will discuss your thoughts on this on Discord.",
      "parentUuid": "bdddc27f_2df3381a",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56d22fb3_f9a3d7d7",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 475,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-09T04:52:55Z",
      "side": 1,
      "message": "@Patrick - PLDM Firmware Update specification provides a notion of Device Identifier record. This is unique to a class of device, this could something like PCIe Vendor ID-Device ID. Table 8 of DSP0267 describes the device descriptors supported for PLDM Firmware update.\n\nThe pldmd can query the device descriptors from a PLDM device during its discovery phase. During the update phase, the update package itself would contain the target device descriptors. Thus the update package (image blob) is self sufficient for pldmd to determine to which FD the update package is for.",
      "parentUuid": "f9dd9322_43547097",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "176bf2de_ffe28c0a",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-04T18:44:17Z",
      "side": 1,
      "message": "could be an array of FDs?",
      "range": {
        "startLine": 519,
        "startChar": 61,
        "endLine": 519,
        "endChar": 73
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d4e9dff_cbc32d97",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "Yes. There is actually an array of HttpPushUris in Redfish (please see 4).",
      "parentUuid": "176bf2de_ffe28c0a",
      "range": {
        "startLine": 519,
        "startChar": 61,
        "endLine": 519,
        "endChar": 73
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a597e2f_6d1b7f0d",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 523,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-04T18:44:17Z",
      "side": 1,
      "message": "Would we need Manifest file for PLDM update? The image payload should be self descriptive, no? \n\nFigure 6 of DSP0267 v1.1 provides the \"image payload\" details - it consists of a package header that describes the target FDs, Image Set version, individual component version numbers. This should give us an option to skip keeping the manifest file altogether.",
      "range": {
        "startLine": 522,
        "startChar": 12,
        "endLine": 523,
        "endChar": 41
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d64c976_19693a89",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 523,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "I agree that the PLDM daemon would be able to prepare the payload header. However, how does it determine the version?\n\nOr, did you indicate that the payload pushed to the Redfish endpoint must already be a PLDM payload (i.e PLDM format header + binary image)? I was thinking this shouldn\u0027t be mandated.",
      "parentUuid": "7a597e2f_6d1b7f0d",
      "range": {
        "startLine": 522,
        "startChar": 12,
        "endLine": 523,
        "endChar": 41
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a98fe4db_8f289f11",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 523,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-02-10T12:53:54Z",
      "side": 1,
      "message": "As per my understanding the image uploaded by the user from redfish targeted to a PLDM device will comply PLDM firmware update package format(i.e PLDM format header + binary image). The PLDM header will not be created by PLDM daemon. Is that not the case?",
      "parentUuid": "9d64c976_19693a89",
      "range": {
        "startLine": 522,
        "startChar": 12,
        "endLine": 523,
        "endChar": 41
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5b6658a_19b2acfc",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 523,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-10T12:57:07Z",
      "side": 1,
      "message": "\u003e As per my understanding the image uploaded by the user from redfish targeted to a PLDM device will comply PLDM firmware update package format(i.e PLDM format header + binary image)\n\nThat is correct. Might need another layer if there is a single image tarball consisting of PLDM and non-PLDM FW payloads.",
      "parentUuid": "a98fe4db_8f289f11",
      "range": {
        "startLine": 522,
        "startChar": 12,
        "endLine": 523,
        "endChar": 41
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f9e46e2_542f8d15",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 525,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2021-02-04T21:48:40Z",
      "side": 1,
      "message": "nit: \u0027staging\u0027",
      "range": {
        "startLine": 525,
        "startChar": 59,
        "endLine": 525,
        "endChar": 66
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "832724b0_c196ee01",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 525,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2f9e46e2_542f8d15",
      "range": {
        "startLine": 525,
        "startChar": 59,
        "endLine": 525,
        "endChar": 66
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a52444cc_82487228",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2021-02-04T21:48:40Z",
      "side": 1,
      "message": "This proposal looks pretty good. Looking to see if we could add a bit more details on an example. Above you mentioned that the webserver could do an HttpPushUri on endpoint /redfish/v1/UpdateService/inventory/nic0 to trigger the update. How would the PLDM service watching the staging area know this image is targeted for that FD?",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30b78056_28a11026",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "\u003e How would the PLDM service watching the staging area know this image is targeted for that FD?\nThe staging area is specific to an FD (at least that\u0027s what I proposed above).\n\nI will add two additional flows detailing Redfish-PLDM interaction and UA-FD interaction.",
      "parentUuid": "a52444cc_82487228",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46662fd9_0426ab15",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 549,
      "author": {
        "id": 1000910
      },
      "writtenOn": "2021-02-04T23:40:41Z",
      "side": 1,
      "message": "Will UA send *ActivateFirmware* automatically after *ApplyComplete* or depends on user options? Firwmare activation should be a separate action from firmware flashing, and let user decide when to activate.",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cd8a8c5_6ca43e45",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 549,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "You\u0027re right - that depends on what the FD expects. There are properties on the FD that the UA will query to determine how the Activation should happen. If that says a reset is required, then the onus is on the user to perform a reset via another Redfish API.",
      "parentUuid": "46662fd9_0426ab15",
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35aff88b_194127cd",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-04T18:44:17Z",
      "side": 1,
      "message": "Agree with the high level flow. However, additional things can be taken care of:\n\n1) The update package could target multiple FDs and each of those FDs could have only a subset of component images applicable to them. \nIn section 7.1 of DSP0267 v1.1 describes this. Thus we could potentially loop over the list of FD, and update all the matched FDs before we proceed with the activation step.\n\n2) There could be multiple instances of the FD in the system (ex: multiple NIC cards from the same vendor would have same FDs). Are we going to update only the inventory item targeted by *HttpPushUri* ?\n\nAlso this section could benefit from a flow diagram describing UA - FD interactions, I think.",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfb858b1_dded2811",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:24:33Z",
      "side": 1,
      "message": "HttpPushUriTargets is actually an array (please see 4), so yes this can target multiple FDs in one shot. I think this again goes back to what you think the Redfish payload should be - just firmware image blobs or a PLDM firmware image payload.\n\nI will add two additional flows detailing Redfish-PLDM interaction and UA-FD interaction (though the latter is well described in DSP0267).",
      "parentUuid": "35aff88b_194127cd",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e0c6bbe_1b5b156e",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-05T04:32:51Z",
      "side": 1,
      "message": "Sumanth - I think you\u0027re right. The payload even at Redfish level must be as per Figure 6 of DSP0267. That actually simplifies things a bit. However let\u0027s discuss if that assertion can cause problems.",
      "parentUuid": "cfb858b1_dded2811",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9093d990_2a507858",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-05T07:55:28Z",
      "side": 1,
      "message": "Yes, with the mechanisms provided in the FWU specification, (since the update package is self descriptive) we wouldn\u0027t require an external agent informing pldmd about the target of the update package. This just means that pldmd can simply determine the target FD just by parsing the update package headers.\n\nWhat this could essentially mean is that the current update service can stage the pldm update packages in a predetermined area and not bother about the target FD at all. We would still require the software.version, software.activation and other interfaces mentioned in 3, this would be required for Firmware Inventory, as you have noted.",
      "parentUuid": "3e0c6bbe_1b5b156e",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1464d97a_ff3b2df7",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000410
      },
      "writtenOn": "2021-02-05T08:01:49Z",
      "side": 1,
      "message": "Also, any thoughts on security aspects? The PLDM firmware update specification doesn\u0027t mandate anything on the UA (onus is on the FD), however if device vendors decide to add security related headers in the update package, where would we handle it? (Perhaps a provision in pldmd to handle custom headers in the update package? or handle it in phosphor-software-manager?)",
      "parentUuid": "9093d990_2a507858",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "406d5b8e_6cfcaf72",
        "filename": "designs/pldm-stack.md",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-08T08:39:48Z",
      "side": 1,
      "message": "Yes. This is needed, esp. option to allow vendor signing is essential to avoid compatibility issues.",
      "parentUuid": "1464d97a_ff3b2df7",
      "range": {
        "startLine": 537,
        "startChar": 0,
        "endLine": 556,
        "endChar": 13
      },
      "revId": "95628110bec07d692fa3a0da1e245168b9ab0dba",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}