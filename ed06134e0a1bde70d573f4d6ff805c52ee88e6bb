{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "95940e1d_07b9d035",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2023-10-02T20:32:37Z",
      "side": 1,
      "message": "I like this idea in general. Working out the state machine to make sure it behaves correctly on this multi-key situation is tricky. I took a stab, but am still not sure it is correct.",
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3eb3b554_7ce31eea",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2023-10-02T20:32:37Z",
      "side": 1,
      "message": "This is not quite the full picture. If the byte is a newline, it should still be emitted immediately, and then we are in the next loop that waits for the next byte. If ~, send break, otherwise emit and go back to empty.\n\nI am not sure if I got this right, but here\u0027s my take:\n\n\n---\ntitle: SSH escape state machine\n---\nstateDiagram-v2\n    direction LR\n    [*] --\u003e Empty\n    Empty --\u003e Emit: [^#92;n]\n    Emit --\u003e Empty\n    Empty --\u003e EmitNewline: [#92;n]\n    EmitNewline --\u003e Emit: [^~]\n    EmitNewline --\u003e Escape: [~]\n    Escape --\u003e EmitEscapeCode: [B]\n    Escape --\u003e EmitTilde: [^B]\n    EmitTilde --\u003e Emit\n    EmitEscapeCode --\u003e Empty\n\nThe trickiest bit is that on \\n -\u003e ~ -\u003e [^B] you still need to emit ~ before whatever key comes after ~ that is not B.",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22f8818e_b0e74deb",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-03T03:27:35Z",
      "side": 1,
      "message": "As an experiment I implemented the state machine. We don\u0027t need quite so many states:\n\nhttps://gist.github.com/amboar/57e481ecd241f28a13b182ddcd1ca2cb\n\nHere\u0027s the output:\n\n```\n$ ./escape \\\n\u003e \"$(printf \"abc\")\" \\\n\u003e \"$(printf \"\\nabc\")\" \\\n\u003e \"$(printf \"\\n~abc\")\" \\\n\u003e \"$(printf \"\\n~Babc\")\" \\\n\u003e \"$(printf \"a\\n~Bbc\")\" \\\n\u003e \"$(printf \"ab\\n~Bc\")\" \\\n\u003e \"$(printf \"abc\\n~B\")\" \\\n\u003e \"$(printf \"abc\\n~\")\"\nabc\n---\n\nabc\n---\n\n~abc\n---\n\u003cBREAK\u003eabc\n---\na\u003cBREAK\u003ebc\n---\nab\u003cBREAK\u003ec\n---\nabc\u003cBREAK\u003e\n---\nabc\n~\n---\n```",
      "parentUuid": "3eb3b554_7ce31eea",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5950a21_5851fbb3",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2023-10-07T06:51:30Z",
      "side": 1,
      "message": "\u003e This is not quite the full picture.\n\nRight, we will update the state machine with a bit more details.",
      "parentUuid": "22f8818e_b0e74deb",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d61ff2d6_406d2a35",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1001852
      },
      "writtenOn": "2023-10-07T08:08:07Z",
      "side": 1,
      "message": "There is a more detailed state machine in patchset 5. These states should show the full picture.",
      "parentUuid": "f5950a21_5851fbb3",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7406a92f_6555ecdd",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1001852
      },
      "writtenOn": "2023-10-07T09:52:54Z",
      "side": 1,
      "message": "There is a problem in our solution. If a user paste a sequence with \"\\n~B\", such as \"ABCD\\n~Babcd\" or \"\\n~Bh\". obmc-console can not handle the sequence correctly, as OOB message can be anywhere in the sequence. Currently, we erase inputBuffer in bmcweb after sending OOB message and check buffer after receiving OOB in obmc-console. This guarantee sequence before “\\n~B” like \"ABCD\" in \"ABCD\\n~Babcd\" will be handled correctly, but lose sequence after “\\n~B” like \"abcd\" in \"ABCD\\n~Babcd\".\nAny suggestions？",
      "parentUuid": "d61ff2d6_406d2a35",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19895a0a_7ad5256c",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-08T03:24:18Z",
      "side": 1,
      "message": "If we\u0027re doing it all in-band, we can have obmc-console run the escape-detection state-machine, right? and it can just issue `tcsendbreak()` directly without requiring an OOB message on the AF_UNIX sockets?",
      "parentUuid": "7406a92f_6555ecdd",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "216db087_bcc945e7",
        "filename": "designs/sol-sysrq.md",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2023-10-08T03:39:01Z",
      "side": 1,
      "message": "To support ipmitool\u0027s break, it\u0027s handled by net-ipmid instead of obmc-console, the OOB message is needed.\nUnless we change net-ipmid to send the `\\n~B` sequence on the break handler?",
      "parentUuid": "19895a0a_7ad5256c",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "ed06134e0a1bde70d573f4d6ff805c52ee88e6bb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}