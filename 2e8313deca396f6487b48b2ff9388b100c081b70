{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9e92fac3_a7607b34",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "Looking like a good start, although I\u0027d really like the alternative discussed more.  If I missed conversations, please point me to them.",
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "343e45fb_dbf26e56",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "nit, replace with \"Single pmbus device\"  I don\u0027t think we expect cross-bus things here, and it\u0027s good to be explicit.",
      "range": {
        "startLine": 34,
        "startChar": 16,
        "endLine": 34,
        "endChar": 21
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b2da58b_e3108ed5",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-04-25T21:54:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "343e45fb_dbf26e56",
      "range": {
        "startLine": 34,
        "startChar": 16,
        "endLine": 34,
        "endChar": 21
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab9cfd88_868f0f34",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "Please call out that when these are paused, that they should return an Unavailable status interface.  This is going to be important for the dbus interfaces.",
      "range": {
        "startLine": 48,
        "startChar": 43,
        "endLine": 48,
        "endChar": 49
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b44f2aa_893a14aa",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-04-25T21:54:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ab9cfd88_868f0f34",
      "range": {
        "startLine": 48,
        "startChar": 43,
        "endLine": 48,
        "endChar": 49
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc5cba08_1dcdc77d",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "?  Shouldn\u0027t this just be handled within PSUSensor?  Why is systemd needed at all here?",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eef7e7fa_01bf3e5d",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-04-25T21:54:50Z",
      "side": 1,
      "message": "My thinking was that the software actually interacting with the device could be broken out for various reasons, but this doesn\u0027t need to be with systemd, it could just be a CLI called directly with boost-process like you mentioned below.\n\nAs far as why not include all of the logic in PSUSensor:\n- This makes it a bit more modular and more plug-in-play for anyone with existing tools to install firmware, they only need to write the config to call the appropriate tool. Also I expect some devices may not be made public, so this would make it more maintainable; there is no need to maintain any downstream patches.\n- The sensor reading logic is already deferred to hwmon sensors, so the firmware install logic would have a similar level of abstraction.\n\nI originally decided to go with systemd units because that is how the ItemUpdater is implemented in phosphor-bmc-code-mgmt. The Activation step simply calls a user supplied systemd service: https://github.com/openbmc/phosphor-bmc-code-mgmt/blob/master/obmc-flash-host-bios%40.service.in",
      "parentUuid": "fc5cba08_1dcdc77d",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f079623_09f98f2e",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-26T23:39:03Z",
      "side": 1,
      "message": "\u003e My thinking was that the software actually interacting with the device could be broken out for various reasons, but this doesn\u0027t need to be with systemd, it could just be a CLI called directly with boost-process like you mentioned below.\n\u003e \n\u003e As far as why not include all of the logic in PSUSensor:\n\u003e - This makes it a bit more modular and more plug-in-play for anyone with existing tools to install firmware, they only need to write the config to call the appropriate tool. Also I expect some devices may not be made public, so this would make it more maintainable; there is no need to maintain any downstream patches.\n\nIMO, the mechanism for modularity that we already have here is dbus, because we have a well defined way to define APIs, and maintain some semblance of a stable API over time.  Adding yet another avenue for plugins would have to answer lots of new questions about how we\u0027re going to maintain and extend it over time that I\u0027m not sure we have answers to.\n\n\u003e - The sensor reading logic is already deferred to hwmon sensors, so the firmware install logic would have a similar level of abstraction.\n\nWe \"defer\" to hwmon because it has a lower level of access, and has a stable, well defined ABI that we can rely on over time.  We didn\u0027t invent it ourselves.\n\n\u003e \n\u003e I originally decided to go with systemd units because that is how the ItemUpdater is implemented in phosphor-bmc-code-mgmt. The Activation step simply calls a user supplied systemd service: https://github.com/openbmc/phosphor-bmc-code-mgmt/blob/master/obmc-flash-host-bios%40.service.in\n\n\nYeah, we have that pattern, but that pattern kind of exposes exactly what I\u0027m talking about.  So far as I\u0027m aware, those service files don\u0027t expose a proper redfish interface.\n\n\n\nAs another example of something that systemd targets don\u0027t have a handle on is the idea of progress.  There\u0027s no way to transfer some progress percentage, and expose the dbus progress API for redfish to consume and supply to the user in this scheme.  If it\u0027s built into psusensor (or ADM1266daemon depending on how much of the code is device specific) exposing that interface in a future patch series becomes trivial.",
      "parentUuid": "eef7e7fa_01bf3e5d",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed983a92_dbb7115d",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-04-28T23:58:38Z",
      "side": 1,
      "message": "I expect some devices will definitely require a decent amount of specific code. Are you suggesting that code should belong in a separate daemon with a DBus API that PSUSensor would talk to, with PSUSensor providing the DBus API for Redfish (ItemUpdater API implementation)? Or that this ADM1266daemon implement the ItemUpdater API, import the PSUSensor class, and reuse (factor out, or just copy?) whatever is relevant from PSUSensorMain?",
      "parentUuid": "3f079623_09f98f2e",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21cdc2d2_aaaaf5e0",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-04-29T00:42:43Z",
      "side": 1,
      "message": "Also how much device-specific code is too much for it to not be included in PSUSensor?",
      "parentUuid": "ed983a92_dbb7115d",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d3c1fc0_ab8da83c",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-29T00:58:50Z",
      "side": 1,
      "message": "\u003e I expect some devices will definitely require a decent amount of specific code. \n\nThat\u0027s fine.  It\u0027s arguably the same architectural distinction between say, an NVMe sensor based on mctp, and a TMP75 sensor based on kernel sysfs.  They have almost no code in common, so they\u0027re put in different daemons.  The only reason we don\u0027t put everything in one \"super daemon\" is just for failure modes, so that one failing daemon doesn\u0027t kill off all sensors for the whole system.  We actually used to run daemon per-sensor, but that had resource and performance consequences so the middle ground of \"deamon per sensor class\" is what we\u0027ve landed on.\n\n\u003e Are you suggesting that code should belong in a separate daemon with a DBus API that PSUSensor would talk to, with PSUSensor providing the DBus API for Redfish (ItemUpdater API implementation)? Or that this ADM1266daemon implement the ItemUpdater API, import the PSUSensor class, and reuse (factor out, or just copy?) whatever is relevant from PSUSensorMain?\n\nBoth are possible;  Which we do is going to depend on how much code is truly device specific in practice, and that question is better answered in code review.  In the past, it\u0027s been found that while lots of things claim to require lots of implementation specific code, that device specific code is relatively small, and easy to abstract in such a way that it doesn\u0027t make a mess (ie file per device type?).  The fact that we can even abstract this to a systemd target tells me it\u0027s pretty doable to just have a switch table of manufacturer and model numbers, and call the appropriate functions for each device type, but I\u0027m open to other patterns.\n\n\nIf #including PSUSensor into ADM1266 is the approach that leads to the least code duplication, that seems fine to me.  I suspect that the PSUSensor class that exists today has some PSUSensor (the daemon) specific code in it at the moment, but this is the great part about abstractions, we can move that into PSUSensorMain, or into another class.",
      "parentUuid": "ed983a92_dbb7115d",
      "range": {
        "startLine": 69,
        "startChar": 61,
        "endLine": 71,
        "endChar": 8
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35325e3a_c4f5f102",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 88,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "Why are these separate services?  Just put the logic in PSUSensor directly.  As-written, this just feels like separate daemons with extra steps.  Proper error handling is going to be difficult (near impossible) with systemd targets.",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 88,
        "endChar": 3
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a231914_e15d96a8",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 88,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-04-25T17:31:45Z",
      "side": 1,
      "message": "Justin can chime in..\nbut what we\u0027ve seen in the past with pmbus devices is that there isn\u0027t a consistent \"version\" string implemented across the pmbus devices we\u0027ve seen.\nWhile some, like the ADM1266, have a nice mfg rev register we can use there are other devices where we\u0027ve had to be a bit more creative.\n\nFor version at least - systemd targets is one way of allowing for an OEM to specify their own version formatting.\n\nThe only other obvious solution is to create some plugin system.",
      "parentUuid": "35325e3a_c4f5f102",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 88,
        "endChar": 3
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da5ef204_89315a4f",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 88,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-26T23:39:03Z",
      "side": 1,
      "message": "\u003e but what we\u0027ve seen in the past with pmbus devices is that there isn\u0027t a consistent \"version\" string implemented across the pmbus devices we\u0027ve seen.\n\nThis is why the devicetype in entity-manager is the actual model number of the device, and not just generic \"PMBUS\".\n\n\u003ehave a nice mfg rev register\n\nYep, but this is ADM1266 specific, so openbmc needs to know it\u0027s talking to an ADM1266, which comes from the EM config file.",
      "parentUuid": "8a231914_e15d96a8",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 88,
        "endChar": 3
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e0ac528_7e8a1f3b",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 93,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "A problem that\u0027s solved by just putting the logic in PSUsensor.\n\nIn this case, depending on how much device-specific logic there is, we might want a \"ADM1266Device\" daemon, that just shares the sensor code through the object libraries we already have but I don\u0027t have context on how much code that is.",
      "range": {
        "startLine": 90,
        "startChar": 0,
        "endLine": 93,
        "endChar": 43
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7da80bbd_fc35f2fd",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 101,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "?  This doesn\u0027t track for me.  For built-in functions, we shouldn\u0027t be calling a CLI, and even if we needed to, fork/exec (or probably boost-process in this case) is doable to write, and the whole point of this design is that we don\u0027t call other daemons, all logic for managing a given device is in the daemon for said device.\n\nOne device, one daemon, to the extent possible.",
      "range": {
        "startLine": 100,
        "startChar": 8,
        "endLine": 101,
        "endChar": 61
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd8849a1_955cccd7",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "While I sympathize with your problems here, this is not the intent of openbmc, so it probably doesn\u0027t belong in this design doc.  If vendors don\u0027t want to produce source code, that\u0027s fine, but in upstream we\u0027re going to actively avoid complexity induced because vendors chose to not open source code.\n\nMy general advice in this case is when vendors do that, wrap that code in a daemon, expose the relevant dbus interfaces, and you\u0027ll be relatively insulated from the upstream changes, and relying on an interface that, while it does change, it\u0027s relatively rare and straightforward.",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 103,
        "endChar": 13
      },
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c8b8a6f_042ba3db",
        "filename": "designs/psusensor-fw-update.md",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-25T03:17:59Z",
      "side": 1,
      "message": "please discuss the security impacts of being able to update a device from outside the system, mitigations, and how it will be tested.",
      "revId": "2e8313deca396f6487b48b2ff9388b100c081b70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}