{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "608bbfff_1525ca75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "Thanks for the updates and replies. I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache.",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ee25269_f7f69859",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:57:59Z",
      "side": 1,
      "message": "I should have said I\u0027m not sure what to do about that feeling. I do understand the concerns around firmware update coordination, I\u0027m just struggling to feel comfortable with the flow-on effects.",
      "parentUuid": "608bbfff_1525ca75",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25275ea3_3ee43748",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "Shouldn\u0027t firmware update coordination be handled in-kernel?  Let the hwmon interfaces return EAGAIN if code update is being done and the sensors are unavailable.",
      "parentUuid": "4ee25269_f7f69859",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d525c826_2d742b79",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:33:53Z",
      "side": 1,
      "message": "\u003e\u003e Shouldn\u0027t firmware update coordination be handled in-kernel?\nNot according to the hwmon maintainer. An attempt was made, explicitly rejected and we were told this should be done in userspace. We respected the maintainer\u0027s decision and have since created some CLIs that do this in userspace.\nWe want to move away from hacking together services and shell scripts and formalize this into a daemon (the daemon proposed here).\n\nContext for those who are interested:\n\nhttps://lkml.org/lkml/2020/8/7/565\n\nNot going to let it happen through ioctls either\n\nhttps://lkml.org/lkml/2020/6/24/830\n\nWe tried once more through an informal chat. Maintainer\u0027s stance has not changed and he has asked us to sort this out ourselves.\n\n\u003e\u003e I\u0027m just struggling to feel comfortable with the flow-on effects.\n\u003e\u003e I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache\n\nI share your concern but I view the alternative as worse (coordinating firmware upgrades with telemetry). At least when it\u0027s all in one daemon you end up debugging a single code base and don\u0027t have to worry about things like dbus latency etc..\n\nIf it helps, we have the mindset of single device single owner.",
      "parentUuid": "25275ea3_3ee43748",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dd6f188_d6277639",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "Thanks for reworking this section, I like the result.",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c46eba88_aa992982",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "It\u0027s mentioned in another comment[1] that an API for firmware updates was tried and rejected. Do you have a link to the mailing list discussion? I think that would be handy background.\n\n[1] https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/50509/3/designs/i2c-device-mgmt.md#31",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f433b00_05a2df74",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "There is this which has been applied to linux-next:\n    https://lore.kernel.org/lkml/cover.1640007183.git.yu.c.chen@intel.com/\n\nIt is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nThere is also the existing (linux-kernel):Documentation/driver-api/firmware.  Is there any reason this can be leveraged by devices that want to do runtime-based firmware update?\n\n\u003e and the hwmon framework doesn\u0027t expose an API for firmware updates.\n\nThe hwmon framework never would expose an API for firmware update.  There would be a separate framework for firmware update and a device might support the APIs necessary for both the hwmon and \"firmware-update\" framework.",
      "parentUuid": "c46eba88_aa992982",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2de7c8e8_ac6771d2",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:52:05Z",
      "side": 1,
      "message": "\u003eIt is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nRight, but at this point we\u0027re talking about refactoring kernel code so we don\u0027t have to do something in userspace? I\u0027ve always taken the stance to do things in userspace and only put things into the kernel if I have no other choice (lower blast radius).\n\n\u003eThere is also the existing (linux-kernel):Documentation/driver-api/firmware. \nquickly reading through \"driver-api/firmware\" leaves me with the impression that this firmware is meant to be loaded onto devices in early boot.. to patch microcode or load something onto a microcontroller. Not our use-case.",
      "parentUuid": "4f433b00_05a2df74",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f7f25e8_c5f7e0dd",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-02-08T07:39:28Z",
      "side": 1,
      "message": "\u003e ... I\u0027ve always taken the stance to do things in userspace and only put things into the kernel if I have no other choice (lower blast radius).\n\nI believe we\u0027ve had this same discussion in the CMIS proposal.  This might be your stance but it isn\u0027t the project\u0027s stance.  Our stance is to work with upstream code-bases, especially the kernel, as much as possible so that the work we do can be leveraged by the broader community.\n\n\u003e quickly reading through \"driver-api/firmware\" leaves me with the impression that this firmware is meant to be loaded onto devices in early boot.. to patch microcode or load something onto a microcontroller. Not our use-case.\n\nSo let\u0027s discuss / propose improving that?\n\nI agree with Guenter\u0027s stance about not adding new APIs that are unique to PMBus/hwmon, but I disagree with his stance that \"nothing in the kernel should deal with update because it is \u0027dangerous\u0027\".  There are lots of things the kernel does that is potentially dangerous.  (We should really be having these discussions on the LKML though.  I don\u0027t fully grasp what the statement of \"the maintainer\u0027s mindset hasn\u0027t changed and expects us to \u0027work it out\u0027\" means.).\n\nIf there is already an API for getting binary blobs into the kernel to use as firmware for devices, this seems like a great starting point for getting binary blobs into the kernel to apply firmware updates for devices.  We should probably get some RFC sent upstream to see who disagrees and why.\n\nI\u0027m really not a fan of us yet again re-implementing support we already have (ie. dbus-sensors) and especially not also re-implementing the whole pmbus/hwmon subsystem in user-space.  I\u0027m also concerned about the error prone approach of having a separate daemon to handle firmware updates that unbinds the device from drivers out from underneath these existing daemons.  (I can\u0027t tell which direction you\u0027re proposing here because I\u0027ve read words that imply both.)  I really think the best approach is to figure out how to do firmware update of these devices cooperatively with the existing pmbus subsystem.",
      "parentUuid": "2de7c8e8_ac6771d2",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e85c4148_ead919b9",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-08T19:01:28Z",
      "side": 1,
      "message": "\u003e I don\u0027t fully grasp what the statement of \"the maintainer\u0027s mindset hasn\u0027t changed and expects us to \u0027work it out\u0027\" means.).\n\nIt means that we spoke to the maintainer of hwmon, his stance hasn\u0027t changed and he\u0027s asked us to leave him out of our debate on this matter.\n\n\u003e I\u0027m also concerned about the error prone approach of having a separate daemon to handle firmware updates that unbinds the device from drivers out from underneath these existing daemons.  (I can\u0027t tell which direction you\u0027re proposing here because I\u0027ve read words that imply both.) \n\nWe wanted to avoid nailing down exactly how we\u0027d do this. One of the core underlying assumption with this proposal is that the business logic of i2c firmware updates (present use-case targets pmbus) would be done in user space (motivated by our past failures to change hwmon/pmbus so to support a firmware update mechanism).\n\nDo I understand it correctly that you oppose handling i2c device updates in userspace?\nAs in a design proposal that specifies such an approach will be rejected?",
      "parentUuid": "8f7f25e8_c5f7e0dd",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f24d2cc_1bbc05d4",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-02-08T19:26:04Z",
      "side": 1,
      "message": "\u003e I really think the best approach is to figure out how to do firmware update of these devices cooperatively with the existing pmbus subsystem.\n\nOne approach would be to have a single i2c daemon that can pause telemetry during a firmware update. No bind/unbind needed. However, this only provides a weak opt-in exclusivity guarantee. Certainly an in-kernel approach can provide stronger guarantees.",
      "parentUuid": "e85c4148_ead919b9",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a37c44dd_4e9b1a84",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "\u003e We wanted to avoid nailing down exactly how we\u0027d do this.\n\nThis is a design doc.... it\u0027s kinda the point to at least throw the dart at the dartboard with \"here\u0027s what we\u0027re going to try first\", not necessarily nail down.  Keep in mind, this design doc isn\u0027t a binding legal contract.  Many..... many.... many times we\u0027ve got to the implementation phase and realized the design was totally borked, or slow, or didn\u0027t meet the design goals, and regrouped on a different plan.  Lets get documented what we think we want to build.  As we all know, \"no plan survives first contact with implementation\", that doesn\u0027t mean that it\u0027s not worth writing down what the plan is, and a hybrid hwmon/userspace approach is worth at least discussing.  The other reviewers might have some input here, given that on this review we have people that have implemented lots of variations of sensor subsystems, they might see a critical flaw and save us a lot of time.",
      "parentUuid": "7f24d2cc_1bbc05d4",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abad482d_b5e1407f",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "In order to support firmware update I think you\u0027re going to need a bit more information than just this.  Please take a look at the Software update design.  There are now compatibility strings that tell you the purpose of the device / image so they can be matched up.\n\nI could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I\u0027ll fry the board.  There quite likely would be a different VR image for different voltage rails.",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e38bda_2865282b",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:54:35Z",
      "side": 1,
      "message": "Wouldn\u0027t name be the unique identifier?\nThat is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAnd it will use the upgrade process relevant to \"I2CDeviceType\":\"adm1266\"",
      "parentUuid": "abad482d_b5e1407f",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c511f74_1f4e1bd6",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "\u003e I could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I\u0027ll fry the board.\n\nGross.... didn\u0027t think of that, but you\u0027re right, we probably need some kind of \"compat\" string in here?  How do VRs generally validate that a payload is for the intended rail?  Seems like anything we did there would be OEM/platform specific unless we invented (or standardized on something like fwupd) a firmware update payload.\n\n\n\u003e That is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAt dbus/interface level, you don\u0027t know which device has which address, and the same VR update might apply to multiples, so you can\u0027t really rely on the specific bus and address.  Also, in the case of EM files, bus might (is probably not) a fixed number.",
      "parentUuid": "34e38bda_2865282b",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7fc7d5f4_93633cc1",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "Okay, I more carefully read through the Software update design doc and I think I get what is being said here.\n\nLooks like targeting a particular image to a particular device is doable by decorating with the\n`Inventory.Decorator.Compatible` interface.\n\ne.g\n\n`foo.software.element.mainsequencer.type.ADM1266`\n\nor\n`foo.software.element.subsequencer2.type.ADM1266`\n\n\n\u003eHow do VRs generally validate that a payload is for the intended rail?\n\nFrom my experience they don\u0027t. You make sure to test your package updates carefully before you roll the update out to the entire fleet.\n\n\n\u003eAt dbus/interface level, you don\u0027t know which device has which address, and the same VR update might apply to multiples, so you can\u0027t really rely on the specific bus and address.  \n\nSure, it sounds like the compat decorator is how we\u0027d target a file for a particular group of devices. Seems like EM could contain the compat string when configuring this firmware upgrade daemon.. That way this daemon knows what images are meant for it.",
      "parentUuid": "1c511f74_1f4e1bd6",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07e5b40c_a37ea0c9",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "\u003e You make sure to test your package updates carefully before you roll the update out to the entire fleet.\n\nIn past systems I\u0027ve worked on we relied on the BMC signing and embedding the firmare to ensure that it wasn\u0027t available out of band.  Agreed, I think the compatible string could solve some things here, but from a security perspective, we need to make sure it\u0027s not possible to send the wrong payload to the wrong VR, overvolt the system and brick it.",
      "parentUuid": "7fc7d5f4_93633cc1",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}