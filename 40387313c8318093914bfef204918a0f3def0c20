{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "608bbfff_1525ca75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "Thanks for the updates and replies. I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache.",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ee25269_f7f69859",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:57:59Z",
      "side": 1,
      "message": "I should have said I\u0027m not sure what to do about that feeling. I do understand the concerns around firmware update coordination, I\u0027m just struggling to feel comfortable with the flow-on effects.",
      "parentUuid": "608bbfff_1525ca75",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25275ea3_3ee43748",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "Shouldn\u0027t firmware update coordination be handled in-kernel?  Let the hwmon interfaces return EAGAIN if code update is being done and the sensors are unavailable.",
      "parentUuid": "4ee25269_f7f69859",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d525c826_2d742b79",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:33:53Z",
      "side": 1,
      "message": "\u003e\u003e Shouldn\u0027t firmware update coordination be handled in-kernel?\nNot according to the hwmon maintainer. An attempt was made, explicitly rejected and we were told this should be done in userspace. We respected the maintainer\u0027s decision and have since created some CLIs that do this in userspace.\nWe want to move away from hacking together services and shell scripts and formalize this into a daemon (the daemon proposed here).\n\nContext for those who are interested:\n\nhttps://lkml.org/lkml/2020/8/7/565\n\nNot going to let it happen through ioctls either\n\nhttps://lkml.org/lkml/2020/6/24/830\n\nWe tried once more through an informal chat. Maintainer\u0027s stance has not changed and he has asked us to sort this out ourselves.\n\n\u003e\u003e I\u0027m just struggling to feel comfortable with the flow-on effects.\n\u003e\u003e I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache\n\nI share your concern but I view the alternative as worse (coordinating firmware upgrades with telemetry). At least when it\u0027s all in one daemon you end up debugging a single code base and don\u0027t have to worry about things like dbus latency etc..\n\nIf it helps, we have the mindset of single device single owner.",
      "parentUuid": "25275ea3_3ee43748",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dd6f188_d6277639",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "Thanks for reworking this section, I like the result.",
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c46eba88_aa992982",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-01-20T00:55:20Z",
      "side": 1,
      "message": "It\u0027s mentioned in another comment[1] that an API for firmware updates was tried and rejected. Do you have a link to the mailing list discussion? I think that would be handy background.\n\n[1] https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/50509/3/designs/i2c-device-mgmt.md#31",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f433b00_05a2df74",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "There is this which has been applied to linux-next:\n    https://lore.kernel.org/lkml/cover.1640007183.git.yu.c.chen@intel.com/\n\nIt is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nThere is also the existing (linux-kernel):Documentation/driver-api/firmware.  Is there any reason this can be leveraged by devices that want to do runtime-based firmware update?\n\n\u003e and the hwmon framework doesn\u0027t expose an API for firmware updates.\n\nThe hwmon framework never would expose an API for firmware update.  There would be a separate framework for firmware update and a device might support the APIs necessary for both the hwmon and \"firmware-update\" framework.",
      "parentUuid": "c46eba88_aa992982",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2de7c8e8_ac6771d2",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:52:05Z",
      "side": 1,
      "message": "\u003eIt is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nRight, but at this point we\u0027re talking about refactoring kernel code so we don\u0027t have to do something in userspace? I\u0027ve always taken the stance to do things in userspace and only put things into the kernel if I have no other choice (lower blast radius).\n\n\u003eThere is also the existing (linux-kernel):Documentation/driver-api/firmware. \nquickly reading through \"driver-api/firmware\" leaves me with the impression that this firmware is meant to be loaded onto devices in early boot.. to patch microcode or load something onto a microcontroller. Not our use-case.",
      "parentUuid": "4f433b00_05a2df74",
      "range": {
        "startLine": 21,
        "startChar": 11,
        "endLine": 21,
        "endChar": 78
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abad482d_b5e1407f",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:39:50Z",
      "side": 1,
      "message": "In order to support firmware update I think you\u0027re going to need a bit more information than just this.  Please take a look at the Software update design.  There are now compatibility strings that tell you the purpose of the device / image so they can be matched up.\n\nI could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I\u0027ll fry the board.  There quite likely would be a different VR image for different voltage rails.",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e38bda_2865282b",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-01-20T17:54:35Z",
      "side": 1,
      "message": "Wouldn\u0027t name be the unique identifier?\nThat is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAnd it will use the upgrade process relevant to \"I2CDeviceType\":\"adm1266\"",
      "parentUuid": "abad482d_b5e1407f",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c511f74_1f4e1bd6",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "\u003e I could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I\u0027ll fry the board.\n\nGross.... didn\u0027t think of that, but you\u0027re right, we probably need some kind of \"compat\" string in here?  How do VRs generally validate that a payload is for the intended rail?  Seems like anything we did there would be OEM/platform specific unless we invented (or standardized on something like fwupd) a firmware update payload.\n\n\n\u003e That is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAt dbus/interface level, you don\u0027t know which device has which address, and the same VR update might apply to multiples, so you can\u0027t really rely on the specific bus and address.  Also, in the case of EM files, bus might (is probably not) a fixed number.",
      "parentUuid": "34e38bda_2865282b",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 107,
        "endChar": 33
      },
      "revId": "40387313c8318093914bfef204918a0f3def0c20",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}