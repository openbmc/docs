{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "758cb73b_6ee83664",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "s",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccb395bd_07c4b9c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-07-29T23:51:46Z",
      "side": 1,
      "message": "No specific comments right now other than to note some prior art that might help with some of @alexander.hansen@9elements.com\u0027s concerns regarding compile-time selection of features:\n\nhttps://github.com/ibm-openbmc/platform-fru-detect",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e237d98f_4b0802ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "Thank you for the review.",
      "parentUuid": "ccb395bd_07c4b9c7",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "883d7a2b_21ed93ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-07-30T00:47:16Z",
      "side": 1,
      "message": "I have no specific comments at this time, as I understand there are several design-specific items that will need to be discussed and addressed as this repository evolves.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd5b48e3_73e8e39c",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "For requirement `4` i would like to propose doing this in `entity-manager` repository.\n\nInitializing hardware and detecting hardware cannot really be separated well currently and there are proposals to initialize i2c gpio muxes and such from entity-manager as well (https://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484).\n\nEven if it is a separate daemon from entity-manager i believe it will be easier to coordinate this development in an existing repo close to the detection and configuration logic.\n\nFrom my viewpoint there is a multi-stage initialization requirement.\n\n- static detection \n- gpio initialization(your proposal?)\n- dynamic detection (FruDevice, gpio presence, ...) \n- dynamic mux initialization\n- dynamic gpio initialization\n- possibly again dynamic detection\n- possibly again dynamic initialization\n- configuration\n- sensor daemons\n\nand EM may need to call into these custom initialization routines \nin case of dynamic initialization. Which is easier if that code is in the same repo.\n\nAlso there may be a preferred or required routine upon removal of a component which may require a custom de-initialization routine. That would also benefit from the code being available there.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa1520c3_60b65ccd",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e For requirement `4` i would like to propose doing this in `entity-manager` repository.\n\nAgreed, this is likely where it would go, but this design doesn\u0027t cover those details, just use them as a future requirement for why this repo should exist.\n\n\u003e \n\u003e Initializing hardware and detecting hardware cannot really be separated well currently and there are proposals to initialize i2c gpio muxes and such from entity-manager as well (https://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484).\n\nThese are initting GPIO muxes based on detected components, this repo is for initting based on image defined rules.\n\n\u003e \n\u003e Even if it is a separate daemon from entity-manager i believe it will be easier to coordinate this development in an existing repo close to the detection and configuration logic.\n\u003e \n\u003e From my viewpoint there is a multi-stage initialization requirement.\n\u003e \n\u003e - static detection \n\nThis is intentionally not in EM today.  EM is for per-device configuration.  If you can \"know\" at an image layer that a software resource exists, ideally we shouldn\u0027t try to detect it in EM.\n\n\u003e - gpio initialization(your proposal?)\n\nGPIO isn\u0027t unique here.  There\u0027s a lot more init that happens in platform init than just GPIO, and a lot of it requires a sequence or map of resources that can\u0027t be represented in an EM config.  For example\n\nStandby power needs asserted\nWait for power good\nInitialize sgpio\nwait for sgpio good\nInitialize GPIO expander\nRead/write GPIO to init hardware.\n\n\u003e - dynamic detection (FruDevice, gpio presence, ...) \n\u003e - dynamic mux initialization\n\u003e - dynamic gpio initialization\n\u003e - possibly again dynamic detection\n\u003e - possibly again dynamic initialization\n\u003e - configuration\n\u003e - sensor daemons\n\nYes, the rest is then handled by EM.\n\n\u003e \n\u003e and EM may need to call into these custom initialization routines \n\u003e in case of dynamic initialization. Which is easier if that code is in the same repo.\n\nFrom the \"explicitly out of scope\" section in entity-manager:\n\n\"Entity manager shall not directly participate in management of any specific device\"\n\nhttps://github.com/openbmc/entity-manager/blob/master/README.md\n\n\u003e \n\u003e Also there may be a preferred or required routine upon removal of a component which may require a custom de-initialization routine. That would also benefit from the code being available there.\n\nOverall, this application exists because I don\u0027t see a way technically to make these things entity-manager enabled, and imposing a fru scanning requirement would reduce the reliability, as well as cause a deadlock (some FRUs are behind the Voltage regulator on this platform)",
      "parentUuid": "fd5b48e3_73e8e39c",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55692022_f142a1c3",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e Overall, this application exists because I don\u0027t see a way technically to make these things entity-manager enabled, and imposing a fru scanning requirement would reduce the reliability, as well as cause a deadlock (some FRUs are behind the Voltage regulator on this platform)\n\nI mean it makes sense for simple initialization cases (single host, fixed board).\nBut if you consider blade servers too then these may need or want custom init routines aswell.\n\nSo the first initialization would need to be done before FruDevice as you said but blade initialization may need to be done based on dynamic detection.\n\nMy point is that there may need to be something in-between detection and EM exposing configuration. Which is the initialization step.\n\nSo having your code be in the EM repo would make it easier to call those handlers.\n\n\nI believe your use-case is similar to the i2c mux feature which is also concerned\nwith initialization\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484\n\nThe major difference being the stage at which the initialization happens (before / after FruDevice) and how it is configured static/dynamic.\n\nI see no reason why it cannot be supported to have a custom init routine for some hardware component after dynamic detection has started.\n\n\n\u003e Standby power needs asserted\nWait for power good\nInitialize sgpio\nwait for sgpio good\nInitialize GPIO expander\nRead/write GPIO to init hardware.\n\nMany of your mentioned use-cases also apply after i2c muxes have been configured and dynamic detection has happened.\n\nSo these init handlers will also need to be available at that point and cannot just be something to run once then forget about it.\n\n\u003e \"Entity manager shall not directly participate in management of any specific device\"\n\nMaybe it wont\u0027 be so bad if we have a simple handler architecture.\nWith ability to register fixed init functions based on the board\nand then register init / de-init handlers based on `Type` of configuration and also based on individual boards (once detected, not-fixed init)\n\nThis may be useful in your case aswell. So you can do custom init based on\nfields detected by `FruDevice` and handle some board variants/revisions differently.\n\nLike this:\n\n- fixed init hardcoded based on fw image\n- FruDevice starts\n- custom init based on fields from FRU Devices (handle board variants)\n- EM exposes board inventory\n- run custom handlers based on \u0027Type\u0027 of configuration\n- (e.g. init i2c muxes, gpio expanders, ...)\n- expose configuration record\n...\n\nFor example in the ipmi stack they have a way to register custom handler functions and it does not make the core code any more complicated.\n\nSince these handlers are all treated all the same with same function signature and so on.",
      "parentUuid": "aa1520c3_60b65ccd",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "014974ee_f887de82",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e But if you consider blade servers too\n\nFor me that is outside the scope of this design.  I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\nIf the blade center needed their standby power brought up , that would be a good use case for this.\n\n\u003e Many of your mentioned use-cases also apply after i2c muxes have been configured and dynamic detection has happened.... cannot just be something to run once then forget about it.\n\nAll of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\n\n\u003e Maybe it wont\u0027 be so bad if we have a simple handler architecture.\n\nIt\u0027s not about \"being bad\" it\u0027s about entity-manager being a common component that all systems can use, and application support being selectable based on component.\n\nThe point of this repo is for compile-time selection of init.  Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\n\n\u003e So you can do custom init based on fields detected by FruDevice\n\nThis is very explicitly outside of the requirements.  Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.",
      "parentUuid": "55692022_f142a1c3",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3067910f_793e523a",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "\u003e For me that is outside the scope of this design. I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\n\u003e All of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\nSo you are making something like a special purpose application which will likely only work for platforms similar to what you have.\n\nWhy not make something which fits your requirements but can be extended by others to fit their requirements also? \n\n\u003e This is very explicitly outside of the requirements. Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.\n\nYes the hardware can look however it was designed. Which is why we may need a flexible design which is not limited by it\u0027s own design to only run at the very beginning.\n\n\n\u003e The point of this repo is for compile-time selection of init. Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\nCompile-time selection of devices is just a fixed case of detection. There is no need to make any explicit distinction here? It is only a different source of information about which devices are present.\n\nCustom init handlers generalize to both statically and dynamically detected devices. It is reasonable to only implement what you need (fixed initialization handlers) but i would love to see something which can be re-used and extended.",
      "parentUuid": "014974ee_f887de82",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15c1f8ae_3601e9ab",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "\u003e \u003e For me that is outside the scope of this design. I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\u003e \n\u003e \u003e All of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\u003e \n\u003e So you are making something like a special purpose application which will likely only work for platforms similar to what you have.\n\u003e \n\nI would say I\u0027m making sure that I\u0027m not just reinventing entity-manager/phosphor-inventory in a different form.  If multi-node makes sense to do as a fixed compile-time image thing, I\u0027m open to seeing patches for it, I just don\u0027t have those requirements.  If there are things that need to be changed on reboot, those use cases are handled by other applications today (phosphor-state-manager for example).  The goal is not to duplicate function.\n\n\u003e Why not make something which fits your requirements but can be extended by others to fit their requirements also?\n\nOverall, what you described is the intent.  This requirement set is intentionally minimal in the hope that we can get a home for some of the common init routines, and we can start accepting peoples init routines for other platforms.\n\n\u003e \n\u003e \u003e This is very explicitly outside of the requirements. Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.\n\u003e \n\u003e Yes the hardware can look however it was designed. Which is why we may need a flexible design which is not limited by it\u0027s own design to only run at the very beginning.\n\n\nConcretely what changes do you think need made to the application to make a flexible design?  Could you put them in a gerrit review?  Some of what I want this repo for is so we can start to explore some of these ideas in code.\n\n\u003e \n\u003e \n\u003e \u003e The point of this repo is for compile-time selection of init. Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\u003e \n\u003e Compile-time selection of devices is just a fixed case of detection.\n\nI said selection of init.  This design has no concept of a \"device\".  If things can be modeled as a \"device\" that\u0027s detectable, I agree, that\u0027s where the line should end for this and entity-manager/reactors should begin.  In the examples in the repo today, compile-time selection is not just a fixed case of detection.\n\n\u003e There is no need to make any explicit distinction here? It is only a different source of information about which devices are present.\n\nThere are no distinction for \"devices\" here.  There is a known image that does known steps to init the platform its loaded on, no runtime detection.\n\n\u003e \n\u003e Custom init handlers generalize to both statically and dynamically detected devices. It is reasonable to only implement what you need (fixed initialization handlers) but i would love to see something which can be re-used and extended.\n\nMy thinking was that this would look a lot like how qemu is setup.  There are routines for each platform\n\nif (GB200){\n   do_gb200_specific_things();\n   do_common_thing_on_bus(2)\n} else if (TyanS7106){\n   do_tyan_specific_things();\n   do_common_thing_on_bus(3);\n}\n\nFunctions can be as common or as not common as we want them to be.  I\u0027m not really sure what custom init handlers means in code, but I\u0027m open to what it could look like.",
      "parentUuid": "3067910f_793e523a",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ba660ac_d16c2674",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-30T10:07:04Z",
      "side": 1,
      "message": "\u003e Concretely what changes do you think need made to the application to make a flexible design? \n\nTo confirm the requirement that hardware initialization is not limited to \u0027before FruDevice starts\u0027 but may need to happen any time a new hardware is added to the system. Including the custom handler functions.\n\nThe system being made up of a \u0027fixed\u0027 hardware and `0 or more` blades / expansion cards.\n\n\u003e I said selection of init. This design has no concept of a \"device\". If things can be modeled as a \"device\" that\u0027s detectable, I agree, that\u0027s where the line should end for this and entity-manager/reactors should begin. In the examples in the repo today, compile-time selection is not just a fixed case of detection.\n\nThere is a difference in compiled kernel modules, target SoC, devicetree, application support and such.\n\nBut that does not need to limit us in the overall architecture?\n\n\u003e There are no distinction for \"devices\" here. There is a known image that does known steps to init the platform its loaded on, no runtime detection.\n\nWe can simply assume that the image is running on the right hardware (otherwise it would make no sense to run hardware specific init functions) and therefore we have \u0027detected\u0027 it.\n\nI think we are running in circles here. My point is to generalize the design and not think in rigid categories like \u0027platform init\u0027. **The platform is just a device which cannot be removed, of which there is always only one, and which does not need to be detected at runtime.**\n\nThese specifics then allow to run the init handlers for the `platform device` before anything else (including `FruDevice`).\n\n```\nif (GB200){\ndo_gb200_specific_things();\ndo_common_thing_on_bus(2)\n} else if (TyanS7106){\ndo_tyan_specific_things();\ndo_common_thing_on_bus(3);\n}\n```\n\nI like this code sample. Here\u0027s another:\n\n```\nvoid gb200_init(){\n    do_gb200_specific_things();\n    do_common_thing_on_bus(2)\n}\n\ninit_routines \u003d {\n  {\"GB200\", gb200_init},\n  {\"TyanS7016, tyan_s7016_init},\n};\n\ninit_routines[fixed_device]();\n```\n\nWith this structure, init routines can be re-used for devices detected at runtime.\n\n```\nvoid onDeviceAdded(std::string\u0026 dynamic_device){\n\n    if (init_routines.contains(dynamic_device)){\n        init_routines[dynamic_device]();\n    }\n\n    logDeviceAdded(device);\n}\n```\n\nThis could work well with the dynamic i2c mux initialization\n\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484",
      "parentUuid": "15c1f8ae_3601e9ab",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55383bb5_ace6f6d2",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "Let\u0027s not from the get-go make it optional.\nIf it ends up being a big binary then maybe?\n\nThere is currently so much optionality in OpenBMC that it is leading to incompatibility between components.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2fb0c55_69d42c7b",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e Let\u0027s not from the get-go make it optional.\n\nIn the initial, SOME platform will need to be opt in.  I agree, ideally we\u0027d enable this everywhere, and for platforms that don\u0027t have definitions would just a be no-op.\n\n\u003e If it ends up being a big binary then maybe?\n\u003e \n\u003e There is currently so much optionality in OpenBMC that it is leading to incompatibility between components.\n\nThere\u0027s pros and cons to optionality.  From my perspective, I\u0027d like to see common solutions where there are common problems that can be solved once.  There\u0027s a lot more routines that can be made common by creating this platform init common application.",
      "parentUuid": "55383bb5_ace6f6d2",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31967f51_9fa1bfcd",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e In the initial, SOME platform will need to be opt in.\n\nWhat about making it opt-out.",
      "parentUuid": "f2fb0c55_69d42c7b",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa037601_351d232d",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e What about making it opt-out.\n\nCan\u0027t do that until we have something that works, then yes, I would advocate for it being opt-out.",
      "parentUuid": "31967f51_9fa1bfcd",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24bffce4_531af379",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "aa037601_351d232d",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59f7f29c_c66b7870",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "If there is a new repo, please have at least 2 maintainers, preferably from 2 different companies.\n\nTo provide a balanced viewpoint in the code review process and ensure the knowledge about how the thing works is not contained in just one person.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e29fefc_f406a240",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e If there is a new repo, please have at least 2 maintainers, preferably from 2 different companies.\n\u003e \n\u003e To provide a balanced viewpoint in the code review process and ensure the knowledge about how the thing works is not contained in just one person.\n\nThat\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.",
      "parentUuid": "59f7f29c_c66b7870",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3254d14_e3c39eb0",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:06:48Z",
      "side": 1,
      "message": "We also haven\u0027t enforced that in the past, and there are a number of repos that are single active maintainer.  Doing as you ask is certainly something to discuss, but I would ask that it doesn\u0027t block this review specifically.",
      "parentUuid": "4e29fefc_f406a240",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e9f186d_95b0e586",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e We also haven\u0027t enforced that in the past\n\nThen why not start this good habit now ðŸ˜Š\n\n\u003e That\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.\n\nI can volunteer to look at the init code if we can get it into `entity-manager` repo and not create yet another one.\n\nSince initialization and configuration are closely related and need to be coordinated well, i believe this application can go into `entity-manager` repo.\n\nAlso i believe the benefit of having more people to maintain this thing outweighs any benefits a separate repo could provide.",
      "parentUuid": "c3254d14_e3c39eb0",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56a2dce6_57eb4ecc",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e \u003e We also haven\u0027t enforced that in the past\n\u003e \n\u003e Then why not start this good habit now ðŸ˜Š\n\u003e \n\nBecause it\u0027s a separate concern.  Many people would debate \"good\".\n\n\u003e \u003e That\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.\n\u003e \n\u003e I can volunteer to look at the init code if we can get it into `entity-manager` repo and not create yet another one.\n\u003e \n\u003e Since initialization and configuration are closely related and need to be coordinated well, i believe this application can go into `entity-manager` repo.\n\n\nAs the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself.  I do not see how technically one could integrate this application with EM.  Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times.  This application proposed doesn\u0027t have a dbus interface.\n\n\u003e \n\u003e Also i believe the benefit of having more people to maintain this thing outweighs any benefits a separate repo could provide.\n\nI would love to see more people maintain this.  And FWIW, once i get the GPIO things solved, the next thing in my targets are the duplicated host interface scripts:\nhttps://github.com/openbmc/openbmc/blob/master/meta-fii/meta-kudo/recipes-kudo/network/usb-network/usb_network.sh\n\nThat should all be common.  I would expect to see a lot more maintainers be involved once that happens, but at the moment, I need to get the existing code moved to place that can be maintained at all (not in a company-specific meta layer).",
      "parentUuid": "8e9f186d_95b0e586",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b38ba306_5b517c89",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "\u003e As the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself. \n\nThen it will need to be handled with IPC which is even more complicated.\nI thought the intend behind the rule was to keep EM simple.\nExtra IPC interfaces are the opposite of that.\n\n\u003e I do not see how technically one could integrate this application with EM. Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times. This application proposed doesn\u0027t have a dbus interface.\n\nSetting a few gpios as part of initializing a blade should not take too long?\nOtherwise, the init can be done in a separate process which is spawned and we can async wait for it to complete?\n\n\u003e I would love to see more people maintain this.\n\nWhich is at odds with creating new repositories. Creating a lot of busy work and boilerplate code instead of leveraging an existing repo.\n\nFrom my perspective, starting a new repo with no other reviewers is just a way of sidestepping the community code review process.",
      "parentUuid": "56a2dce6_57eb4ecc",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "959a8c8d_b56529e3",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "\u003e \u003e As the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself. \n\u003e \n\u003e Then it will need to be handled with IPC which is even more complicated.\n\u003e I thought the intend behind the rule was to keep EM simple.\n\u003e Extra IPC interfaces are the opposite of that.\n\nIt\u0027s not clear where this IPC is coming from?  There is currently no IPC in this design, by design.  The moment we get into needing dbus/ipc/state, the design doesn\u0027t belong in this repo/application.\n\n\u003e \n\u003e \u003e I do not see how technically one could integrate this application with EM. Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times. This application proposed doesn\u0027t have a dbus interface.\n\u003e \n\u003e Setting a few gpios as part of initializing a blade should not take too long?\n\nThis design and application does more than set GPIOs.  There are cases where it needs to wait for GPIOs to assert, that does take some time.\n\n\u003e Otherwise, the init can be done in a separate process which is spawned and we can async wait for it to complete?\n\nThat design would make this a full reactor, and largely defeat the purpose of doing a known initialization.\n\n\u003e \n\u003e \u003e I would love to see more people maintain this.\n\u003e \n\u003e Which is at odds with creating new repositories. Creating a lot of busy work and boilerplate code instead of leveraging an existing repo.\n\u003e \n\u003e From my perspective, starting a new repo with no other reviewers is just a way of sidestepping the community code review process.\n\nFWIW, this was discussed some in TOF, and creating a new repository was what was asked for.  This code is currently in a meta layer, which is even worse than a common repo with one maintainer.  I\u0027m actually hoping that by pulling in use cases into a common repo instead of putting it in meta layer scripts that they get more scrutiny and review, not less.\n\nThe structure I\u0027d really like to see in this repo is that each platform is in a folder, and each platform maintainer is in the OWNERS for that folder.  Common layers will be reviewed by all platform maintainers that pull in the common components.\n\nOverall, this is something that I think the project needs, and I\u0027m open to having other maintainers.  The only reason I\u0027m requesting a new repo is that there wasn\u0027t a logical place to put general hardware init code.  Most thusfar have been putting it in meta layers, which makes it harder to share.",
      "parentUuid": "b38ba306_5b517c89",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "645d4407_3b9df38a",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-30T10:07:04Z",
      "side": 1,
      "message": "\u003e The only reason I\u0027m requesting a new repo is that there wasn\u0027t a logical place to put general hardware init code.\n\nDoes the place to put it really need to be the \u0027logical\u0027 place if there is other convincing advantages?\n\nConsider this:\n\n- strategy A: Make a new repo from the get-go, then perhaps later struggle to integrate it with EM. Create all structure from scratch and maintain by yourself.\n\n- strategy B: Put it in EM repo, get reviewers and existing structure for free.\n You can always later rip it out and put into another repo. Properly structured meson projects are quite portable in this way.\n\n\nWhat\u0027s the advantage in creating another repo?\n\nYou can even create a separate bitbake recipe if the code is in an existing repo.\nJust set the right meson options.\n\nIf you want to keep an existing bitbake recipe, you can deploy or pull things into the image separately due to split pkg.\n\nBecause of the regex matching with gerrit you can have separate reviewers / owners even for code in the same repo.\n\nAnd you only have to declare the wrap files and dependencies once.\n\nWhat do you really get from yet another repo? Another git remote and and a separate url on github? Consider if you really need it.\n\n\nWhat you are proposing is not a library or something that will *certainly* be re-used by other projects, or is it?",
      "parentUuid": "959a8c8d_b56529e3",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}