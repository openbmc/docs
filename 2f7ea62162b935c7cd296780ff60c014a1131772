{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "758cb73b_6ee83664",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "s",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccb395bd_07c4b9c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-07-29T23:51:46Z",
      "side": 1,
      "message": "No specific comments right now other than to note some prior art that might help with some of @alexander.hansen@9elements.com\u0027s concerns regarding compile-time selection of features:\n\nhttps://github.com/ibm-openbmc/platform-fru-detect",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e237d98f_4b0802ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "Thank you for the review.",
      "parentUuid": "ccb395bd_07c4b9c7",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "883d7a2b_21ed93ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-07-30T00:47:16Z",
      "side": 1,
      "message": "I have no specific comments at this time, as I understand there are several design-specific items that will need to be discussed and addressed as this repository evolves.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c7fb0d4_8a128f07",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T15:37:34Z",
      "side": 1,
      "message": "Thank you for reviewing.",
      "parentUuid": "883d7a2b_21ed93ab",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3ac9193_94873953",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2025-08-12T20:13:21Z",
      "side": 1,
      "message": "Good to see the robust discussion on this one. I think in the end, this get us somewhere better then where we are today, and given that Ed is a maintainer of EM, I think we just go with this proposal.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd5b48e3_73e8e39c",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "For requirement `4` i would like to propose doing this in `entity-manager` repository.\n\nInitializing hardware and detecting hardware cannot really be separated well currently and there are proposals to initialize i2c gpio muxes and such from entity-manager as well (https://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484).\n\nEven if it is a separate daemon from entity-manager i believe it will be easier to coordinate this development in an existing repo close to the detection and configuration logic.\n\nFrom my viewpoint there is a multi-stage initialization requirement.\n\n- static detection \n- gpio initialization(your proposal?)\n- dynamic detection (FruDevice, gpio presence, ...) \n- dynamic mux initialization\n- dynamic gpio initialization\n- possibly again dynamic detection\n- possibly again dynamic initialization\n- configuration\n- sensor daemons\n\nand EM may need to call into these custom initialization routines \nin case of dynamic initialization. Which is easier if that code is in the same repo.\n\nAlso there may be a preferred or required routine upon removal of a component which may require a custom de-initialization routine. That would also benefit from the code being available there.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa1520c3_60b65ccd",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e For requirement `4` i would like to propose doing this in `entity-manager` repository.\n\nAgreed, this is likely where it would go, but this design doesn\u0027t cover those details, just use them as a future requirement for why this repo should exist.\n\n\u003e \n\u003e Initializing hardware and detecting hardware cannot really be separated well currently and there are proposals to initialize i2c gpio muxes and such from entity-manager as well (https://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484).\n\nThese are initting GPIO muxes based on detected components, this repo is for initting based on image defined rules.\n\n\u003e \n\u003e Even if it is a separate daemon from entity-manager i believe it will be easier to coordinate this development in an existing repo close to the detection and configuration logic.\n\u003e \n\u003e From my viewpoint there is a multi-stage initialization requirement.\n\u003e \n\u003e - static detection \n\nThis is intentionally not in EM today.  EM is for per-device configuration.  If you can \"know\" at an image layer that a software resource exists, ideally we shouldn\u0027t try to detect it in EM.\n\n\u003e - gpio initialization(your proposal?)\n\nGPIO isn\u0027t unique here.  There\u0027s a lot more init that happens in platform init than just GPIO, and a lot of it requires a sequence or map of resources that can\u0027t be represented in an EM config.  For example\n\nStandby power needs asserted\nWait for power good\nInitialize sgpio\nwait for sgpio good\nInitialize GPIO expander\nRead/write GPIO to init hardware.\n\n\u003e - dynamic detection (FruDevice, gpio presence, ...) \n\u003e - dynamic mux initialization\n\u003e - dynamic gpio initialization\n\u003e - possibly again dynamic detection\n\u003e - possibly again dynamic initialization\n\u003e - configuration\n\u003e - sensor daemons\n\nYes, the rest is then handled by EM.\n\n\u003e \n\u003e and EM may need to call into these custom initialization routines \n\u003e in case of dynamic initialization. Which is easier if that code is in the same repo.\n\nFrom the \"explicitly out of scope\" section in entity-manager:\n\n\"Entity manager shall not directly participate in management of any specific device\"\n\nhttps://github.com/openbmc/entity-manager/blob/master/README.md\n\n\u003e \n\u003e Also there may be a preferred or required routine upon removal of a component which may require a custom de-initialization routine. That would also benefit from the code being available there.\n\nOverall, this application exists because I don\u0027t see a way technically to make these things entity-manager enabled, and imposing a fru scanning requirement would reduce the reliability, as well as cause a deadlock (some FRUs are behind the Voltage regulator on this platform)",
      "parentUuid": "fd5b48e3_73e8e39c",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55692022_f142a1c3",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e Overall, this application exists because I don\u0027t see a way technically to make these things entity-manager enabled, and imposing a fru scanning requirement would reduce the reliability, as well as cause a deadlock (some FRUs are behind the Voltage regulator on this platform)\n\nI mean it makes sense for simple initialization cases (single host, fixed board).\nBut if you consider blade servers too then these may need or want custom init routines aswell.\n\nSo the first initialization would need to be done before FruDevice as you said but blade initialization may need to be done based on dynamic detection.\n\nMy point is that there may need to be something in-between detection and EM exposing configuration. Which is the initialization step.\n\nSo having your code be in the EM repo would make it easier to call those handlers.\n\n\nI believe your use-case is similar to the i2c mux feature which is also concerned\nwith initialization\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484\n\nThe major difference being the stage at which the initialization happens (before / after FruDevice) and how it is configured static/dynamic.\n\nI see no reason why it cannot be supported to have a custom init routine for some hardware component after dynamic detection has started.\n\n\n\u003e Standby power needs asserted\nWait for power good\nInitialize sgpio\nwait for sgpio good\nInitialize GPIO expander\nRead/write GPIO to init hardware.\n\nMany of your mentioned use-cases also apply after i2c muxes have been configured and dynamic detection has happened.\n\nSo these init handlers will also need to be available at that point and cannot just be something to run once then forget about it.\n\n\u003e \"Entity manager shall not directly participate in management of any specific device\"\n\nMaybe it wont\u0027 be so bad if we have a simple handler architecture.\nWith ability to register fixed init functions based on the board\nand then register init / de-init handlers based on `Type` of configuration and also based on individual boards (once detected, not-fixed init)\n\nThis may be useful in your case aswell. So you can do custom init based on\nfields detected by `FruDevice` and handle some board variants/revisions differently.\n\nLike this:\n\n- fixed init hardcoded based on fw image\n- FruDevice starts\n- custom init based on fields from FRU Devices (handle board variants)\n- EM exposes board inventory\n- run custom handlers based on \u0027Type\u0027 of configuration\n- (e.g. init i2c muxes, gpio expanders, ...)\n- expose configuration record\n...\n\nFor example in the ipmi stack they have a way to register custom handler functions and it does not make the core code any more complicated.\n\nSince these handlers are all treated all the same with same function signature and so on.",
      "parentUuid": "aa1520c3_60b65ccd",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "014974ee_f887de82",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e But if you consider blade servers too\n\nFor me that is outside the scope of this design.  I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\nIf the blade center needed their standby power brought up , that would be a good use case for this.\n\n\u003e Many of your mentioned use-cases also apply after i2c muxes have been configured and dynamic detection has happened.... cannot just be something to run once then forget about it.\n\nAll of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\n\n\u003e Maybe it wont\u0027 be so bad if we have a simple handler architecture.\n\nIt\u0027s not about \"being bad\" it\u0027s about entity-manager being a common component that all systems can use, and application support being selectable based on component.\n\nThe point of this repo is for compile-time selection of init.  Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\n\n\u003e So you can do custom init based on fields detected by FruDevice\n\nThis is very explicitly outside of the requirements.  Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.",
      "parentUuid": "55692022_f142a1c3",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3067910f_793e523a",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "\u003e For me that is outside the scope of this design. I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\n\u003e All of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\nSo you are making something like a special purpose application which will likely only work for platforms similar to what you have.\n\nWhy not make something which fits your requirements but can be extended by others to fit their requirements also? \n\n\u003e This is very explicitly outside of the requirements. Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.\n\nYes the hardware can look however it was designed. Which is why we may need a flexible design which is not limited by it\u0027s own design to only run at the very beginning.\n\n\n\u003e The point of this repo is for compile-time selection of init. Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\nCompile-time selection of devices is just a fixed case of detection. There is no need to make any explicit distinction here? It is only a different source of information about which devices are present.\n\nCustom init handlers generalize to both statically and dynamically detected devices. It is reasonable to only implement what you need (fixed initialization handlers) but i would love to see something which can be re-used and extended.",
      "parentUuid": "014974ee_f887de82",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15c1f8ae_3601e9ab",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "\u003e \u003e For me that is outside the scope of this design. I do not support blade servers, and presumably each blade would be a detected entity, so that would be a completely different design.\n\u003e \n\u003e \u003e All of the use cases mentioned for my platform are in fact run once and don\u0027t re-run until a reboot.\n\u003e \n\u003e So you are making something like a special purpose application which will likely only work for platforms similar to what you have.\n\u003e \n\nI would say I\u0027m making sure that I\u0027m not just reinventing entity-manager/phosphor-inventory in a different form.  If multi-node makes sense to do as a fixed compile-time image thing, I\u0027m open to seeing patches for it, I just don\u0027t have those requirements.  If there are things that need to be changed on reboot, those use cases are handled by other applications today (phosphor-state-manager for example).  The goal is not to duplicate function.\n\n\u003e Why not make something which fits your requirements but can be extended by others to fit their requirements also?\n\nOverall, what you described is the intent.  This requirement set is intentionally minimal in the hope that we can get a home for some of the common init routines, and we can start accepting peoples init routines for other platforms.\n\n\u003e \n\u003e \u003e This is very explicitly outside of the requirements. Keep in mind, on some platforms the FRUs are actually behind initted hardware, so no FRUs are available until power rails are initted.\n\u003e \n\u003e Yes the hardware can look however it was designed. Which is why we may need a flexible design which is not limited by it\u0027s own design to only run at the very beginning.\n\n\nConcretely what changes do you think need made to the application to make a flexible design?  Could you put them in a gerrit review?  Some of what I want this repo for is so we can start to explore some of these ideas in code.\n\n\u003e \n\u003e \n\u003e \u003e The point of this repo is for compile-time selection of init. Entity-manager is for runtime selection of devices, and instantiation of inventory, both of which are not part of platform-init.\n\u003e \n\u003e Compile-time selection of devices is just a fixed case of detection.\n\nI said selection of init.  This design has no concept of a \"device\".  If things can be modeled as a \"device\" that\u0027s detectable, I agree, that\u0027s where the line should end for this and entity-manager/reactors should begin.  In the examples in the repo today, compile-time selection is not just a fixed case of detection.\n\n\u003e There is no need to make any explicit distinction here? It is only a different source of information about which devices are present.\n\nThere are no distinction for \"devices\" here.  There is a known image that does known steps to init the platform its loaded on, no runtime detection.\n\n\u003e \n\u003e Custom init handlers generalize to both statically and dynamically detected devices. It is reasonable to only implement what you need (fixed initialization handlers) but i would love to see something which can be re-used and extended.\n\nMy thinking was that this would look a lot like how qemu is setup.  There are routines for each platform\n\nif (GB200){\n   do_gb200_specific_things();\n   do_common_thing_on_bus(2)\n} else if (TyanS7106){\n   do_tyan_specific_things();\n   do_common_thing_on_bus(3);\n}\n\nFunctions can be as common or as not common as we want them to be.  I\u0027m not really sure what custom init handlers means in code, but I\u0027m open to what it could look like.",
      "parentUuid": "3067910f_793e523a",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ba660ac_d16c2674",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-30T10:07:04Z",
      "side": 1,
      "message": "\u003e Concretely what changes do you think need made to the application to make a flexible design? \n\nTo confirm the requirement that hardware initialization is not limited to \u0027before FruDevice starts\u0027 but may need to happen any time a new hardware is added to the system. Including the custom handler functions.\n\nThe system being made up of a \u0027fixed\u0027 hardware and `0 or more` blades / expansion cards.\n\n\u003e I said selection of init. This design has no concept of a \"device\". If things can be modeled as a \"device\" that\u0027s detectable, I agree, that\u0027s where the line should end for this and entity-manager/reactors should begin. In the examples in the repo today, compile-time selection is not just a fixed case of detection.\n\nThere is a difference in compiled kernel modules, target SoC, devicetree, application support and such.\n\nBut that does not need to limit us in the overall architecture?\n\n\u003e There are no distinction for \"devices\" here. There is a known image that does known steps to init the platform its loaded on, no runtime detection.\n\nWe can simply assume that the image is running on the right hardware (otherwise it would make no sense to run hardware specific init functions) and therefore we have \u0027detected\u0027 it.\n\nI think we are running in circles here. My point is to generalize the design and not think in rigid categories like \u0027platform init\u0027. **The platform is just a device which cannot be removed, of which there is always only one, and which does not need to be detected at runtime.**\n\nThese specifics then allow to run the init handlers for the `platform device` before anything else (including `FruDevice`).\n\n```\nif (GB200){\ndo_gb200_specific_things();\ndo_common_thing_on_bus(2)\n} else if (TyanS7106){\ndo_tyan_specific_things();\ndo_common_thing_on_bus(3);\n}\n```\n\nI like this code sample. Here\u0027s another:\n\n```\nvoid gb200_init(){\n    do_gb200_specific_things();\n    do_common_thing_on_bus(2)\n}\n\ninit_routines \u003d {\n  {\"GB200\", gb200_init},\n  {\"TyanS7016, tyan_s7016_init},\n};\n\ninit_routines[fixed_device]();\n```\n\nWith this structure, init routines can be re-used for devices detected at runtime.\n\n```\nvoid onDeviceAdded(std::string\u0026 dynamic_device){\n\n    if (init_routines.contains(dynamic_device)){\n        init_routines[dynamic_device]();\n    }\n\n    logDeviceAdded(device);\n}\n```\n\nThis could work well with the dynamic i2c mux initialization\n\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75484",
      "parentUuid": "15c1f8ae_3601e9ab",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5881253a_c7997479",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T15:37:34Z",
      "side": 1,
      "message": "\u003e may need to happen any time a new hardware is added to the system\n\nIn my mind there\u0027s a large difference between \"platform init\" and \"device init\". A \"platform\" cannot be removed, it is a property of the image loaded.  I really think that runtime detection is well covered by entity-manager and reactors today, and I do want to draw some amount of a line to it\u0027s clear where each type of init \"should\" go.\n\n\u003e With this structure, init routines can be re-used for devices detected at runtime.\n\nThe code you posted looks like an improvement, but I\u0027m not sure where the detection would happen or how it would happen?  I see a string for \"TyanS7106\" but it\u0027s not clear to me where fixed_device would come from?  If it\u0027s ultimately coming from a meson option, I\u0027m in support of that model, and will pivot the code to do that once this repository is approved.  I don\u0027t have a detection requirement for the platforms that I would like this to target, so that might need to be a different design.\n\nFWIW, two of the platforms I\u0027d like to have common code for are actually Intel platforms not made by my employer, so I\u0027m fairly sure there\u0027s some broad applicability.",
      "parentUuid": "8ba660ac_d16c2674",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a24d8bf2_4cc6e878",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-31T10:18:03Z",
      "side": 1,
      "message": "\u003e In my mind there\u0027s a large difference between \"platform init\" and \"device init\". A \"platform\" cannot be removed, it is a property of the image loaded.\n\nI see no *fundamental* difference between a platform init and a device init which would *justify* any design constraint which may be limiting for OpenBMC in the future.\n\nThe platform is just a device which is known to exist and initialized first, before other devices. From BMC perspective the `platform` is always present.\n\n\u003e I do want to draw some amount of a line to it\u0027s clear where each type of init \"should\" go.\n\nI am not sure where you would draw that line exactly? To me that sounds like some kind of discrimination where the platform is some kind of blessed device that gets treated differently?\n\n\n\u003e  If it\u0027s ultimately coming from a meson option, I\u0027m in support of that model, and will pivot the code to do that once this repository is approved\n\nYes. The `fixed_device` string is coming from the fw image in my example. It\u0027s known beforehand and not detected at runtime.",
      "parentUuid": "5881253a_c7997479",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52591009_f3e3c73e",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-01T18:33:50Z",
      "side": 1,
      "message": "\u003e \u003e In my mind there\u0027s a large difference between \"platform init\" and \"device init\". A \"platform\" cannot be removed, it is a property of the image loaded.\n\u003e \n\u003e I see no *fundamental* difference between a platform init and a device init which would *justify* any design constraint which may be limiting for OpenBMC in the future.\n\nDevices are detected at runtime, platforms are detected at startup.  That is why there are quite a few scripts now put into meta layers today.  Overall, I think this design is an improvement on what exists.\n\n\u003e \n\u003e The platform is just a device which is known to exist and initialized first, before other devices. From BMC perspective the `platform` is always present.\n\nThe platform will not be self contained in a single inventory item, that is one of the distinctions that have put a number of scripts in meta layers.  The init scripts also don\u0027t host any telemetry or inventory, so enforcing that they do both of those would be a lot of effort.\n\n\u003e \n\u003e \u003e I do want to draw some amount of a line to it\u0027s clear where each type of init \"should\" go.\n\u003e \n\u003e I am not sure where you would draw that line exactly? To me that sounds like some kind of discrimination where the platform is some kind of blessed device that gets treated differently?\n\nBecause we have different images per platform, that is already \"blessed\" by the project.  The goal here is to reduce the variability and copy-based between those already blessed images.\n\n\u003e \n\u003e \n\u003e \u003e  If it\u0027s ultimately coming from a meson option, I\u0027m in support of that model, and will pivot the code to do that once this repository is approved\n\u003e \n\u003e Yes. The `fixed_device` string is coming from the fw image in my example. It\u0027s known beforehand and not detected at runtime.\n\nOk, so I think we\u0027re on the same page on that point.",
      "parentUuid": "a24d8bf2_4cc6e878",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63ee5e53_84a62d07",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-04T09:12:20Z",
      "side": 1,
      "message": "\u003e Overall, I think this design is an improvement on what exists.\n\nYes. Having a single application to put the init logic is an improvement and will lead to better re-use of common initialization routines. Error handling and logging of the init logic should also improve as a result.\n\n100% agree on that. The C++ application is better than a bunch of copy-pasted shell scripts.\n\nBut we can go one step further and already think about enabling the next step which would require custom init handlers to be integrated with EM.\n\nIf you make a new repo it will make that next step that much harder and require to redo the whole thing again.",
      "parentUuid": "52591009_f3e3c73e",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4580051a_a2726509",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-05T22:56:23Z",
      "side": 1,
      "message": "\u003e \n\u003e If you make a new repo it will make that next step that much harder and require to redo the whole thing again.\n\nI\u0027m not sure i understand why where the code is located makes turning this into an EM reactor in the future harder?  There are no EM reactors in the EM repo today, they\u0027re in dbus-sensors or individual repos.  Can you elaborate a little?\n\nIf someone has a design that they want to go through with that requires the code to move, I\u0027m happy to even help move it, but as this design is defined (and carefully crafted to avoid scope creep) EM integration is not required, nor has requirements here.",
      "parentUuid": "63ee5e53_84a62d07",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d57805d8_7009543d",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-06T07:49:35Z",
      "side": 1,
      "message": "\u003e There are no EM reactors in the EM repo today, they\u0027re in dbus-sensors or individual repos. Can you elaborate a little?\n\n`gpio-presence` is an EM reactor, right?\n\n\u003e I\u0027m not sure i understand why where the code is located makes turning this into an EM reactor in the future harder?\n\nHaving more repos makes *everything* harder.\n\nNeeding more patches to get anything done.\n\nIf your proposed init code and entity-manager share the same repo, then someone can add both init and EM config for a platform in a single patch.\n\nWhich has the advantage that the platform does not get stuck in some stage where it has init but no config, or config but no init.",
      "parentUuid": "4580051a_a2726509",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ccbf4b0_0216fe46",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-08-18T20:22:54Z",
      "side": 1,
      "message": "I\u0027m not a fan of mono-repos.  I don\u0027t see a good overlap between this work and entity-manager.  We can always add service dependencies as/if needed to ensure we do the right thing here.  I think some platforms are going to be able to do their base-board detection without this code and some will not.  There probably isn\u0027t a strong tie between them.  More likely, fru-device might be precluded from running in some platforms until the initial init is done.",
      "parentUuid": "d57805d8_7009543d",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3637281c_e690c8d3",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-19T10:03:19Z",
      "side": 1,
      "message": "\u003e I\u0027m not a fan of mono-repos.\n\nGrouping a few related features does not turn OpenBMC into a mono-repo.\n\n\u003e We can always add service dependencies as/if needed to ensure we do the right thing here.\n\nsystemd-level service ordering prevents the fine-grained ordering and may introduce some extra delay until `multi-user.target` is ready.\n\n\u003e I don\u0027t see a good overlap between this work and entity-manager.\n\nFine with me, since you agreed to help maintain/review this new repo.",
      "parentUuid": "5ccbf4b0_0216fe46",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd5ee6c7_5e688b64",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-08-18T20:12:12Z",
      "side": 1,
      "message": "I don\u0027t know if we have to support this now, but I\u0027d also like this to be the place that we also add phosphor-state-manager hooks.  This might enable alternate executables and/or sub-commands.\n\n1. Do you want to add a sentence about that now?\n2. Should we make the executable be a sub-command for the \"initial\" init for the first go?",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff3b5ff4_877bf190",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-18T20:33:07Z",
      "side": 1,
      "message": "I\u0027m 100% in support of that, but intentionally didn\u0027t add it because I didn\u0027t want to further complicate the doc.  If you think it\u0027s necessary to add a sentence to that effect for this to merge, I can do that, but I\u0027d prefer to keep it to just init for now just for simplicity.\n\nHappy to add a sub command (probably using cli11).   I think starting with something that doesn\u0027t parse CLI at all is easier as a first patchset, but I can put that up as a patchset in short order.",
      "parentUuid": "fd5ee6c7_5e688b64",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48b9b9a8_57440cfb",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1002459
      },
      "writtenOn": "2025-08-19T22:27:28Z",
      "side": 1,
      "message": "Does this document only cover the initialization portion or do we want to cover all power on/off/cycle too? \n\nCould we potentially have our \"platform_power_control\" link to phosphor-state-manager through dbus so we can have custom init, on, off, etc in C++?",
      "parentUuid": "ff3b5ff4_877bf190",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61b6464b_b62311d2",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-08-18T20:12:12Z",
      "side": 1,
      "message": "I\u0027d prefer we drop this.  No reason to also support bash.",
      "range": {
        "startLine": 39,
        "startChar": 11,
        "endLine": 40,
        "endChar": 22
      },
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd515b7f_e9f0cfa5",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-18T20:33:07Z",
      "side": 1,
      "message": "My thinking was that step 1 was to get all the bash scripts into one place so people quit extending and copy/pasting them, then step 2 was to start conslidating them porting them into this application.  Lots of issues stem from folks just copying scripts in the tree without realizing they\u0027re maybe not the best, so my hope was to improve that, but sure, I can remove this.\n\nWith all that said, I\u0027ve dropped this sentence.",
      "parentUuid": "61b6464b_b62311d2",
      "range": {
        "startLine": 39,
        "startChar": 11,
        "endLine": 40,
        "endChar": 22
      },
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0c6e7c8_6bca6d46",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-08-18T20:12:12Z",
      "side": 1,
      "message": "I see that \"detection\" is left as a future exercise.  Do we want to remove the meson option and compile all platforms in, but have the platform as an argument in the service file?  We can default to \"detect\" (which is maybe a no-op for now).",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 53,
        "endChar": 40
      },
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c528ddb_a82f8245",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-18T20:33:07Z",
      "side": 1,
      "message": "My original thinking was that if we have to pull in an odd dependency, like peci-utils, you probably don\u0027t want to have that dependency on a non-intel platform, but sure, I think we can start with just including all platforms and handle that case when and if it comes up.\n\nI\u0027ve updated the doc to swap meson option -\u003e CLI option.",
      "parentUuid": "d0c6e7c8_6bca6d46",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 53,
        "endChar": 40
      },
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55383bb5_ace6f6d2",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "Let\u0027s not from the get-go make it optional.\nIf it ends up being a big binary then maybe?\n\nThere is currently so much optionality in OpenBMC that it is leading to incompatibility between components.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2fb0c55_69d42c7b",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e Let\u0027s not from the get-go make it optional.\n\nIn the initial, SOME platform will need to be opt in.  I agree, ideally we\u0027d enable this everywhere, and for platforms that don\u0027t have definitions would just a be no-op.\n\n\u003e If it ends up being a big binary then maybe?\n\u003e \n\u003e There is currently so much optionality in OpenBMC that it is leading to incompatibility between components.\n\nThere\u0027s pros and cons to optionality.  From my perspective, I\u0027d like to see common solutions where there are common problems that can be solved once.  There\u0027s a lot more routines that can be made common by creating this platform init common application.",
      "parentUuid": "55383bb5_ace6f6d2",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31967f51_9fa1bfcd",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e In the initial, SOME platform will need to be opt in.\n\nWhat about making it opt-out.",
      "parentUuid": "f2fb0c55_69d42c7b",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa037601_351d232d",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e What about making it opt-out.\n\nCan\u0027t do that until we have something that works, then yes, I would advocate for it being opt-out.",
      "parentUuid": "31967f51_9fa1bfcd",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24bffce4_531af379",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "aa037601_351d232d",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59f7f29c_c66b7870",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T13:45:44Z",
      "side": 1,
      "message": "If there is a new repo, please have at least 2 maintainers, preferably from 2 different companies.\n\nTo provide a balanced viewpoint in the code review process and ensure the knowledge about how the thing works is not contained in just one person.",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e29fefc_f406a240",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:04:33Z",
      "side": 1,
      "message": "\u003e If there is a new repo, please have at least 2 maintainers, preferably from 2 different companies.\n\u003e \n\u003e To provide a balanced viewpoint in the code review process and ensure the knowledge about how the thing works is not contained in just one person.\n\nThat\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.",
      "parentUuid": "59f7f29c_c66b7870",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3254d14_e3c39eb0",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T16:06:48Z",
      "side": 1,
      "message": "We also haven\u0027t enforced that in the past, and there are a number of repos that are single active maintainer.  Doing as you ask is certainly something to discuss, but I would ask that it doesn\u0027t block this review specifically.",
      "parentUuid": "4e29fefc_f406a240",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e9f186d_95b0e586",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-28T17:23:37Z",
      "side": 1,
      "message": "\u003e We also haven\u0027t enforced that in the past\n\nThen why not start this good habit now ðŸ˜Š\n\n\u003e That\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.\n\nI can volunteer to look at the init code if we can get it into `entity-manager` repo and not create yet another one.\n\nSince initialization and configuration are closely related and need to be coordinated well, i believe this application can go into `entity-manager` repo.\n\nAlso i believe the benefit of having more people to maintain this thing outweighs any benefits a separate repo could provide.",
      "parentUuid": "c3254d14_e3c39eb0",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56a2dce6_57eb4ecc",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-28T17:52:03Z",
      "side": 1,
      "message": "\u003e \u003e We also haven\u0027t enforced that in the past\n\u003e \n\u003e Then why not start this good habit now ðŸ˜Š\n\u003e \n\nBecause it\u0027s a separate concern.  Many people would debate \"good\".\n\n\u003e \u003e That\u0027s fine, and I\u0027m in support, but without someone volunteering this comment isn\u0027t really actionable.\n\u003e \n\u003e I can volunteer to look at the init code if we can get it into `entity-manager` repo and not create yet another one.\n\u003e \n\u003e Since initialization and configuration are closely related and need to be coordinated well, i believe this application can go into `entity-manager` repo.\n\n\nAs the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself.  I do not see how technically one could integrate this application with EM.  Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times.  This application proposed doesn\u0027t have a dbus interface.\n\n\u003e \n\u003e Also i believe the benefit of having more people to maintain this thing outweighs any benefits a separate repo could provide.\n\nI would love to see more people maintain this.  And FWIW, once i get the GPIO things solved, the next thing in my targets are the duplicated host interface scripts:\nhttps://github.com/openbmc/openbmc/blob/master/meta-fii/meta-kudo/recipes-kudo/network/usb-network/usb_network.sh\n\nThat should all be common.  I would expect to see a lot more maintainers be involved once that happens, but at the moment, I need to get the existing code moved to place that can be maintained at all (not in a company-specific meta layer).",
      "parentUuid": "8e9f186d_95b0e586",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b38ba306_5b517c89",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-29T10:03:00Z",
      "side": 1,
      "message": "\u003e As the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself. \n\nThen it will need to be handled with IPC which is even more complicated.\nI thought the intend behind the rule was to keep EM simple.\nExtra IPC interfaces are the opposite of that.\n\n\u003e I do not see how technically one could integrate this application with EM. Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times. This application proposed doesn\u0027t have a dbus interface.\n\nSetting a few gpios as part of initializing a blade should not take too long?\nOtherwise, the init can be done in a separate process which is spawned and we can async wait for it to complete?\n\n\u003e I would love to see more people maintain this.\n\nWhich is at odds with creating new repositories. Creating a lot of busy work and boilerplate code instead of leveraging an existing repo.\n\nFrom my perspective, starting a new repo with no other reviewers is just a way of sidestepping the community code review process.",
      "parentUuid": "56a2dce6_57eb4ecc",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "959a8c8d_b56529e3",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T00:09:12Z",
      "side": 1,
      "message": "\u003e \u003e As the entity-manager maintainer, I would like to maintain the rule that EM does not participate in hardware management itself. \n\u003e \n\u003e Then it will need to be handled with IPC which is even more complicated.\n\u003e I thought the intend behind the rule was to keep EM simple.\n\u003e Extra IPC interfaces are the opposite of that.\n\nIt\u0027s not clear where this IPC is coming from?  There is currently no IPC in this design, by design.  The moment we get into needing dbus/ipc/state, the design doesn\u0027t belong in this repo/application.\n\n\u003e \n\u003e \u003e I do not see how technically one could integrate this application with EM. Doing so would involve blocking the main dbus reactor, which would be bad for dbus response times. This application proposed doesn\u0027t have a dbus interface.\n\u003e \n\u003e Setting a few gpios as part of initializing a blade should not take too long?\n\nThis design and application does more than set GPIOs.  There are cases where it needs to wait for GPIOs to assert, that does take some time.\n\n\u003e Otherwise, the init can be done in a separate process which is spawned and we can async wait for it to complete?\n\nThat design would make this a full reactor, and largely defeat the purpose of doing a known initialization.\n\n\u003e \n\u003e \u003e I would love to see more people maintain this.\n\u003e \n\u003e Which is at odds with creating new repositories. Creating a lot of busy work and boilerplate code instead of leveraging an existing repo.\n\u003e \n\u003e From my perspective, starting a new repo with no other reviewers is just a way of sidestepping the community code review process.\n\nFWIW, this was discussed some in TOF, and creating a new repository was what was asked for.  This code is currently in a meta layer, which is even worse than a common repo with one maintainer.  I\u0027m actually hoping that by pulling in use cases into a common repo instead of putting it in meta layer scripts that they get more scrutiny and review, not less.\n\nThe structure I\u0027d really like to see in this repo is that each platform is in a folder, and each platform maintainer is in the OWNERS for that folder.  Common layers will be reviewed by all platform maintainers that pull in the common components.\n\nOverall, this is something that I think the project needs, and I\u0027m open to having other maintainers.  The only reason I\u0027m requesting a new repo is that there wasn\u0027t a logical place to put general hardware init code.  Most thusfar have been putting it in meta layers, which makes it harder to share.",
      "parentUuid": "b38ba306_5b517c89",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "645d4407_3b9df38a",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-30T10:07:04Z",
      "side": 1,
      "message": "\u003e The only reason I\u0027m requesting a new repo is that there wasn\u0027t a logical place to put general hardware init code.\n\nDoes the place to put it really need to be the \u0027logical\u0027 place if there is other convincing advantages?\n\nConsider this:\n\n- strategy A: Make a new repo from the get-go, then perhaps later struggle to integrate it with EM. Create all structure from scratch and maintain by yourself.\n\n- strategy B: Put it in EM repo, get reviewers and existing structure for free.\n You can always later rip it out and put into another repo. Properly structured meson projects are quite portable in this way.\n\n\nWhat\u0027s the advantage in creating another repo?\n\nYou can even create a separate bitbake recipe if the code is in an existing repo.\nJust set the right meson options.\n\nIf you want to keep an existing bitbake recipe, you can deploy or pull things into the image separately due to split pkg.\n\nBecause of the regex matching with gerrit you can have separate reviewers / owners even for code in the same repo.\n\nAnd you only have to declare the wrap files and dependencies once.\n\nWhat do you really get from yet another repo? Another git remote and and a separate url on github? Consider if you really need it.\n\n\nWhat you are proposing is not a library or something that will *certainly* be re-used by other projects, or is it?",
      "parentUuid": "959a8c8d_b56529e3",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b1e1880_de992f77",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-30T15:37:34Z",
      "side": 1,
      "message": "\u003e \u003e The only reason I\u0027m requesting a new repo is that there wasn\u0027t a logical place to put general hardware init code.\n\u003e \n\u003e Does the place to put it really need to be the \u0027logical\u0027 place if there is other convincing advantages?\n\u003e \n\u003e Consider this:\n\u003e \n\u003e - strategy A: Make a new repo from the get-go, then perhaps later struggle to integrate it with EM. Create all structure from scratch and maintain by yourself.\n\u003e \n\u003e - strategy B: Put it in EM repo, get reviewers and existing structure for free.\n\u003e  You can always later rip it out and put into another repo. Properly structured meson projects are quite portable in this way.\n\nI don\u0027t believe those are mutually exclusive, and FWIW, there was some consensus before I pushed this that we didn\u0027t want this to go into a reactor, and I was asked by TOF to request a repo.  I absolutely want other people to help maintain this, I don\u0027t think moving the repo itself gets reviewers for free.\n\n\u003e \n\u003e \n\u003e What\u0027s the advantage in creating another repo?\n\nWe have a place where we can start moving the multitude of bash scripts, init routines, and other things that exist in meta layers and could be more common.  Entity-managers folder structure isn\u0027t set up for per-image ownership or code.\n\n\u003e \n\u003e You can even create a separate bitbake recipe if the code is in an existing repo.\n\u003e Just set the right meson options.\n\u003e \n\u003e If you want to keep an existing bitbake recipe, you can deploy or pull things into the image separately due to split pkg.\n\nAgreed, the recipe part is not the concern.\n\n\u003e \n\u003e Because of the regex matching with gerrit you can have separate reviewers / owners even for code in the same repo.\n\nAgreed, in this doc as it stands I intend to use that.\n\n\u003e \n\u003e And you only have to declare the wrap files and dependencies once.\n\u003e \n\u003e What do you really get from yet another repo? Another git remote and and a separate url on github? Consider if you really need it.\n\nopt-in for platforms.  I agree the repo itself isn\u0027t the most important part, but having multiple applications in a single repository has been a source of confusion in the past, and I don\u0027t know of a case where we\u0027ve split the recipe.\n\n\u003e \n\u003e \n\u003e What you are proposing is not a library or something that will *certainly* be re-used by other projects, or is it?\n\nit is _not_ a library, and while it would be reused, it is not intended to be reused in other applications.  It will pull in relevant libraries for IO it needs to do (libgpio etc).",
      "parentUuid": "645d4407_3b9df38a",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96d460fc_bff26617",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-31T10:18:03Z",
      "side": 1,
      "message": "\u003e FWIW, there was some consensus before I pushed this that we didn\u0027t want this to go into a reactor,\n\nI am not asking for a reactor because initially (fixed initialization) there is not much to react to.\n\n\u003e We have a place where we can start moving the multitude of bash scripts, init routines, and other things that exist in meta layers and could be more common. Entity-managers folder structure isn\u0027t set up for per-image ownership or code.\n\nJust make a change to `OWNERS` file then? Use `mkdir` to create some new directories?\n\n\u003e but having multiple applications in a single repository has been a source of confusion in the past\n\nThis is how `phosphor-bmc-code-mgmt\u0027 is currently being developed. There has not been any pushback on having multiple applications in the same repository.\n\nAlso for the gpio-presence there has not been any issue i am aware of where people had problems to find the code.\n\n\u003e it is not a library, and while it would be reused, it is not intended to be reused in other applications. It will pull in relevant libraries for IO it needs to do (libgpio etc).\n\nSince we know that a hardware can be both a platform and a device, the code developed for hardware init needs to be available for initialization of dynamically detected hardware as well.\n\nSo it makes sense to put it into `entity-manager` repo so anyone who wants to develop that integration will have an easier time doing so, instead of creating multiple patches across 3+ repositories.",
      "parentUuid": "5b1e1880_de992f77",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b5d5201_12058554",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-01T18:33:50Z",
      "side": 1,
      "message": "\u003e \u003e FWIW, there was some consensus before I pushed this that we didn\u0027t want this to go into a reactor,\n\u003e \n\u003e I am not asking for a reactor because initially (fixed initialization) there is not much to react to.\n\u003e \n\u003e \u003e We have a place where we can start moving the multitude of bash scripts, init routines, and other things that exist in meta layers and could be more common. Entity-managers folder structure isn\u0027t set up for per-image ownership or code.\n\u003e \n\u003e Just make a change to `OWNERS` file then? Use `mkdir` to create some new directories?\n\nThat doesn\u0027t solve the recipe/meson option/dependency issues.  EM specifically have almost no dependencies to try to make it \n\n\u003e \n\u003e \u003e but having multiple applications in a single repository has been a source of confusion in the past\n\u003e \n\u003e This is how `phosphor-bmc-code-mgmt\u0027 is currently being developed. There has not been any pushback on having multiple applications in the same repository.\n\u003e \n\u003e Also for the gpio-presence there has not been any issue i am aware of where people had problems to find the code.\n\u003e \n\u003e \u003e it is not a library, and while it would be reused, it is not intended to be reused in other applications. It will pull in relevant libraries for IO it needs to do (libgpio etc).\n\u003e \n\u003e Since we know that a hardware can be both a platform and a device, the code developed for hardware init needs to be available for initialization of dynamically detected hardware as well.\n\u003e \n\u003e So it makes sense to put it into `entity-manager` repo so anyone who wants to develop that integration will have an easier time doing so, instead of creating multiple patches across 3+ repositories.",
      "parentUuid": "96d460fc_bff26617",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6579b9c5_fa573a3d",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-04T09:12:20Z",
      "side": 1,
      "message": "\u003e That doesn\u0027t solve the recipe/meson option/dependency issues. \n\nThere\u0027s a number of recipes already which can add dependencies based on `PKGCONFIG` so it would not be an issue. The dependencies for a recipe do not have to be fixed.\n\n\u003e EM specifically have almost no dependencies to try to make it \n\nTo me this sounds like\n\n`X cannot do Y so we need Z but it\u0027s fine since X has almost no dependencies.`\n\nFor the downstream this can be very confusing. Instead of selection meson options mapping to features, you are making it into a 2-stage problem of first selecting the right applications and then configuring them.\n\nThere is a problem now with `phosphor-sel-logger` https://github.com/openbmc/phosphor-sel-logger/\n(comment reference https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/75997/comments/94d4e919_915a8c55)\n\nwhere the scenario already happened like this.\nThe optional application was created to fill some use-case, but because of the optionality, it cannot be relied upon.\n\nIn the end, the feature had to be implemented `3 times` in the different sensor repos which require structured logging for threshold events.",
      "parentUuid": "2b5d5201_12058554",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1861727b_2b0e56ba",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-05T22:56:23Z",
      "side": 1,
      "message": "\u003e \u003e That doesn\u0027t solve the recipe/meson option/dependency issues. \n\u003e \n\u003e There\u0027s a number of recipes already which can add dependencies based on `PKGCONFIG` so it would not be an issue. The dependencies for a recipe do not have to be fixed.\n\u003e \n\u003e \u003e EM specifically have almost no dependencies to try to make it \n\u003e \n\u003e To me this sounds like\n\u003e \n\u003e `X cannot do Y so we need Z but it\u0027s fine since X has almost no dependencies.`\n\nThat\u0027s not a correct characterization.  Entity-manager cannot take per-plaftorm dependencies BECAUSE it is a common core component that we would expect all systems to be able to take.  Yes, PKGCONFIG can alleviate some of these problems, but doesn\u0027t solve the ability for backends to be swapped out at will (or removed entirely) that was part of why EM and dbus-sensors/other reactors are different repositories.  As EM maintainer, I don\u0027t want to lose that requirement just yet.\n\n\u003e \n\u003e For the downstream this can be very confusing. Instead of selection meson options mapping to features, you are making it into a 2-stage problem of first selecting the right applications and then configuring them.\n\u003e \n\u003e There is a problem now with `phosphor-sel-logger` https://github.com/openbmc/phosphor-sel-logger/\n\u003e (comment reference https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/75997/comments/94d4e919_915a8c55)\n\u003e \n\u003e where the scenario already happened like this.\n\u003e The optional application was created to fill some use-case, but because of the optionality, it cannot be relied upon.\n\u003e \n\u003e In the end, the feature had to be implemented `3 times` in the different sensor repos which require structured logging for threshold events.\n\nLet\u0027s keep this review focused concretely on this design.  While I certainly have opinions on what should happen with the 2 SEL designs, they have very different constraints than this design does in regards to user-facing APIs (that cannot change without breaking people) as well as matching standards bodies that design things that are difficult to implement.  This repository (by design) has ties to neither a user-facing API nor a standard, so it\u0027s largely unrelated.",
      "parentUuid": "6579b9c5_fa573a3d",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c551928_70906326",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-06T07:49:35Z",
      "side": 1,
      "message": "\u003e Yes, PKGCONFIG can alleviate some of these problems, but doesn\u0027t solve the ability for backends to be swapped out at will (or removed entirely) that was part of why EM and dbus-sensors/other reactors are different repositories\n\nI assume backends can be swapped out via `PKGCONFIG` and meson options as well?\n\nIn bmcweb we configure which EventLog backend to use based on meson options.\n\nIt works well because in meson files you can then check for valid and invalid combinations of options fairly easily.\n\nAdding recipes to an image build is more of a \u0027you are on your own here\u0027 kind of deal where ultimately the platform maintainer becomes responsible to see if the combination of recipes they chose will even work together.",
      "parentUuid": "1861727b_2b0e56ba",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bb21f52_24581ba5",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-09T07:32:32Z",
      "side": 1,
      "message": "\u003e I assume backends can be swapped out via PKGCONFIG and meson options as well?\n\nNot in the design, no.\n\n\u003e In bmcweb we configure which EventLog backend to use based on meson options.\n\nYou\u0027re interchanging two different \"backend\" terms here (and for this reason in bmcweb Gunnar correctly asked they be called \"features\").  In bmcweb, these enable sections of code/paths, in a very similar way to what\u0027s being described here.  In the EM case it could be a completely different implementation, like omnisensor, which doesn\u0027t use meson or c++ at all.\n\n\u003e ultimately the platform maintainer becomes responsible\n\nI would go even beyond that and say that this is free open source software.  By the license there are no guarantees of utility.  Arguably whomever compiles the code is responsible for their own use.",
      "parentUuid": "8c551928_70906326",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3848a4c_b2ba1649",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-08-18T20:22:54Z",
      "side": 1,
      "message": "You can add my name as a second maintainer if there are no other volunteers.",
      "parentUuid": "6bb21f52_24581ba5",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df1142f6_a70b3c0b",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-08-18T20:33:07Z",
      "side": 1,
      "message": "I\u0027ve added your name to the doc.",
      "parentUuid": "b3848a4c_b2ba1649",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "069c87e4_cea36369",
        "filename": "designs/platform-init.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-19T10:03:19Z",
      "side": 1,
      "message": "\u003e You can add my name as a second maintainer if there are no other volunteers.\n\nðŸ‘. Then we will at least have the proper community review process for this repo.",
      "parentUuid": "df1142f6_a70b3c0b",
      "revId": "2f7ea62162b935c7cd296780ff60c014a1131772",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}