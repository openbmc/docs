# PLDM transport layer abstraction for MCTP and NCSI over RBT

  Naveen Moses S (naveen.moses), [naveen.mosess@hcl.com](mailto:naveen.mosess@hcl.com)
  Velumani T (velu),  [velumanit@hcl](mailto:velumanit@hcl.com)

Primary assignee: Naveen Moses S

Created: October 6, 2021

## Problem Description
The PLDM stack in OpenBMC currently supports PLDM over MCTP transport layer.
Being an application layer PLDM can support additional transport protocols
such as NCSI over RBT. To enable support for such transport an abstraction
layer is required.

This design proposes a common set of apis for PLDM request and response
for both MCTP and NCSI over RBT transport layer and provides abstraction of
 transport protocols based on terminus id.

The proposed PLDM request apis accepts terminus id
and PLDM request as parameters for supported transport layers(MCTP,NCSI etc).
This common api calls then internally maps the transport layer
specific PLDM apis based on the given pldm_tid_t terminus id.

## Assumptions
- The additional transport layer is considered as the NCSI over RBT.

## Background and References

#### PLDM stack design :
https://github.com/openbmc/docs/blob/master/designs/pldm-stack.md

### libpldm pldm requester apis
https://github.com/openbmc/pldm/blob/master/libpldm/requester/pldm.c

### PLDM request class
https://github.com/openbmc/pldm/blob/master/requester/request.hpp

### PLDM handler class
https://github.com/openbmc/pldm/blob/master/requester/handler.hpp

## Requirements

- The PLDM request api should have common interfaces to send / receive
 PLDM packets for supported transport layers based on PLDM terminus id.

- The PLDM request api should abstract transport layer specific parameters.

- The discovery and mapping of PLDM terminus id with the underlying transport
  layer endpoints shall be done dynamically or done as static config based on
  the transport layer / device capability.

- The transport layer specific PLDM request libraries (NCSI, MCTP) should
 be included in the PLDM repository.

- The initialization of the transport layer and drivers should be handled
 separately and not part of this wrapper.

## Transport layer identification

## Terminus id discovery and EID mapping

    In order to make the transport layer abstracted from the PLDM client app
the PLDM request api should accept PLDM terminus id as parameter along
with the PLDM request message. The mapping of the terminus id to
the transport layer specific endpoints (EID or RBT UID) should be done
in the discovery phase which is done by the PLDM wrapper when the pldmd
service is started.

    When  calling the PLDM requester api, the terminus id
(pldm_tid_t) is passed as one of the parameters.
 The PLDM wrapper requester api deduces mapped transport layer endpoints
from this terminus id parameter and calls corresponding transport layer
PLDM request api.

- At the start of PLDM daemon it invokes the discovery of PLDM terminus by
 calling discoverTIDS() method which is provided by transport layer wrapper,
  which then gathers the endpoint info for MCTP and NCSI exposed over dbus
  made available by respective process daemons.

### MCTP terminus id mapping
- The transport layer wrapper library queries about MCTP Endpoints
exposed over D-Bus call which are discoverd by the mctp daemon.

- Each discovered eid is then polled to check any one of pldm types

- The EIDs with minimum PLDM type support is polled for the PLDM device
terminus id and a one to one mapping is created for the terminus id and eid.

- Incase if the mctp does not have terminus id supported then
    a virtual terminus id is created and mapped to the device with the eid.

Note : virtual tid is a way of having a terminus id generated by bmc itself
in case the PLDM terminus does not support setTID command. The bmc should
have the mapping of the underlying transport endpoint(EID/RBT UID) to this
virtual TID.
### NCSI terminus id mapping
- Terminus id mapping for NCSI transport layer terminus id is done by
    mapping to ncsi parameters such as package id, channel id and interface.

- The NCSI parametrs are read from the entity manager config and
      a virtual terminus id is set for each individual ncsi device parameter.

## PLDM  transport wrapper design

- The new PLDM request apis accepts the terminus id and PLDM parameters.

- It should provide api to discovery of transport layer based device
endpoints(EID or RBT UID).

- If the PLDM is supported assigning terminus id to supported PLDM terminus
create a map of terminus id with for corresponding endpoint.

- If set Terminus id is not supported then the PLDM wrapper can create a
virtual terminus id and map it with the transport layer
specific endpoints(EID or RBT UID).

- The PLDM wrapper requester should have linkage to the ncsi based pldm
   and mctp based PLDM apis.

## PLDM terminus lifecycle management
 A separate daemon/handler is created to add newly discoverd
terminus in the PLDM terminus dbus object when they are available.
 It also monitors for PLDM terminus non availability
 at runtime  and it should depopulate the PLDM terminus info from the DBUS object.

 Two separate pldm terminus lifecycle handlers should be created for MCTP based
 PLDM devices as well as NCSI over RBT based PLDM devices.

 In case the endpoint config is mentioned as static config(It can be static MCTP
 endpoint info or static NCSI endpoint parameters), then the PLDM terminus
 lifecycle manager will not handle PLDM terminus removal.

### MCTP PLDM terminus lifecycle manager
- The MCTP daemon supports discovery and population
   of endpoint details on dbus.
-  The MCTP based PLDM terminus lifecycle handler uses the MCTP endpoint discovery
  api to dynamically handle addition and removal of PLDM terminus.

### NCSI PLDM device lifecycle manager
- When PLDM daemon triggers the discover terminus at startup
this NCSI PLDM terminus lifecycle manager handler is started.
- It is responsible for adding the discovered PLDM terminus over Dbus.
- If the NCSI PLDM terminus supports async event notification for PLDM terminus
   removal, then a handler is implemented to depopulate the respective
   PLDM terminus from the PLDM device dbus object.
- In case the PLDM device discovery is static configuration then
 the PLDM terminus lifecycle management deoes not handle PLDM terminus removal.

### NCSI transport layer library details
- The NCSI over RBT library is added as a separate library which will
be part of PLDM repo.
- This library apis are configured to send only PLDM requests over NCSI.
- It is a socket based library which uses generic netlink library.

```

vector<pldm_tid_t> tids discoverTIDs()

pldm_requester_rc_t pldm_send(pldm_tid_t tid,
			      const uint8_t *pldm_req_msg, size_t req_msg_len)

pldm_requester_rc_t pldm_send_recv(pldm_tid_t tid,
				   const uint8_t *pldm_req_msg,
				   size_t req_msg_len, uint8_t **pldm_resp_msg,
				   size_t *resp_msg_len)

pldm_requester_rc_t pldm_recv(pldm_tid_t tid, uint8_t instance_id,
			      uint8_t **pldm_resp_msg, size_t *resp_msg_len)

pldm_requester_rc_t pldm_recv_any(pldm_tid_t tid,
				  uint8_t **pldm_resp_msg, size_t *resp_msg_len)
```

## Proposed PLDMD requester and handler changes

 PLDMD requester code consists of the following two classes
 1. request - calls libpldm api to send PLDM request
 2. handler - creates object of request class with PLDM request msg and
  initiates  PLDM request when **registerRequest** member method is called.

 Currently the pldmd request and handler classes are also has mctp association.

 The PLDM requester exposes registerRequest() method
 to send and receive pldmd messages asynchronously which currently accepts
  mctp parameters.

```
    int registerRequest(mctp_eid_t eid, uint8_t instanceId, uint8_t type,
                        uint8_t command, pldm::Request&& requestMsg,
                        ResponseHandler&& responseHandler)
```

 This api shall be modified to accept terminus id and PLDM request message as
 parameters.

```
    int registerRequest(pldm_tid_t tid, uint8_t instanceId, uint8_t type,
                        uint8_t command, pldm::Request&& requestMsg,
                        ResponseHandler&& responseHandler)

```
 The registerrequest internally calls the PLDM transport wrapper with the
 provided terminus id and PLDM request message.

 The PLDM wrapper calls the corresponding TID - endpoint id map to
 and calls the transport layer specific call with the mapped endpoint parameters.

## Proposed PLDM message transaction process flow

```
+-------------------+     +----------------+      +---------------+    +----------------+
|                   |     |                |      | PLDM transport|    |                |
| bmc requester /   |     | PLDM Daemon    |      |  wrapper /    |    |   transport    |
|                   |     |                |      |   Transport   |    |   layer api    |
|   client app      |     |                |      |   abstraction |    |                |
|                   |     |                |      |   layer       |    |( NCSI or MCTP) |
+--------+----------+     +-------+--------+      +-------+-------+    +--------+-------+
         |                        |                       |                     |
         |                        |   discoverTids()      |                     |
         |                        +----------------------->                     |
         |                        |                       |                     |
         |                        |                       +-------+             |
         |                        |                       |       |             |
         |                        |                       | queryEndpoints()    |
         |                        |                       |       |             |
         |                        |                       <-------+             |
         |                        |                       |                     |
         |                        |                       +-------+             |
         |                        |                       |       |             |
         |                        |                       | MapTIDEndpoints()   |
         |                        |                       |       |             |
         |                        |                       |       |             |
         |                        |                       |<------+             |
         |                        |                       |                     |
         |                        |    returnTIDMap       |                     |
         |                        |<----------------------+                     |
         |   getPLDMInstanceId()  |                       |                     |
         +----------------------->|                       |                     |
         |     return instanceId  |                       |                     |
         |<-----------------------+                       |                     |
         |                        |                       |                     |
         |registerRequest(tid,    |                       |                     |
         | instanceId,            |                       |                     |
         |request,respHandler)    |                       |                     |
         +------------------------>                       |                     |
         |                        |                       |                     |
         |                        |send_pldm(tid,req)     |                     |
         |                        +----------------------->                     |
         |                        |                       |                     |
         |                        |                       +---------+           |
         |                        |                       |         |           |
         |                        |                       | getMappedSocket()   |
         |                        |                       |         |           |
         |                        |                       <---------+           |
         |                        |                       |                     |
         |                        |                       | send_pldm(socketFd, |
         |                        |                       |  req)               |
         |                        |                       |                     |
         |                        |                       +--------------------->
         |                        |                       |                     |
         |                        |                       |                     |
         |   responseHandler()    |                       |                     |
         |    (async callback)    |                       |                     |
         <------------------------+                       |                     |
         |                        |                       |                     v
         |                        |                       v
         v                        v
```

### steps
- when the PLDM service is started , the PLDM wrapper's discoverTIDs() api
is called so that the transport layer specific endpoints(EID or RBT UID) are
 discovered and mapped to the TID or virtual TID.

 - The TID to EID map should be further mapped to the sockets associated
  with them.

- The PLDM client packs the PLDM message using libpldm's encode apis.

- The PLDM client apps which calls the PLDMrequester with terminus id
 and PLDM request as parameter using **registerRequest** api

- The PLDM requester calls the PLDM wrapper api with
 terminus id and PLDM request message as parameters.

- The PLDM wrapper internally checks the TID and endpoint id
map and calls the respective transport layer PLDM request api along
with the EID associated Socket.

 - When the PLDM message is received the callback function
 provided in the **registerRequest** api is called and the
 PLDM client app process the received PLDM message.

## Impacts
The current apps using  mctp based socket and EID will need to use the
terminus ID and PLDM request message as parameter.
## Testing
MCTP transport - existing features can be validated using supported platforms
NCSI RBT - Testing can be done on the supported yosemitev2 platform.

