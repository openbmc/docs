# Architecture for Inventory and Hardware Management in EntityManager -based system.

Note: this document intended to describe system architecture as we would like it to be, but not actual implementation state. Main goal is to define system architecture and EM role in there that would be clear and common for everyone interested in using EM. When we accept this implementation proposal, we should keep in mind this design when refactoring code and/or developing new features.
This document also can be interpreted as attempt to create roadmap or at least ToDo list for EM-related stuff development.

## 1. Requirements Specification

### 1.1. Inventory representation requirements
The main way to access Inventory information for end user is BMC web interface. There is a hardware section in WebUI with subsections per device type. Inventory should contain information about all removable parts of the system. Most common components that should be represented are:
* Chassis
* Baseboard
* Backplanes/expanders
* CPUs
* DIMMs
* Storage devices
* Add-in cards (PCIe removable devices, like Storage controllers, Ethernet cards, GPUs)
* PSUs
* Fans

Depending on platform structure other hardware component types could be added, so design should support extending without significant change of existing code.
Amount of information shown for each component could be different, but should contain static information (like model,  serial number, etc) and dynamic state. It should be able to associate each particular device with sensors located there.
Hierarchical associations for inventory items should be supported, e. g. Storage Devices should be associated with Backplanes where they are located and Storage Controllers which they are connected to.
Additionally it would be useful to show empty slots for devices types where it possibly (empty CPU sockets, PCIe slots, Storage Device ports, Fan connectors).

Inventory should dynamically monitor hardware status and update information on any components change except the cases when component information can’t be retrieved due to host power of (or some other reasons). This case component should be marked as Offline. In system powered up but component not present it should be removed from inventory and corresponding SEL record should be added.

### 1.2 Redfish
It should be possible to get all the inventory information with Redfish protocol. Since the actual design is that all the communication between BMCWeb and WebUI should go through Redfish this should go automatically.

### 1.3 IPMI
IPMI has no dedicated inventory commands set, there are only FRU list/get/set commands. EM-based system doesn’t generate any "virtual" FRU but only exposes FRUs found in plugged devices or other places.
[Question:]
On Phosphor Inventory Manager (PIM) based systems ipmi fru list had autogenerated list of FRUs for all entities in inventory config. Is it acceptable for other companies to change the behavior in case of migration PIM->EM?
[/Question]

### 1.4. Sensors
Sensors configuration should be automatically synchronized with inventory state.
All sensors should be associated with corresponding devices in inventory.

### 1.5. Other requirements
* System should be designed in the way that it require minimal code changes when adding new platform and device types. All type should have common generic interfaces and share handling code.
* All dbus structure should be well-described and fully compatible with phosphor-dbus-interfaces
* There should be easy way to export full inventory to some other representation form without code duplication.

## 2. Implementation proposal

### 2.1. System structure
Central element of the system is EntityManager, which probes hardware and publish to dbus inventory information.
[Discussion:]
Should we claim EM to be central element? There should be one joint point for all the inventory information in one place and all the other inventory consumers requests there. Currently in our design such point is bmcweb: beside EM it reads DIMM information from SMBIOS-SDR and PCI devices information from PECI-PCIe daemon as this two daemons can provide inventory information by them self. Thus inventory information from EM, SMBIOS, and PECI flows trough bmcweb where is is processed and converted to Redfish. Although from architecture point of view it would be more logical if all the bmcweb would receive inventory information only from EM.
Same assumption might be done after reading EM documentation where smbios-mdr and peci-pcie are stated as detection daemons for EM.
[/Discussion]
EM doesn't detect any hardware by itself: EM has only hardware descriptions, but can't communicate with this hw. EM doesn't have full hardware attributes in advance: some information such as model, serial number, supported subnodes number obtained in runtime only.
The information, required by EM is provided by detection daemons, which knows how to detect hardware presence, like FruDevice, smbios-mdr and peci-pcie. This daemons somehow obtain information about device and expose it to dbus in a way EM could interpret it.
Detection daemons can also provide device communication if required.
There is no strictly defined interface to provide detection information to EM: one have to specify details in "probe" directive of EM config depending on what is detection daemon is expected.
[Note:] If we want EM configs be dbus-agnostic this probe design should be changed to use some well-known interfaces and then use keyword-based lookup in probe directives. However I don't think it's really a case here.
Bmcweb in its turn translates inventory data to Redfish according DMTF schemes. After bmcweb get Redfish request from webui (or other consumer) it uses ObjectMapper to find services provides required data by interface name and object path.
In order to simplify and unify inventory processing all inventory entities should have following dbus interfaces:
* xyz.openbmc_project.Inventory.Item -  according to phosphor-dbus-interfaces mandatory interface for all inventory item ([NOTE:] currently not used at all in EM-based design!!)
* xyz.openbmc_project.Inventory.Item.<TYPE> - additional properties depending in device type
* xyz.openbmc_project.Inventory.Decorator.Asset - device details

### 2.2 EntityManager
According to EM documentation, system should contain EM itself, set of configuration files, detection daemons and reactors.
[inputs by Ed:]
General inputs for EM design:
* probe-based runtime configuration, doesn't require any per-system configuration, just handle common configurations for all known hardware
* hardware configuration files should be implementation-agnostic, ideally it should know nothing about dbus and OpenBMC internals
* configuration files should be a hardware description which can be written by engineers, not OpenBMC developer
* configuration files should require minimum changes even if any wide sweeping architecture changes happen

[/inputs]
[Discussion:]
Here we have trade of Easy to write Vs Easy to read. Once we say EM configuration should only define hardware configuration rather then system configuration, it became hard to understand how system use this configuration. It may end up situation when no one really knows which parts of configuration file used for what and if it is used at all. Is it acceptable risk and is there a plan on how to mitigate it?
Other trade of is system internals knowledge: currently EM has really narrow dbus knowledge, it just expose everything it found in config as dbus object and then engineer should know how to setup hw daemons. Don't think we can really do something good here, but this doesn't sound like "configuration files are implementation-agnostic" as was planned. E.g PID control: it is actually not a hardware description but it is part of system configuration.
[/Discussion]

Currently in upstreamed system there are following services are used to communicate with EM:

Detection daemons:
* FruDevice
smbios-mdr and peci-pcie are claimed to be detection daemons but actually there is no any configs or examples that use them.

Reactors:
* dbus-sensors
* phosphor-pid-control
* some services from Intel-BMC/provingground

Other data consumers:
* bmcweb
* intel-ipmi-oem

#### 2.2.1 Operation principles
In actual implementation EM works as follows:
* reads all configuration files and stores all "probe" interfaces to the cache.
* for each of the cached probe interfaces requests objects provided this interface using ObjectMapper
* for each found object tests probe condition
* if match found, creates dbus object in "/xyz/openbmc_project/inventory/system" hierarchy (first-class entry).
* if required by configuration, creates also dbus objects for second-class entry
* if required by configuration, do addition actions (bind devices, change other loaded configuration)

EM automatically triggered on dbus updates. EM also provides control interface xyz.openbmc_project.EntityManager with ".ReScan" method which can be used to manually trigger rescan for entities. This provides hot-plug functionality.
For initial speedup, EM cache detected configurations in /var/configuration/.
[Question:]
How does EM works on hot unplug event (in case it can't find entry that was there before)?
[/Question]
While first-class entries represent inventory node itself, second-class entries are used by reactors to interact with hardware. They generally just exposed to dbus to allow consumers to get periphery configuration. Only the first-class entries should be claimed as inventory objects.

#### 2.2.2 Configuration file format
Each EM configuration file contains JSON object (or array of JSON objects) which represents a inventory entry. Root element of entity description (first-class entity) contains basic entity information:
* Type - device type used to construct dbus object names and subnodes interfaces
* name - Entity Name also used to generate dbus object names
* probe - expression to determine if EM should instantiate object of this type

Additional entity details are defined as nested JSON objects. Special property "Exposes" is used to define second-class objects.

When instantiate entity EM will create objects as follows:
* top level object will be named as
/xyz/openbmc_project/inventory/system/<Type>/<Name>
where <Type> and <Name> are reformatted values from corresponding fields of config
* every string/number/bool fields of config became property of interface
xyz.openbmc_project.Inventory.Item.<Type>
* every array/object (except special member "Exposes") creates new interface with name equal the name of this array/object with index in case of array (are arrays allowed for first-class entries?) and properties reflects array/object fields
* for each member of "Exposes" array new second-level entry created as object with path
/xyz/openbmc_project/inventory/system/board/<Type>/<Name>/<ExposesName>
where <ExposesName> is value of Name property of the corresponding array item
* every string/number/bool fields of the item became property of interface
xyz.openbmc_project.Configuration.<Type>
where <Type> is value of Type field of the item
* every array/object of the item creates new interface with name
xyz.openbmc_project.Configuration.<Type>.<Name> (with index in case of array) and with properties reflects array/object fields

Parameter values can have variable and expressions, which will be evaluated on instantiation time. In case device is probed using dbus interface, all properties of this interface could be used as variables in configuration file.
[Discussion:]
* note: one more dbus knowledge related feature - we have to know interface properties names
* Can we get more information about device? E.g. from other interfaces, object name, other resources.

[/Discussion]

System can instantiate any number of entities of the same type. However note that <Type>/<Name> pair should be unique and EM doesn't handle this by itself.
Generally, EM should not react on detected hardware, but for bunch of I2C devices and for GPIO there is a hook, which automatically tries to initialize kernel driver for found device.
[Question:]
This looks like "out of scope side effect" for EM. Should we extract this function to separate daemon?
[/Question]

[Discussion:]
* if we want EM config files to be implementation-agnostic, Probe mechanism should be redesigned, since now it requires knowledge about dbus interfaces. Otherwise we should accept that some system knowledge is required and then we just should have detailed description of that interfaces.
* currently one should explicitly define all the dbus interfaces he want to expose, if we want EM be more platform-agnostic, it should add required interfaces by itself depending on entry "Type".
* We should have autoindexing for dbus object names like in FruDevice and for disply name use "PrettyName" property of xyz.openbmc_project.Inventory.Item interface (which we doesn't have now)
* Includes: a way to move definitions of things that are common for entire devices family to one file like in DTS (well, some other features of device trees can be useful too)
* CPU sockets, PCIe slots, Storage Device ports, Fan connectors: would be nice if we have separate array for them similar to "Exposes", but dedicated for ports where some FRUs can be attached.

[/Discussion]

#### 2.2.3 Other question
Since we define inventory as set of removable devices in platform, almost each inventory item has it's own place to install (socket, slot, connector, port, etc). In EM configuration we should define all such places and be able to links instantiated inventory item to port where it is inserted and then be able to show this information in web interface.

### 2.3. dbus-sensors
Note: While this package names "dbus-sensors" it is actually bunch of hardware management daemons, which handles mostly but not only sensors and shares some common functions. Since functions of the daemons are different behavior also different, but generally they looks up for instantiated second-level entries using ObjectMapper and exposed interface in "xyz.openbmc_project.Configuration" space.
Once match found, service tries to actually communicate with hardware and expose to dbus data/control interfaces.
[Discussion:]
* This exposed interfaces currently are not associated with any EM entries, so it's hard to link senors with inventory. Sensor daemons should always associate created interfaces with corresponding inventory item.
* Don't really like concept "all the stuff in one repo". If this is really not just sensors anymore, is it time to split repo to several and move common code into library?

[/Discussion]

### 2.4. Redfish
There is list of Redfish schemes, used to implement most common inventory elements:

Procesor:
https://redfish.dmtf.org/schemas/v1/Processor.v1_10_0.json

Memory:
https://redfish.dmtf.org/schemas/v1/Memory.v1_10_0.json

PCIe:
https://redfish.dmtf.org/schemas/v1/PCIeDevice.v1_5_0.json
https://redfish.dmtf.org/schemas/v1/PCIeFunction.v1_2_3.json
PCIeSlots schema should be implemented to provide information about a physical PCI slots.
https://redfish.dmtf.org/schemas/v1/PCIeSlots.v1_4_0.json

Power:
https://redfish.dmtf.org/schemas/v1/Power.v1_6_1.json
Also probably worth to implement Equipment, PowerDomain, PowerDistribution to get
a full picture of power distribution subsystem
https://redfish.dmtf.org/schemas/v1/PowerDistribution.v1_0_1.json
https://redfish.dmtf.org/schemas/v1/PowerDomain.v1_0_1.json
https://redfish.dmtf.org/schemas/v1/PowerEquipment.v1_0_0.json

Storage:
https://redfish.dmtf.org/schemas/v1/Storage.v1_9_0.json
https://redfish.dmtf.org/schemas/v1/StorageController.v1_0_0.json
https://redfish.dmtf.org/schemas/v1/Drive.v1_11_0.json

Fans:
https://redfish.dmtf.org/schemas/v1/Thermal.v1_6_2.json

BMC:
https://redfish.dmtf.org/schemas/v1/Manager.v1_10_0.json

System:
https://redfish.dmtf.org/schemas/v1/ComputerSystem.v1_13_0.json

## 3. Particular cases

### 3.1 CPUs
Currently in EM CPUs are only second-class entities for baseboard configurations.
```
            {
                "Address": "0x30",
                "Bus": 0,
                "CpuID": 0,
                "Name": "CPU 0",
                "PresenceGpio": [
                    {
                        "Name": "CPU1_PRESENCE",
                        "Polarity": "Low"
                    }
                ],
                "Type": "XeonCPU"
            }
```
But actually that should be called "CPU socket" instead, as exactly this role they plays here. For first-class entry we actually should go to SMBIOS-MDR.
PresenceGpio here is "socket occupied sensor", which is used by some of daemons from dbus-sensors however it doesn't anyhow interact with actual first-class CPU entity, which can be source of inconsistency.

### 3.2 DIMMs
Same as for CPU, DIMM inventory information goes from SMBIOS-SDR, but here EM doesn't have any DIMM-related configuration at all, even there is no any DIMM slot information. We should add such entries for baseboard configuration.

### 3.3 PCIe devices
Same as above, EM doesn't care about PCIe devices at all. All PCIe-related information goes from PECI-PCIe daemon.
Note: currently peci-pcie daemon exposes all the PCIe devices except internal CPU devices, there are number of PCI devices built-in on baseboard. Should we hide somewhere them also and show in inventory only Add-In Cards? Good way to filter out internal devices is based on PCI address, but then we need to know where PCIe slots connected (one more reason to define slots).

### 3.4 Fans
Currently we have Fans as second-class entities and also Fan Connectors as other second-class entities (or even third class). This looks really weird for inventory, it requires kind of tricks to enumerate Fans in such way. Fans should be moved to first-class entity but we should keep in mind embedded Fans (e.g. in PSU) which are not Inventory Items.
Beside the hierarchy we have configuration problem.
Typical example for Fan description:
```
{
                    "Name": "System Fan connector 3",
                    "PwmName": "SYS_FAN3_PWM",
                    "Pwm": 2,
                    "Tachs": [
                        2,
                        9
                    ],
                    "Type": "SysFanConnector"
                },
                {
                    "BindConnector": "System Fan connector 3",
                    "Index": 2,
                    "Name": "SYS_FAN3",
                    "Thresholds": [
    [...]
                    ],
                    "Type": "AspeedFan"
                }
```

Here in connector configuration we do have "Tachs" property with tachometer lines defined, but in linked Fan node we have to specify "Index" with the same value. Looks like for index here we should use index of corresponding line in "Tachs" array ("0" in this example).
