# Architecture for Inventory and Hardware Management in EntityManager -based system.

__NOT FOR MERGE, WORK IN PROGRESS__

Note: this document intended to describe system architecture as we would like it to be, but not actual implementation state. Main goal is to define system architecture and EM role in there that would be clear and common for everyone interested in using EM. When we accept this implementation proposal, we should keep in mind this design when refactoring code and/or developing new features.
This document also can be interpreted as attempt to create roadmap or at least ToDo list for EM-related stuff development.

## 1. Requirements Specification

### 1.1. Inventory representation requirements
The main way to access Inventory information for end user is BMC web interface. There is a hardware section in WebUI with subsections per device type. Inventory should contain information about all removable parts of the system. Most common components that should be represented are:
* Chassis
* Baseboard
* Backplanes/expanders
* CPUs
* DIMMs
* Storage devices
* Add-in cards (PCIe removable devices, like Storage controllers, Ethernet cards, GPUs)
* PSUs
* Fans

Depending on platform structure other hardware component types could be added, so design should support extending without significant change of existing code.
Amount of information shown for each component could be different, but should contain static information (like model,  serial number, etc) and dynamic state. It should be able to associate each particular device with sensors located there.
Hierarchical associations for inventory items should be supported, e. g. Storage Devices should be associated with Backplanes where they are located and Storage Controllers which they are connected to.
Additionally it would be useful to show empty slots for devices types where it possibly (empty CPU sockets, PCIe slots, Storage Device ports, Fan connectors).

Inventory should dynamically monitor hardware status and update information on components change. System will make every attempt to keep the inventory interfaces correct, although detection may be deferred in some cases. This case component should be marked as Offline. If system powered up but component not present it should be removed from inventory and corresponding SEL record should be added.

### 1.2 Redfish
Redfish has a schema that tends to be a large user of Inventory interfaces. All the inventory information must be in Redfish. This tends to be higtly inportant since upcoming webui-vue design aimed to use only Redfish to communicate to bmcweb.
Since that all inventory design decisions should be made keeping Redfish schemas in mind.

### 1.3 IPMI
IPMI has no dedicated inventory commands set, there are only FRU list/get/set commands. EM-based system doesnâ€™t generate any "virtual" FRU but only exposes FRUs found in plugged devices or other places.
[Question:]
On Phosphor Inventory Manager (PIM) based systems ipmi fru list had autogenerated list of FRUs for all entities in inventory config. Is it acceptable for other companies to change the behavior in case of migration PIM->EM?
[/Question]

### 1.4. Sensors
Sensors configuration should be automatically synchronized with inventory state.
All sensors should be associated with corresponding devices in inventory.

### 1.5. Other requirements
* System should be designed in the way that it require minimal code changes when adding new platform and device types. All types should have common generic interfaces and share handling code as much as possible.
* All dbus structure should be well-described and fully compatible with phosphor-dbus-interfaces
* There should be easy way to export full inventory to some other representation form without code duplication.

## 2. Implementation

### 2.1. System structure
There is no central point that collect all the inventory information except bmcweb which is responsible for data representation in Redfish. Inventory subsystem contains one or more services provides inventory. Common structure is as follows:
* Detection daemons are looking for hardware presence
* Hardware communication daemons, so called "reactors", communicates with hardware to get details, status, sensors values and/or control it
* Entity Manager provides configuration for communication daemons
* bmcweb does conversion of inventory information published on dbus to Redfish
* webui represents Inventory information from Redfish to human-readable presentation

According this logic, only reactors should be source of inventory information while EM just a software configuration interface. However for simplification purposes this logical roles are mixed:
* function of detection daemons and reactors may be handled
 by same daemon (e.g. smbios-mdr and peci-pcie)
* Entity Manager can provide inventory information for cases were is no need for direct device communication and there are enough information provided by corresponded detection daemon

[Discussion:]
Okey, now this mess is documented. But it is still a mess... I mean I don't see strict structure here: I don't want to dig every component sources in my system to understand what is should do and what shouldn't.
If we don't want distribute functions between component types, we should be at least more explicit in interfaces we use.
Benefit of using phosphor-dbus-interfaces is that explicitly define what kind of functionality application implements. But, as we said using it is separate discussion. Here I would like we at least define set of mandatory interfaces for each logical function or other way of service self-description.
[/Discussion]

The information about hardware blocks present in system is provided by detection daemons, which knows how to detect hardware presence, like FruDevice, smbios-mdr and peci-pcie. This daemons somehow obtain basic information about device and expose it to dbus.
Hardware communication daemon responsible for this kind of devices starts device monitoring or other interaction. In case it require some additional configuration/external information, Entity Manager should provide it.
As general rule Entity Manager looks for present devices in detection daemons and reactors loos for them in EM, but when there is no need in configuration, Entity Manager could be not involved.
Since EM is very generic, there is no strictly defined interface to provide detection information to there: one have to specify details in "probe" directive of EM config depending on what is detection daemon expected.

Bmcweb in its turn translates inventory data to Redfish according DMTF schemes. After bmcweb get Redfish request from webui (or other consumer) it uses ObjectMapper to find services provides required data by interface name and object path.
In order to simplify and unify inventory processing all inventory entities should have following dbus interfaces:
* xyz.openbmc_project.Inventory.Item -  according to phosphor-dbus-interfaces mandatory interface for all inventory item ([NOTE:] currently not used at all in EM-based design!!)
* xyz.openbmc_project.Inventory.Item.<TYPE> - additional properties depending on device type
* xyz.openbmc_project.Inventory.Decorator.Asset - device details

### 2.2 EntityManager
According to EM documentation, system should contain EM itself, set of configuration files, detection daemons and reactors.

General inputs for EM design:
* hardware configuration files should be implementation-agnostic, ideally it should know nothing about dbus and OpenBMC internals
* probe-based runtime configuration, doesn't require any per-system configuration, just handle common configurations for all known hardware
* configuration files should be a hardware or software resources description which can be written by engineers, not OpenBMC developer
* configuration files should require minimum changes even if any wide sweeping architecture changes happen
* configuration files should contain the minimum amount of information required to describe how they differ from other entities.  Intelligent defaults should always be preferred.
* configuration filess describe the differences between platforms/hardware/software.  It doesn't "just" define hardware configuration.

Currently in upstreamed system there are following services are used to communicate with EM:

Detection daemons:
* FruDevice
smbios-mdr and peci-pcie are claimed to be detection daemons but actually there is no any configs or examples that use them.

Reactors:
* dbus-sensors
* phosphor-pid-control
* some services from Intel-BMC/provingground

Other data consumers:
* bmcweb
* intel-ipmi-oem

#### 2.2.1 Operation principles
In actual implementation EM works as follows:
* reads all configuration files and stores all "probe" interfaces to the cache.
* for each of the cached probe interfaces requests objects provided this interface using ObjectMapper
* for each found object tests probe condition
* if match found, creates dbus object in "/xyz/openbmc_project/inventory/system" hierarchy (first-class entry).
* if required by configuration, creates also dbus objects for second-class entry
* if required by configuration, do addition actions (bind devices, change other loaded configuration)

EM automatically triggered on dbus updates. EM also provides control interface xyz.openbmc_project.EntityManager with ".ReScan" method which can be used to manually trigger rescan for entities. This provides hot-plug functionality.
For initial speedup, EM cache detected configurations in /var/configuration/.
[Question:]
How does EM works on hot unplug event (in case it can't find entry that was there before)?
[/Question]
While first-class entries represent inventory node itself, second-class entries are used by reactors to interact with hardware. They generally just exposed to dbus to allow consumers to get periphery configuration. Only the first-class entries should be claimed as inventory objects.

#### 2.2.2 Configuration file format
Each EM configuration file contains JSON object (or array of JSON objects) which represents a inventory entry. Root element of entity description (first-class entity) contains basic entity information:
* Type - device type used to construct dbus object names and subnodes interfaces
* name - Entity Name also used to generate dbus object names
* probe - expression to determine if EM should instantiate object of this type

Additional entity details are defined as nested JSON objects. Special property "Exposes" is used to define second-class objects.

When instantiate entity EM will create objects as follows:
* top level object will be named as
/xyz/openbmc_project/inventory/system/<Type>/<Name>
where <Type> and <Name> are reformatted values from corresponding fields of config
* every string/number/bool fields of config became property of interface
xyz.openbmc_project.Inventory.Item.<Type>
* every array/object (except special member "Exposes") creates new interface with name equal the name of this array/object with index in case of array (are arrays allowed for first-class entries?) and properties reflects array/object fields
* for each member of "Exposes" array new second-level entry created as object with path
/xyz/openbmc_project/inventory/system/<Type>/<Name>/<ExposesName>
where <ExposesName> is value of Name property of the corresponding array item
* every string/number/bool fields of the item became property of interface
xyz.openbmc_project.Configuration.<Type>
where <Type> is value of Type field of the item
* every array/object of the item creates new interface with name
xyz.openbmc_project.Configuration.<Type>.<Name> (with index in case of array) and with properties reflects array/object fields

Parameter values can have variable and expressions, which will be evaluated on instantiation time. In case device is probed using dbus interface, all properties of this interface could be used as variables in configuration file.
[Discussion:]
* note: one more dbus knowledge related feature - we have to know interface properties names
* Can we get more information about device? E.g. from other interfaces, object name, other resources.

[/Discussion]

System can instantiate any number of entities of the same type. However note that <Type>/<Name> pair should be unique and EM doesn't handle this by itself.
Generally, EM should not react on detected hardware, but for bunch of I2C devices and for GPIO there is a hook, which automatically tries to initialize kernel driver for found device.
[Question:]
This looks like "out of scope side effect" for EM. Should we extract this function to separate daemon?
[/Question]

[Discussion:]
* if we want EM config files to be implementation-agnostic, Probe mechanism should be redesigned, since now it requires knowledge about dbus interfaces. Otherwise we should accept that some system knowledge is required and then we just should have detailed description of that interfaces.
* currently one should explicitly define all the dbus interfaces he want to expose, if we want EM be more platform-agnostic, it should add required interfaces by itself depending on entry "Type".
* We should have autoindexing for dbus object names like in FruDevice and for disply name use "PrettyName" property of xyz.openbmc_project.Inventory.Item interface (which we doesn't have now)
* Includes: a way to move definitions of things that are common for entire devices family to one file like in DTS (well, some other features of device trees can be useful too)
* CPU sockets, PCIe slots, Storage Device ports, Fan connectors: would be nice if we have separate array for them similar to "Exposes", but dedicated for ports where some FRUs can be attached.

[/Discussion]

#### 2.2.3 Other questions
Since we define inventory as set of removable devices in platform, almost each inventory item has it's own place to install (socket, slot, connector, port, etc). In EM configuration we should define all such places and be able to links instantiated inventory item to port where it is inserted and then be able to show this information in web interface.

ToDo: in future design EM should not store inventory information about device, but should have associations to detection daemon origin resource.
ToDo: Since EM configs should be dbus-agnostic probe design should be changed to use some well-known interfaces and then use keyword-based lookup in probe directives. We should describe design for this future solution

### 2.3. dbus-sensors
Note: While this package names "dbus-sensors" it is actually bunch of hardware management daemons, which handles mostly but not only sensors and shares some common functions. Since functions of the daemons are different behavior also different, but generally they looks up for instantiated second-level entries using ObjectMapper and exposed interface in "xyz.openbmc_project.Configuration" space.
Once match found, service tries to actually communicate with hardware and expose to dbus data/control interfaces.
[Discussion:]
* This exposed interfaces currently are not associated with any EM entries, so it's hard to link senors with inventory. Sensor daemons should always associate created interfaces with corresponding inventory item.
* Don't really like concept "all the stuff in one repo". If this is really not just sensors anymore, is it time to split repo to several and move common code into library?

[/Discussion]

### 2.4. Redfish
There is list of Redfish schemes, used to implement most common inventory elements:

Procesor:
https://redfish.dmtf.org/schemas/v1/Processor.v1_10_0.json

Memory:
https://redfish.dmtf.org/schemas/v1/Memory.v1_10_0.json

PCIe:
https://redfish.dmtf.org/schemas/v1/PCIeDevice.v1_5_0.json
https://redfish.dmtf.org/schemas/v1/PCIeFunction.v1_2_3.json
PCIeSlots schema should be implemented to provide information about a physical PCI slots.
https://redfish.dmtf.org/schemas/v1/PCIeSlots.v1_4_0.json

Power:
https://redfish.dmtf.org/schemas/v1/Power.v1_6_1.json
Also probably worth to implement Equipment, PowerDomain, PowerDistribution to get
a full picture of power distribution subsystem
https://redfish.dmtf.org/schemas/v1/PowerDistribution.v1_0_1.json
https://redfish.dmtf.org/schemas/v1/PowerDomain.v1_0_1.json
https://redfish.dmtf.org/schemas/v1/PowerEquipment.v1_0_0.json

Storage:
https://redfish.dmtf.org/schemas/v1/Storage.v1_9_0.json
https://redfish.dmtf.org/schemas/v1/StorageController.v1_0_0.json
https://redfish.dmtf.org/schemas/v1/Drive.v1_11_0.json

Fans:
https://redfish.dmtf.org/schemas/v1/Thermal.v1_6_2.json

BMC:
https://redfish.dmtf.org/schemas/v1/Manager.v1_10_0.json

System:
https://redfish.dmtf.org/schemas/v1/ComputerSystem.v1_13_0.json

## 3. Particular cases

### 3.1 CPUs
Currently in EM CPUs are only second-class entities for baseboard configurations.
```
            {
                "Address": "0x30",
                "Bus": 0,
                "CpuID": 0,
                "Name": "CPU 0",
                "PresenceGpio": [
                    {
                        "Name": "CPU1_PRESENCE",
                        "Polarity": "Low"
                    }
                ],
                "Type": "XeonCPU"
            }
```
But actually that should be called "CPU socket" instead, as exactly this role they plays here. For first-class entry we actually should go to SMBIOS-MDR.
PresenceGpio here is "socket occupied sensor", which is used by some of daemons from dbus-sensors however it doesn't anyhow interact with actual first-class CPU entity, which can be source of inconsistency.
CPU naming also is inconsistency point: peci driver count CPUs from 1 (besides the internal numbering and peci specification uses 0-based numbering), while EM configuration should use "silkscreen name".

### 3.2 DIMMs
Same as for CPU, DIMM inventory information goes from SMBIOS-SDR, but here EM doesn't have any DIMM-related configuration at all, even there is no any DIMM slot information. We should add such entries for baseboard configuration.

### 3.3 PCIe devices
Same as above, EM doesn't care about PCIe devices at all. All PCIe-related information goes from PECI-PCIe daemon.
Note: currently peci-pcie daemon exposes all the PCIe devices except internal CPU devices, there are number of PCI devices built-in on baseboard. Should we hide somewhere them also and show in inventory only Add-In Cards? Good way to filter out internal devices is based on PCI address, but then we need to know where PCIe slots connected (one more reason to define slots).

### 3.4 Fans
Currently we have Fans as second-class entities and also Fan Connectors as other second-class entities (or even third class). This looks really weird for inventory, it requires kind of tricks to enumerate Fans in such way. Fans should be moved to first-class entity but we should keep in mind embedded Fans (e.g. in PSU) which are not Inventory Items.
Beside the hierarchy we have configuration problem.
Typical example for Fan description:
```
{
                    "Name": "System Fan connector 3",
                    "PwmName": "SYS_FAN3_PWM",
                    "Pwm": 2,
                    "Tachs": [
                        2,
                        9
                    ],
                    "Type": "SysFanConnector"
                },
                {
                    "BindConnector": "System Fan connector 3",
                    "Index": 2,
                    "Name": "SYS_FAN3",
                    "Thresholds": [
    [...]
                    ],
                    "Type": "AspeedFan"
                }
```

Here in connector configuration we do have "Tachs" property with tachometer lines defined, but in linked Fan node we have to specify "Index" with the same value. Looks like for index here we should use index of corresponding line in "Tachs" array ("0" in this example).
