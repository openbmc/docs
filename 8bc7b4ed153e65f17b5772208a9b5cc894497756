{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e743152e_450c1403",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-09-03T14:30:46Z",
      "side": 1,
      "message": "is this true ? on IBM systems(we dont use snoop interface), the progress codes can come even before BMC reaches ready state if the host is up and running. is that an ipmi problem ? trying to understand where the bottle neck is ?",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf73b71f_7959411a",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-09-03T14:50:56Z",
      "side": 1,
      "message": "Thanks a lot for time and review\nThe BMC needs to be fully operational and responsive when the host begins sending boot progress codes. However, in the proposed design, the host continuously writes error or progress codes to the scratchpad registers. This allows the BMC to retrieve and process those codes once it becomes available.",
      "parentUuid": "e743152e_450c1403",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f53077bb_97e4072e",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-09-10T14:36:56Z",
      "side": 1,
      "message": "Marking the conversation as resolved. Please let me know if there is any concern.",
      "parentUuid": "bf73b71f_7959411a",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24d86fa5_1f4e6dcc",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-09-17T11:31:28Z",
      "side": 1,
      "message": "\u003e The BMC needs to be fully operational and responsive when the host begins sending boot progress codes.\n\nwhy ? having an operational ipmi-snoop application isn\u0027t sufficient ? the kernel snoop interface will be anyways there before even the user-space starts, right ?",
      "parentUuid": "f53077bb_97e4072e",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62e3fb43_63e40eab",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-09-17T16:44:48Z",
      "side": 1,
      "message": "This design is intended to address limitations in existing boot progress reporting mechanisms that rely on real-time delivery — such as IPMI over SMBus or SSIF — where boot codes can be lost if the BMC is not yet fully initialized or responsive when the host begins transmitting them.\n\nIn contrast, the proposed approach uses host-maintained, hardware-backed circular queues to log boot progress and error codes asynchronously. This allows the BMC to retrieve the complete set of boot events after it becomes available, ensuring no data is lost due to boot timing mismatches.\n\nBy decoupling the host’s boot logging from the BMC’s runtime state, this design improves reliability, especially in scenarios where the host firmware begins execution before the BMC is fully online",
      "parentUuid": "24d86fa5_1f4e6dcc",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "996a175a_d322abab",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-09-18T06:52:28Z",
      "side": 1,
      "message": "I get what this design does. \n\nThe thing that this design does not seem to cover is - why is this a limiting factor for IPMI over SMbus or SSIF alone ? why not others?  and why is the post code problem tied to \"complete BMC readiness\" ? rather, the post codes should be tied to the daemon that reads the post codes off the snoop interface.",
      "parentUuid": "62e3fb43_63e40eab",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93d27a09_9fadefe1",
        "filename": "designs/queued-boot-progress.md",
        "patchSetId": 17
      },
      "lineNbr": 14,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-09-22T09:00:51Z",
      "side": 1,
      "message": "The concern is not with the IPMI protocol itself, but rather with the current OpenBMC implementation of SMBus/SSIF POST code delivery, which operates as a real-time push mechanism.\nThis approach relies on both the BMC kernel drivers and the associated userspace daemon being active to receive the messages.\nIf these components are not yet initialized when the host begins transmitting codes, some messages may unfortunately be lost.\nThe proposed hardware-queue design addresses this by allowing the host to write codes into a persistent buffer, which the BMC can safely poll once it becomes available—ensuring reliable capture independent of the BMC’s readiness state",
      "parentUuid": "996a175a_d322abab",
      "range": {
        "startLine": 13,
        "startChar": 27,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "8bc7b4ed153e65f17b5772208a9b5cc894497756",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}