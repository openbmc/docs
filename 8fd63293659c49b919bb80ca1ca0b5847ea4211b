{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d6c3cd7a_f0dd0cbf",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-07-12T17:01:59Z",
      "side": 1,
      "message": "Does it make sense to provide an example config here to help readers understand how this dynamic probe works?",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 12
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b19d70f8_3f02a119",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-12T18:03:00Z",
      "side": 1,
      "message": "I\u0027ll include an example in the next revision",
      "parentUuid": "d6c3cd7a_f0dd0cbf",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 12
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5712f718_71549bd6",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-13T05:09:07Z",
      "side": 1,
      "message": "+1.  An example would be good.  I\u0027m pretty sure I\u0027m ok with this, and it solves the problem, but one or two examples, (even an example in review) might be helpful to show a real system.",
      "parentUuid": "b19d70f8_3f02a119",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 12
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fb26b10_35652243",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-14T04:02:30Z",
      "side": 1,
      "message": "Added a simple example with 2 chassis",
      "parentUuid": "5712f718_71549bd6",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 12
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11936c83_0d58a4d0",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-07-12T17:01:59Z",
      "side": 1,
      "message": "Same here; it will be great if we can get an example query (e.g., how Fans are connected to a chassis).\n\nAlso, I have the same concerns as Patrick: the association will contain as list of object paths, right? How will we parse that path? If we only use filename, then we will have the problem of nested names, for example, say we have two chassis, one contained by the other\n\n```\n/a/b/c/chassis0\n/a/b/c/chassis0/chassis0\n```\n\nhow do know which chassis0 an inventory maps to? Maybe we assume all filenames are unique?",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 78
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6e7793d_9e7eb449",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-12T18:03:00Z",
      "side": 1,
      "message": "\u003e Same here; it will be great if we can get an example query (e.g., how Fans are connected to a chassis).\n\nSure, I can add an example response from the mapper\n\n\u003e \n\u003e Also, I have the same concerns as Patrick: the association will contain as list of object paths, right? How will we parse that path? If we only use filename, then we will have the problem of nested names, for example, say we have two chassis, one contained by the other\n\u003e \n\u003e ```\n\u003e /a/b/c/chassis0\n\u003e /a/b/c/chassis0/chassis0\n\u003e ```\n\u003e \n\u003e how do know which chassis0 an inventory maps to? Maybe we assume all filenames are unique?\n\nYes, all D-Bus paths should be unique",
      "parentUuid": "11936c83_0d58a4d0",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 78
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba2a888f_92deb125",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000682
      },
      "writtenOn": "2022-07-12T18:51:33Z",
      "side": 1,
      "message": "\u003e Yes, all D-Bus paths should be unique\n\nNo, I was asking the filename (the last piece of the path), not the entire DBus path.",
      "parentUuid": "f6e7793d_9e7eb449",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 78
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "975826f5_6ea19bb2",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-12T23:00:17Z",
      "side": 1,
      "message": "Associations are based on the entire D-Bus path, so this should be fine",
      "parentUuid": "ba2a888f_92deb125",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 78
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53df80c4_68a04e3f",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-14T04:02:30Z",
      "side": 1,
      "message": "Added mapper calls based on the example JSONs",
      "parentUuid": "975826f5_6ea19bb2",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 78
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7081c674_5fcd6e52",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-07-11T10:56:26Z",
      "side": 1,
      "message": "This feels a bit hand-wavy in the way it is worded.  Is it really \"significant...complexity\"?\n\nIs there any case where certain types of associations (such as contained-in) would always be hierarchy and other types of association (ex. powered-by) would not be?  This doesn\u0027t seem more complex on the part of the client and it more intuitive to humans.",
      "range": {
        "startLine": 88,
        "startChar": 38,
        "endLine": 89,
        "endChar": 23
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bbbf807f_ab92f944",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-12T18:03:00Z",
      "side": 1,
      "message": "It would at least double the complexity since the clients need to understand both ways of encoding topology.\n\nChassis contains relationships should always be hierarchical, so the paths could work for that, but I\u0027d prefer avoiding a special case for one type of relationship.\n\nAnother potential issue: could we ever have multiple inventory providers at once? In that case, coordinating paths across multiple daemons would be much more difficult than just using associations.",
      "parentUuid": "7081c674_5fcd6e52",
      "range": {
        "startLine": 88,
        "startChar": 38,
        "endLine": 89,
        "endChar": 23
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e03a54e_2bc104ad",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-13T05:09:07Z",
      "side": 1,
      "message": "\u003e This feels a bit hand-wavy in the way it is worded.  Is it really \"significant...complexity\"?\n\nHaving been party to several people attempting it.... Yes. It really does add significant complexity given there are now two paths to any architecture.\n\n\n\u003e Is there any case where certain types of associations (such as contained-in) would always be hierarchy and other types of association (ex. powered-by) would not be?\n\nI can\u0027t really think of any.\n\n\u003e Chassis contains relationships should always be hierarchical, so the paths could work for that, but I\u0027d prefer avoiding a special case for one type of relationship.\n\nThis is the key, you can pick ONE definition for paths, be it contained by, socketed into (which are different relationships than contained by) powered by, Drives for, ect.  EVERYTHING else needs to use associations, so doing something different for the one case just makes things more complex.",
      "parentUuid": "bbbf807f_ab92f944",
      "range": {
        "startLine": 88,
        "startChar": 38,
        "endLine": 89,
        "endChar": 23
      },
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a5cb95c_a49779ae",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-07-11T10:56:26Z",
      "side": 1,
      "message": "I don\u0027t see a great section to write this.\n\nIn effect, you\u0027ve taken just the \"connections\" part of the inventory design and used that as justification why using associations is better, but by leaving out the rest of the design you\u0027ve implicitly simplified away all the other issues.  A few issues that associations cause in my initial thinking:\n\n* Naming becomes a harder problem and should probably be specified.\n\nWhere you previous might be able to name an inventory object /chassis0/proc0 and /chassis1/proc0, you now need to either name them chassis0-proc0 and chassis1-proc0 or proc0 and proc8.  Both of these are a bit clumsy and the second is much less intuitive for humans.\n\n* How are \"building blocks\" defined?\n\nThis might be somewhat due to my own ignorance of the details of EM (and this is also somewhat related to \u0027naming\u0027).  It is much more obvious to me how you would go about specifying a building block of your system, such as a compute card, in a hierarchical design.  \"I detected compute card X in slot Y, so all of its stuff is named /slotY/stuff\".  How you go about specifying (and generating the name) of duplicative entities, and creating all the appropriate associations back to parents, isn\u0027t obvious to me.  Is there anything in the EM design already that handles this?\n\n* Implicit information vs explicit information.\n\nUsing hierarchy means you get a good view into the inventory relationships for free (implicit due to path assignments).  That means system designers don\u0027t need to do anything [special] to get a huge part of their Redfish data exposed.  Using associations means that all of it needs to be expressed explicitly and anything that is missed is missing.  This increases the work necessary.\n\nSome might argue that explicit expression is less bug-prone because it is all obvious and I can sympathize with that argument.  I think it is mostly only true when you are writing your system *after* all the association features have been done.  The minute we add a new association, all old systems are going to be missing it, and likely most of them will never get it added.  Implicit definitions, at least wherever possible, allow us to keep most systems on parity with each other much easier.",
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe39b847_d2e7e4a4",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-07-12T18:03:00Z",
      "side": 1,
      "message": "\u003e I don\u0027t see a great section to write this.\n\u003e \n\u003e In effect, you\u0027ve taken just the \"connections\" part of the inventory design and used that as justification why using associations is better, but by leaving out the rest of the design you\u0027ve implicitly simplified away all the other issues.  A few issues that associations cause in my initial thinking:\n\u003e \n\u003e * Naming becomes a harder problem and should probably be specified.\n\u003e \n\u003e Where you previous might be able to name an inventory object /chassis0/proc0 and /chassis1/proc0, you now need to either name them chassis0-proc0 and chassis1-proc0 or proc0 and proc8.  Both of these are a bit clumsy and the second is much less intuitive for humans.\n\nYou can technically still use whatever path names you want, you\u0027d just also need the associations for clients to understand this information.\n\nMaybe we could have the inventory providers automatically create these associations? This would only really apply to PIM though since EM doesn\u0027t let you use more complex paths for chassis items\n\n\u003e \n\u003e * How are \"building blocks\" defined?\n\u003e \n\u003e This might be somewhat due to my own ignorance of the details of EM (and this is also somewhat related to \u0027naming\u0027).  It is much more obvious to me how you would go about specifying a building block of your system, such as a compute card, in a hierarchical design.  \"I detected compute card X in slot Y, so all of its stuff is named /slotY/stuff\".  How you go about specifying (and generating the name) of duplicative entities, and creating all the appropriate associations back to parents, isn\u0027t obvious to me.  Is there anything in the EM design already that handles this?\n\nYes, EM already lets you customize names based on the \"index\" or bus number of an item that was detected:\n\nexample: https://github.com/openbmc/entity-manager/blob/master/configurations/nvme_p4000.json\n\ndocumentation: https://github.com/openbmc/entity-manager/blob/394ea2b48699cfed8807e61720b78b5a88027366/CONFIG_FORMAT.md#configuration-syntax\n\nDuplicate items will all have the same \"Connections\" field so they\u0027ll all get associated back to whatever they\u0027re connected to automatically. In the future, we could do this dynamically based on I2C topology (which would allow generic items to connect to other generic items), but that\u0027s not necessary for this initial design and would be an EM-specific feature.\n\n\u003e \n\u003e * Implicit information vs explicit information.\n\u003e \n\u003e Using hierarchy means you get a good view into the inventory relationships for free (implicit due to path assignments).  That means system designers don\u0027t need to do anything [special] to get a huge part of their Redfish data exposed.  Using associations means that all of it needs to be expressed explicitly and anything that is missed is missing.  This increases the work necessary.\n\u003e \n\u003e Some might argue that explicit expression is less bug-prone because it is all obvious and I can sympathize with that argument.  I think it is mostly only true when you are writing your system *after* all the association features have been done.  The minute we add a new association, all old systems are going to be missing it, and likely most of them will never get it added.  Implicit definitions, at least wherever possible, allow us to keep most systems on parity with each other much easier.\n\nOpenBMC has existed so far without this information being exposed on Redfish at all, so most users haven\u0027t needed this functionality. I\u0027d much rather keep this the same unless system designers explicitly enable it and make sure that it\u0027s exporting correct information.\n\nMissing information is better than incorrect information",
      "parentUuid": "0a5cb95c_a49779ae",
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc1b5286_35c885bc",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-13T05:09:07Z",
      "side": 1,
      "message": "\u003e Naming becomes a harder problem and should probably be specified.\n\nPretty sure the duplication issue has been a solved problem in EM for a while, and in phosphor-inventory, there\u0027s an implicit requirement that names don\u0027t collide.  I don\u0027t think this design makes it any harder.\n\n\n\u003e Both of these are a bit clumsy and the second is much less intuitive for humans.\n\n1. If we need to build tooling around this to help humans, we can.\n2. Nothing about this design precludes placing things in a hierarchical path if A, the software can support it, B. it\u0027s useful enough to humans that it makes sense, but in a design that supports add in cards, we weren\u0027t able to make it work in a reasonable way;  Happy to see review code that can do A+B though, but in the general rules of \"is it hard to unwind if we make the wrong decision\", we could certainly have a patchset that adds the associations support (some of which already exists) THEN we could set things up in patch hierarchies to make them useful to humans when we figured out the hard problems with them.\n\n\n\u003e \"I detected compute card X in slot Y, so all of its stuff is named /slotY/stuff\"\n\nPer the fact that we can only represent ONE atom of the graph, all of its stuff can\u0027t go in sloty/stuff.  only the stuff contained within it can go in it (assuming containment is the graph association you choose), otherwise we can\u0027t tell the difference between \"Contained by\" and \"Associated with port\", or \"cabled to\".\n\n\n\u003e  Is there anything in the EM design already that handles this?\n\nYup.  The naming problem has been solved, and yeah, it\u0027s clumsy, but it does function in a way that avoids collisions.\n\n\n\u003e OpenBMC has existed so far without this information being exposed on Redfish at all, so most users haven\u0027t needed this functionality.\n\nUsers have needed this functionality.  Most have ended up hardcoding it in their downstream forks for a given system.",
      "parentUuid": "fe39b847_d2e7e4a4",
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4544bb78_80d32293",
        "filename": "designs/physical-topology.md",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1000233
      },
      "writtenOn": "2022-08-12T00:01:17Z",
      "side": 1,
      "message": "\u003e \u003e Both of these are a bit clumsy and the second is much less intuitive for humans.\n\u003e \n\u003e 1. If we need to build tooling around this to help humans, we can.\n\nAdded a note about tooling to help with this\n\n\u003e 2. Nothing about this design precludes placing things in a hierarchical path if A, the software can support it, B. it\u0027s useful enough to humans that it makes sense, but in a design that supports add in cards, we weren\u0027t able to make it work in a reasonable way;  Happy to see review code that can do A+B though, but in the general rules of \"is it hard to unwind if we make the wrong decision\", we could certainly have a patchset that adds the associations support (some of which already exists) THEN we could set things up in patch hierarchies to make them useful to humans when we figured out the hard problems with them.\n\nThis should be handled by the inventory managers themselves. In the future, if phosphor-inventory-manager wants to generate chassisContains/chassisContainedBy associations based on path hierarchies, that feature could be added.\n\n\u003e \n\u003e \u003e OpenBMC has existed so far without this information being exposed on Redfish at all, so most users haven\u0027t needed this functionality.\n\u003e \n\u003e Users have needed this functionality.  Most have ended up hardcoding it in their downstream forks for a given system.\n\nUnderstood. I still believe that leaving this information missing if it hasn\u0027t been explicitly encoded is better than reporting possibly incorrect information based on how someone happened to organize their inventory configurations.",
      "parentUuid": "dc1b5286_35c885bc",
      "revId": "8fd63293659c49b919bb80ca1ca0b5847ea4211b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}