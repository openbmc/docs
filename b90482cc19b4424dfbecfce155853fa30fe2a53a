{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5910c4ed_7f98c8d3",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 29,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "It is?  I don\u0027t know of any instances of using phosphor-ipmi-flash for i2c firmware updates?  Maybe I\u0027m out of touch?  No, it\u0027s the codebase that\u0027s wrong.\n\nhttps://i.kym-cdn.com/entries/icons/original/000/019/899/skinner.jpg",
      "range": {
        "startLine": 28,
        "startChar": 61,
        "endLine": 29,
        "endChar": 28
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22c3279f_61d9ea71",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Yes, we should do this as a design pattern.",
      "range": {
        "startLine": 30,
        "startChar": 35,
        "endLine": 32,
        "endChar": 20
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5bfb5b9_4e5af1c0",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 34,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Nit, this doc would read a lot better without mentioning the daemon in the \"background\" section.  At this point, no new daemon has been introduced, you\u0027re just documenting background on why some change is needed.",
      "range": {
        "startLine": 34,
        "startChar": 37,
        "endLine": 34,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f7d0f5b_e7da3b13",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "This isn\u0027t a requirement.  The requirement is implementing both telemetry and firmware update/configuration changes that don\u0027t conflict.  Requirements should avoid jumping into solution space, which a single daemon is one possible solution.",
      "range": {
        "startLine": 43,
        "startChar": 14,
        "endLine": 43,
        "endChar": 27
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c09e4b87_1171d762",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Having a single daemon that supports ALL i2c devices seems like a kind of extremely large scope.  Should we decrease it a bit to scope it down a bit, to say, only pmbus devices?  Otherwise this design conflicts directly with things like the BIC controller daemon that\u0027s currently in review for a new repo.",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85d947f7_1b2fdd43",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-02-07T19:23:45Z",
      "side": 1,
      "message": "The single daemon for all i2c idea is largely coming from my WIP proposals for performance improvements. Justin wanted to get this proposal out to get started on the firmware management discussions. Agreed, this doc doesn\u0027t provide enough justification as is. I will work with Justin and Jason to combine our proposals into a unified design.\n\nA daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time). That said, it is crucially important that it works in an cooperative, opt-in way. This daemon must live with other services using i2c and still provide predictable (if degraded) guarantees about performance, functionality, and reliability.\n\nExpect a more comprehensive proposal from the three of us that will superseded this doc.",
      "parentUuid": "c09e4b87_1171d762",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f46a2211_b7f262d7",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-02-08T07:39:28Z",
      "side": 1,
      "message": "I\u0027m a bit confused by this.  Elsewhere Jason wrote:\n\n\u003e It\u0027s not really a daemon for everything i2c, but for devices that require more than just telemetry so that all access to that device is encapsulated in a single application. I reworded the description to reflect this.\n\nI want to be very forward that I see this proposal as being a big uphill battle to get me convinced that this is the right architectural direction.  I\u0027ll read what you have with an open mind but I don\u0027t want you to feel like you\u0027re wasting time later on.\n\n\u003e A daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time)\n\nThis sounds like you\u0027re proposing yet another i2c-in-userspace implementation.  This is absolutely a no-go in my mind, unless I see a lot of data explaining why it is better.  You\u0027re talking about not only reimplementing hwmon and pmbus and mux control but EEPROM, GPIO, LED control, MCTP, IPMB, etc. and then merging them all into one giant codebase.  There is already a lot of kernel drivers and existing openbmc userspace code to handle these things.  Some of these have implementations that are leveraged for non-i2c buses, so we end up having a divergence of functionality and approach depending on which bus gets chosen by a particular hardware design.\n\nI really cannot conceive that the 2-4 bytes of i2c traffic to switch the mux is our performance bottleneck.  If you really think that it is, and again I\u0027d like to see data that shows this, I think you have at least three better options:\n\n1. Improve your hardware design so you\u0027re not cramming so many devices on a single i2c bus, but spread it out among the 6 (or more?) masters on the BMC chip.\n\n2. Get these scheduling enhancements ideas into the kernel i2c subsystem directly.\n\n3. Improve dbus-sensors so it is mux-aware and to handle better timer scheduling of the devices it is monitoring so that mux switching is minimized.",
      "parentUuid": "85d947f7_1b2fdd43",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6eadc89a_2ba231d1",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Additional requirement, the code should fully deprecate the need for PSUsensor, given that it\u0027s duplicating a number of features and not sharing any code, it needs to use that featureset as a starting point to make it maintainable in the long term.\n\n\nI suspect we also need some requirements around being runtime invokable for when i2c devices exist on add in cards (solution probably being an EM reactor), otherwise this ends up being a point solution that only works on non DC-SCM baseboards.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2e4ac73_503b88ae",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eAdditional requirement, the code should fully deprecate the need for PSUsensor, \u003egiven that it\u0027s duplicating a number of features and not sharing any code, it \u003eneeds to use that featureset as a starting point to make it maintainable in the \u003elong term.\nI\u0027m okay with making this the long term replacement for PSUSensors. Of course the initial commits will focus heavily (exclusively) on implementing the features described in this design. Justin, thoughts?",
      "parentUuid": "6eadc89a_2ba231d1",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b80cfd0_56e6e96a",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Isn\u0027t this duplicated with the requirement?\n\nHow is this interface backed?  Does it implement pmbus?",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 9
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c3e4070_f1e87a7b",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eIsn\u0027t this duplicated with the requirement?\n\nI don\u0027t understand this question.\n\n\u003eHow is this interface backed? \n\nIf we\u0027re talking about the interfaces used to actuate a firmware update then it\u0027s backed with a bunch of userspace code that knows how to update particular devices.\n\n\u003eDoes it implement pmbus?\n\nYes, each pmbus device gets its own class that knows how to update the device. The classes know how to read standard telemetry if we decide to do userspace vs kernel.",
      "parentUuid": "8b80cfd0_56e6e96a",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 9
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38f84e65_3b2b62b4",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "This also feels like a requirement in the way it\u0027s phrased.  maybe move it up a section.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "236fcb04_e90adb92",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 78,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "It seems like this is kind of covered by the \"With a single daemon acting as an owner of a device\" statement previously.  If that\u0027s true, this isn\u0027t possible.",
      "range": {
        "startLine": 77,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6ecc541_1525acab",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "If it does this, it needs to not duplicate code.  We already have two implementations that are able to read from hwmon implementations (hwmontempsensor/psusenor, and phosphor-hwmon) as a matter of design, we need to avoid a having a third.",
      "range": {
        "startLine": 78,
        "startChar": 28,
        "endLine": 79,
        "endChar": 36
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e195ccb2_f3deb3c2",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-02-03T00:17:15Z",
      "side": 1,
      "message": "I don\u0027t feel like this is enough of a description of how this will be implemented in practice.\n\nEM board configs are written specific to the board they support with no regard for the system context in which they live. How do you handle wanting to update a device in system context A but not in system context B for the one card? Maybe you could argue that\u0027s not valid concern, but I think the point is it\u0027s a policy decision of the system designer/owner/maintainer.\n\nHow does this property get populated? Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards. It\u0027s almost as if you want a separate interface for these devices or something, so you don\u0027t trigger dbus-sensors to start with.\n\nBut on that front, with the work required deal with this in a separate daemon that ends up providing the Sensor interface itself, is there a reason why we can\u0027t add generic support inside dbus-sensors that could be leveraged by each of the daemon implementations? Doesn\u0027t that remove the conflict headache? Have the sensor daemons provide the Software interface?",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a63c2ce_acb8df05",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Agree with arj that this is underspecified, but reading between the lines a bit this implies that OpenBMC as an implementation we have two different daemons implementing support for the same device, which would mean we\u0027ve duplicated code, which as a matter of design, we shouldn\u0027t.  If this daemon supports, say, the adm1266 device fully, that node support should be removed entirely from PSUSensor so we maintain the \"one implementation per device\" guideline.\n\n\n\u003e Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards.\n\nAdmittedly, we kind of already have this support with the \"DisableNode\" stuff, but that was meant for when we wanted to implement more general limits, then more specific limits as more entities were detected.  It shouldn\u0027t be used for this case.",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d028cf09_9793a8d5",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eIf this daemon supports, say, the adm1266 device fully, that node support should \u003ebe removed entirely from PSUSensor so we maintain the \"one implementation per \u003edevice\" guideline.\n\nThat sounds reasonable to me , I was thinking that a different Type qualifier would cause the config to be ignored for dbus-sensors and used by this daemon.\n\n\u003eBut on that front, with the work required deal with this in a separate daemon that \u003eends up providing the Sensor interface itself, is there a reason why we can\u0027t add \u003egeneric support inside dbus-sensors that could be leveraged by each of the daemon \u003eimplementations? Doesn\u0027t that remove the conflict headache? Have the sensor \u003edaemons provide the Software interface?\n\nYes, that would avoid the headache. one of the reasons we are more interested in spinning off our own daemon is to improve sensor polling performance while we\u0027re at it. I suspect such performance increases in dbus-sensors would require some fundamental changes..\n\nAnd so spinning off a new daemon allows us the luxury of moving forward without much worry about breaking any systems that depend on the quirks of dbus-sensors.",
      "parentUuid": "8a63c2ce_acb8df05",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d23e92e_67e8ac1d",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 122,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "EM requires that every note has a \"Type\" field (and a Name field, but you got that right).  The way you\u0027re defining this, you need to change I2CDeviceType -\u003e Type and you\u0027d be mostly correct.",
      "range": {
        "startLine": 122,
        "startChar": 7,
        "endLine": 122,
        "endChar": 20
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac227381_54019dc5",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "I think you\u0027re missing a bunch of fields here.  an ADM1266 has multiple rails, multiple sensors, and some optionally implementable features, all of which need named per-system, scaled, and min/maxed per system.  Take a look at the existing PSUsensor devices for examples of how this would work.\n\nGiven you also plan on making control interfaces available, I suspect that will need to be configurable per system.  There are a number of systems that will need to treat the VRs as \"read only\" and that will need to be configurable at some level.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c71ec415_7a47f738",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 141,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Nope.  This isn\u0027t a requirement, and as a matter of being precise, entity-manager doesn\u0027t monitor any devices directly.  It does create some devices, but that\u0027s a remnant from a long dead design that I\u0027d really like to see die at some point in the future.",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 141,
        "endChar": 31
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d981f768_ce90d1a0",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Same as above.  \"any generic i2c device\" seems like a huge scope, unless you\u0027re planning on implementing support for OpenBIC, and management engine.  Lets scope this on pmbus devices.",
      "range": {
        "startLine": 156,
        "startChar": 4,
        "endLine": 156,
        "endChar": 22
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}