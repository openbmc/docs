{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "334525a6_0ad608a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1001162
      },
      "writtenOn": "2022-03-08T18:13:16Z",
      "side": 1,
      "message": "It looks like the discussion is trending towards improving dbus-sensors as much as possible rather than introduce yet another daemon to provide sensors, which I agree would help to reduce fragmentation. One of our primary motivations for this design was to eliminate i2c collisions from telemetry during firmware upgrades. So I\u0027m wondering, what is everyone\u0027s preference: option A) to integrate firmware upgrades into dbus-sensors or option B) provide some sort of \"pause\" API to temporarily disable telemetry in dbus-sensors during firmware upgrades that some other dedicated firmware upgrade daemon could toggle?",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37006619_0c4c38ed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-03-08T19:46:59Z",
      "side": 1,
      "message": "I vote for bundling firmware upgrades with sensor telemetry into the same daemon.",
      "parentUuid": "334525a6_0ad608a7",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "664af55b_2b8a0111",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-03-09T00:53:33Z",
      "side": 1,
      "message": "Also voting for bundling firmware upgrades with sensor telemetry into the same daemon (option A).",
      "parentUuid": "37006619_0c4c38ed",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3da02ff_3e42a07f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-03-09T01:46:49Z",
      "side": 1,
      "message": "Also agree with telemetry + firmware in same daemon (option A).\n\nThe reasons why we were considering alternatives was that some I2C devices or protocols need exclusive access to the entire I2C bus; not just exclusive access to the device. But I don\u0027t see this being a big concern right now. First, I haven\u0027t seen a misbehaving device like this in a few years; hopefully we don\u0027t ever again. Second, with MCTP in the kernel, we don\u0027t need to worry about some locking scheme for a user space MCTP. That seems to cover the immediate problems.",
      "parentUuid": "664af55b_2b8a0111",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5910c4ed_7f98c8d3",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 29,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "It is?  I don\u0027t know of any instances of using phosphor-ipmi-flash for i2c firmware updates?  Maybe I\u0027m out of touch?  No, it\u0027s the codebase that\u0027s wrong.\n\nhttps://i.kym-cdn.com/entries/icons/original/000/019/899/skinner.jpg",
      "range": {
        "startLine": 28,
        "startChar": 61,
        "endLine": 29,
        "endChar": 28
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22c3279f_61d9ea71",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Yes, we should do this as a design pattern.",
      "range": {
        "startLine": 30,
        "startChar": 35,
        "endLine": 32,
        "endChar": 20
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5bfb5b9_4e5af1c0",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 34,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Nit, this doc would read a lot better without mentioning the daemon in the \"background\" section.  At this point, no new daemon has been introduced, you\u0027re just documenting background on why some change is needed.",
      "range": {
        "startLine": 34,
        "startChar": 37,
        "endLine": 34,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f7d0f5b_e7da3b13",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "This isn\u0027t a requirement.  The requirement is implementing both telemetry and firmware update/configuration changes that don\u0027t conflict.  Requirements should avoid jumping into solution space, which a single daemon is one possible solution.",
      "range": {
        "startLine": 43,
        "startChar": 14,
        "endLine": 43,
        "endChar": 27
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c09e4b87_1171d762",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Having a single daemon that supports ALL i2c devices seems like a kind of extremely large scope.  Should we decrease it a bit to scope it down a bit, to say, only pmbus devices?  Otherwise this design conflicts directly with things like the BIC controller daemon that\u0027s currently in review for a new repo.",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85d947f7_1b2fdd43",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-02-07T19:23:45Z",
      "side": 1,
      "message": "The single daemon for all i2c idea is largely coming from my WIP proposals for performance improvements. Justin wanted to get this proposal out to get started on the firmware management discussions. Agreed, this doc doesn\u0027t provide enough justification as is. I will work with Justin and Jason to combine our proposals into a unified design.\n\nA daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time). That said, it is crucially important that it works in an cooperative, opt-in way. This daemon must live with other services using i2c and still provide predictable (if degraded) guarantees about performance, functionality, and reliability.\n\nExpect a more comprehensive proposal from the three of us that will superseded this doc.",
      "parentUuid": "c09e4b87_1171d762",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f46a2211_b7f262d7",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-02-08T07:39:28Z",
      "side": 1,
      "message": "I\u0027m a bit confused by this.  Elsewhere Jason wrote:\n\n\u003e It\u0027s not really a daemon for everything i2c, but for devices that require more than just telemetry so that all access to that device is encapsulated in a single application. I reworded the description to reflect this.\n\nI want to be very forward that I see this proposal as being a big uphill battle to get me convinced that this is the right architectural direction.  I\u0027ll read what you have with an open mind but I don\u0027t want you to feel like you\u0027re wasting time later on.\n\n\u003e A daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time)\n\nThis sounds like you\u0027re proposing yet another i2c-in-userspace implementation.  This is absolutely a no-go in my mind, unless I see a lot of data explaining why it is better.  You\u0027re talking about not only reimplementing hwmon and pmbus and mux control but EEPROM, GPIO, LED control, MCTP, IPMB, etc. and then merging them all into one giant codebase.  There is already a lot of kernel drivers and existing openbmc userspace code to handle these things.  Some of these have implementations that are leveraged for non-i2c buses, so we end up having a divergence of functionality and approach depending on which bus gets chosen by a particular hardware design.\n\nI really cannot conceive that the 2-4 bytes of i2c traffic to switch the mux is our performance bottleneck.  If you really think that it is, and again I\u0027d like to see data that shows this, I think you have at least three better options:\n\n1. Improve your hardware design so you\u0027re not cramming so many devices on a single i2c bus, but spread it out among the 6 (or more?) masters on the BMC chip.\n\n2. Get these scheduling enhancements ideas into the kernel i2c subsystem directly.\n\n3. Improve dbus-sensors so it is mux-aware and to handle better timer scheduling of the devices it is monitoring so that mux switching is minimized.",
      "parentUuid": "85d947f7_1b2fdd43",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a0b667d_fb51f3a3",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-02-08T18:24:26Z",
      "side": 1,
      "message": "\u003e This sounds like you\u0027re proposing yet another i2c-in-userspace implementation.\n\nAbsolutely not! I understand your concern. We will still defer to the hwmon drivers for the vast majority of I2C traffic in the same way that dbus-sensors does today.\n\n\u003e I really cannot conceive that the 2-4 bytes of i2c traffic to switch the mux is our performance bottleneck.\n\nWe have systems where with 2 nested muxes with i2c-mux-idle-disconnect enabled (fru-device misplaces eeproms otherwise) we see a 10x overhead with the muxes. That said, I don\u0027t want to over-emphasize this. I2C bandwidth is not the current bottleneck.\n\n\u003e 1. Improve your hardware design so you\u0027re not cramming so many devices on a single i2c bus, but spread it out among the 6 (or more?) masters on the BMC chip.\n\nYou\u0027re right that changing the hardware design is better. And removing i2c-mux-idle-disconnect is better still. This is a case where the racy nature of the current design causes issue. We find fru-device eeprom detection process to be unreliable at scale.\n\n\u003e 2. Get these scheduling enhancements ideas into the kernel i2c subsystem directly.\n\nScheduling in the kernel is an interesting idea. It would require something like io_uring to batch a number of requests and allowing the kernel to reorder them. That behavior would be pretty surprising. I\u0027m not sure it makes sense.\n\n\u003e 3. Improve dbus-sensors so it is mux-aware and to handle better timer scheduling of the devices it is monitoring so that mux switching is minimized.\n\ndbus-sensors cannot perform this scheduling because it distributes I2C responsibility across several different daemons.\n\nApologies for having a design discussion in these comments. Give us some time to come back with a more detailed proposal. I need to scrub our performance research of proprietary information so that we can publish it. That will make things more clear. I\u0027ll get back to you with more details.",
      "parentUuid": "f46a2211_b7f262d7",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e787e16_6ff9eb93",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "I think we\u0027re talking past eachother a little.  when I say \"ALL i2c devices\", I include smart controllers talking over IPMB, NVMe-MI capable drives, PLDM drives, and MCTP capable controllers.  I would hope that it isn\u0027t in your plan to intercept those with this deamon, considering we previously had a userspace implementation of each of the aforementioned, and moving to the kernel version improved performance, decreased the code complexity, and got rid of bugs.\n\nIf it is in your plan to intercept the above with this new implementation, that needs a much bigger design doc.\n\n\nIn the comments, we\u0027ve kinda dove into some more topics than this design doc can really handle.  i2c mux optimization probably deserves a design doc on its own, as that will have some far reaching implications, and there\u0027s probably 2-3 different designs that we\u0027ll likely need to discuss with the relevant experts.\n\n\n\n\u003e We will still defer to the hwmon drivers\n\nIs this true?  I guess I didn\u0027t process that part of this, and assumed that we\u0027d move the paging out of telemetry values into userspace based on the doc.  Given we\u0027re doing a hybrid, can this doc explicitly call out what data we\u0027re going to get from userspace, and what we\u0027ll get from hwmon?  Assuming I\u0027m reading this right, this is sounding more like we just need to add some features to PSUSensor (or some stronger child implementation of a different name) more than it is we need a totally new thing.\n\n\n\u003e another i2c-in-userspace implementation.  This is absolutely a no-go in my mind, unless I see a lot of data explaining why it is better.\n\nI think it comes down to \"it\u0027s possible to accomplish in a staffable (call it 2 year) time horizon\".  upstream kernel drivers with the various sysfs interfaces for all devices and all interfaces a BMC would need seems to get stopped in upstream, which while unfortunate, doesn\u0027t leave much alternative, as this doc calls out, unless there\u0027s a path I\u0027m missing that doesn\u0027t involve the kernel people adding a new sysfs interface, but still gets us VR firmware update and various model-specific telemetry in openbmc?  Doing pmbus in userspace is architecturally no different than a userspace implementation of IPMB reading that\u0027s being proposed for the OpenBIC stuff that the repo got requested for: It\u0027s taking an existing kernel interface, and implementing an interpretation of the raw interface in userspace.  This seems reasonable to me given the uphill battle with the kernel.  Given that, and your strong opinion here, I\u0027m really not quite understanding where the \"no-go\" line exists.",
      "parentUuid": "3a0b667d_fb51f3a3",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6894dd2a_d6c49a68",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-11T23:23:59Z",
      "side": 1,
      "message": "\u003e It would require something like io_uring to batch a number of requests and allowing the kernel to reorder them. That behavior would be pretty surprising. I\u0027m not sure it makes sense.\n\nFWIW, at least as far as the defined semantics of existing interfaces are concerned, io_uring requests are by default not ordered (hence the kernel is free to reorder them); if there are ordering requirements that you need to enforce you can use IOSQE_IO_DRAIN and/or IOSQE_IO_LINK (see sec. 5.1 \u0026 5.2 of https://kernel.dk/io_uring.pdf).\n\nHowever, in terms of the existing implementation, since the APIs in the i2c subsystem are all currently fully synchronous, by my understanding io_uring for i2c I/O would currently just end up punting all requests to a single work queue where I expect they\u0027d be carried out in the order they arrive -- so while the interfaces would allow for reordering, getting that to actually happen for this use-case would be non-trivial.",
      "parentUuid": "7e787e16_6ff9eb93",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abe73c7c_6b01c790",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 43,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2022-03-09T01:46:49Z",
      "side": 1,
      "message": "Update on the sensor performance conversation:\n\nI like to conceptualize performance optimization as a peak finding problem. As we make incremental performance improvements, we\u0027re performing a gradient ascent algorithm that will find the local performance maxima. However, the classic weakness of gradient ascent is that it can get stuck on a local maxima far away from the global maxima. So if the current dbus-sensor architecture is the current peak we\u0027re on, what other peaks are out there? Should we continue to ascend the dbus-sensors peak or search for another potentially higher peak? Let\u0027s consider 3 peaks:\n\n1. dbus-sensors Peak\n\nWith our current architecture, we can make incremental performance improvements. Most significantly, we should work on making our interprocess communication as efficient as possible. D-Bus is a significant bottleneck. We can directly attack the D-Bus bottleneck by batching updates or using alternative IPC. Less dramatic changes can also make a big impact like how matching signals can be much better than polling on D-Bus or other optimizations like delayed-release for I2C muxes (https://www.spinics.net/lists/linux-i2c/msg55343.html).\n\n2. Maximum Embedded Linux Performance Peak\n\nIf we\u0027re willing to step outside of the dbus-sensors architecture, there\u0027s much more we can do to improve performance. This is where the discussions about a larger service responsible for more I2C functionality comes in. A single I2C service could perform optimizations based on mux topology, for example. With care, embedded Linux can start to take on real-time characteristics. Funneling all IPC through dbus-broker prevents any real-time tuning today. Some primitive benchmarking shows that we can saturate I2C with \u003e10,000 sensor reads per second using \u003c10% CPU. D-Bus can\u0027t keep up with that, but Linux can if we\u0027re willing to redesign the software.\n\n3. Alternative Hardware and Operating Systems Peak\n\nBeyond Embedded Linux is an endless landscape of entirely different architectures. Different industries can poll sensors at tremendously high rates, but needs for BMCs top out at maybe 1-10 Hz per sensor, so there\u0027s really little need to consider exotic options. I have heard discussions about using co-processors or FPGAs for sensor polling, but I wouldn\u0027t recommend them. Stick with Linux.\n\n\nPeak 3 clearly doesn\u0027t make sense for BMCs, but there\u0027s an interesting discussion to be had between options 1 and 2. Both have been tried in the past; no design is a panacea. Ultimately, we\u0027re having this discussion because we\u0027ve seen performance problems with dbus-sensors and we need to fix them.\n\nCertainly earlier in this thread I was voting more for option 2, but today I am increasingly optimistic that there\u0027s a path to good enough with option 1. My colleagues and I will be working on improvements to the dbus-sensors stack in the coming year. In line with that, we should design I2C firmware updates for dbus-sensors interoperability.",
      "parentUuid": "6894dd2a_d6c49a68",
      "range": {
        "startLine": 43,
        "startChar": 38,
        "endLine": 43,
        "endChar": 49
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6eadc89a_2ba231d1",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Additional requirement, the code should fully deprecate the need for PSUsensor, given that it\u0027s duplicating a number of features and not sharing any code, it needs to use that featureset as a starting point to make it maintainable in the long term.\n\n\nI suspect we also need some requirements around being runtime invokable for when i2c devices exist on add in cards (solution probably being an EM reactor), otherwise this ends up being a point solution that only works on non DC-SCM baseboards.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2e4ac73_503b88ae",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eAdditional requirement, the code should fully deprecate the need for PSUsensor, \u003egiven that it\u0027s duplicating a number of features and not sharing any code, it \u003eneeds to use that featureset as a starting point to make it maintainable in the \u003elong term.\nI\u0027m okay with making this the long term replacement for PSUSensors. Of course the initial commits will focus heavily (exclusively) on implementing the features described in this design. Justin, thoughts?",
      "parentUuid": "6eadc89a_2ba231d1",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5d8f53f_e531e7ee",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "As I think about this more, and discussed with the other dbus-sensors maintainers, what I suspect needs to happen is:\n1. Refactor the \"sensor\" specific code out of PSU sensor, such that it can be reused, and we don\u0027t immediately lose features that the community (and Google-specifically) needs.  This is kind of already done, there\u0027s a sensor class, we just need to simplify the code a bit to make it more sane.\n2. Write the new application calling the underlying routines.  I\u0027d expect most of the existing userspace code to be shared, minus the \"where do we actually read the value\" portion, which would instead call into your userspace code.\n\nSeem reasonable?  The above avoids the problem of inventing a new \"thing\" then having to port all the use cases over to it, and I don\u0027t think your design has any plans on making major changes to how, say, thresholds, or dbus interfaces works, at least based on reading it, and we don\u0027t want to have to re-invent all that work that\u0027s already been done.",
      "parentUuid": "d2e4ac73_503b88ae",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3bea9e9b_00124cda",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1001358
      },
      "writtenOn": "2022-02-16T22:32:51Z",
      "side": 1,
      "message": "From my perspective supporting PMBus/SMBus/I2C Hot Swap, Regulators, Managers, and Sequencers at ADI, and from discussions within the PMBus Technical Committee, missing capabilities in linux based management systems are:\n\nA) Fetching Fault Logs used to diagnose failures\nB) Updating firmware stored in the slave Flash or EEPROM\nC) Updating settings stored in the slave Flash or EEPROM\nD) General access to MFR commands used for diagnostics or remote diagnosis\nE) Initialization of devices that do not store settings\nF) Status monitoring\n\nSome linux hwmon drivers use devicetree for E, but this is not usable on a delivered product.\n\nThe PMBus Technical Committee is interested in C and has done work to define a data language that works for all vendors, which allows for algorithmic behavior in addition to content.\n\nI have extended the ltc2978.c driver to support fault logs using debugfs, but it’s not practical because debugfs is not always enabled. But it demonstrates it is practical to do it a driver.\n\nB and C are quite different. I am a little surprised at B. I did not see this as a need until I saw it here. C is built into many products (non OBMC), and well established as a need.\n\nA enables tracking and predicting failures without requiring a product return to factory. F serves the same goal.\n\nE is probably less important for OBMC, but if more designs use newer low cost Regulators, they don’t have Flash or EEPROM. E becomes an equivalent of C for these devices.",
      "parentUuid": "f5d8f53f_e531e7ee",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b80cfd0_56e6e96a",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Isn\u0027t this duplicated with the requirement?\n\nHow is this interface backed?  Does it implement pmbus?",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 9
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c3e4070_f1e87a7b",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eIsn\u0027t this duplicated with the requirement?\n\nI don\u0027t understand this question.\n\n\u003eHow is this interface backed? \n\nIf we\u0027re talking about the interfaces used to actuate a firmware update then it\u0027s backed with a bunch of userspace code that knows how to update particular devices.\n\n\u003eDoes it implement pmbus?\n\nYes, each pmbus device gets its own class that knows how to update the device. The classes know how to read standard telemetry if we decide to do userspace vs kernel.",
      "parentUuid": "8b80cfd0_56e6e96a",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 9
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28bcf842_1533ee0c",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "\u003e \u003eIsn\u0027t this duplicated with the requirement?\n\u003e \n\u003e I don\u0027t understand this question.\n\n\nI was thinking that this was kind of duplicated with requirement 1 in the section above, but in re-reading, I understand your confusion.  Fine as is on this point.\n\n\u003e \n\u003e \u003eHow is this interface backed? \n\u003e \n\u003e If we\u0027re talking about the interfaces used to actuate a firmware update then it\u0027s backed with a bunch of userspace code that knows how to update particular devices.\n\u003e \n\u003e \u003eDoes it implement pmbus?\n\u003e \n\u003e Yes, each pmbus device gets its own class that knows how to update the device. The classes know how to read standard telemetry if we decide to do userspace vs kernel.\n\n\nMy point on the two above questions is that should be called out in your design.",
      "parentUuid": "2c3e4070_f1e87a7b",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 9
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38f84e65_3b2b62b4",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 68,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "This also feels like a requirement in the way it\u0027s phrased.  maybe move it up a section.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "236fcb04_e90adb92",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 78,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "It seems like this is kind of covered by the \"With a single daemon acting as an owner of a device\" statement previously.  If that\u0027s true, this isn\u0027t possible.",
      "range": {
        "startLine": 77,
        "startChar": 0,
        "endLine": 78,
        "endChar": 27
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6ecc541_1525acab",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "If it does this, it needs to not duplicate code.  We already have two implementations that are able to read from hwmon implementations (hwmontempsensor/psusenor, and phosphor-hwmon) as a matter of design, we need to avoid a having a third.",
      "range": {
        "startLine": 78,
        "startChar": 28,
        "endLine": 79,
        "endChar": 36
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e195ccb2_f3deb3c2",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-02-03T00:17:15Z",
      "side": 1,
      "message": "I don\u0027t feel like this is enough of a description of how this will be implemented in practice.\n\nEM board configs are written specific to the board they support with no regard for the system context in which they live. How do you handle wanting to update a device in system context A but not in system context B for the one card? Maybe you could argue that\u0027s not valid concern, but I think the point is it\u0027s a policy decision of the system designer/owner/maintainer.\n\nHow does this property get populated? Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards. It\u0027s almost as if you want a separate interface for these devices or something, so you don\u0027t trigger dbus-sensors to start with.\n\nBut on that front, with the work required deal with this in a separate daemon that ends up providing the Sensor interface itself, is there a reason why we can\u0027t add generic support inside dbus-sensors that could be leveraged by each of the daemon implementations? Doesn\u0027t that remove the conflict headache? Have the sensor daemons provide the Software interface?",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a63c2ce_acb8df05",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Agree with arj that this is underspecified, but reading between the lines a bit this implies that OpenBMC as an implementation we have two different daemons implementing support for the same device, which would mean we\u0027ve duplicated code, which as a matter of design, we shouldn\u0027t.  If this daemon supports, say, the adm1266 device fully, that node support should be removed entirely from PSUSensor so we maintain the \"one implementation per device\" guideline.\n\n\n\u003e Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards.\n\nAdmittedly, we kind of already have this support with the \"DisableNode\" stuff, but that was meant for when we wanted to implement more general limits, then more specific limits as more entities were detected.  It shouldn\u0027t be used for this case.",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d028cf09_9793a8d5",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000521
      },
      "writtenOn": "2022-02-07T19:00:15Z",
      "side": 1,
      "message": "\u003eIf this daemon supports, say, the adm1266 device fully, that node support should \u003ebe removed entirely from PSUSensor so we maintain the \"one implementation per \u003edevice\" guideline.\n\nThat sounds reasonable to me , I was thinking that a different Type qualifier would cause the config to be ignored for dbus-sensors and used by this daemon.\n\n\u003eBut on that front, with the work required deal with this in a separate daemon that \u003eends up providing the Sensor interface itself, is there a reason why we can\u0027t add \u003egeneric support inside dbus-sensors that could be leveraged by each of the daemon \u003eimplementations? Doesn\u0027t that remove the conflict headache? Have the sensor \u003edaemons provide the Software interface?\n\nYes, that would avoid the headache. one of the reasons we are more interested in spinning off our own daemon is to improve sensor polling performance while we\u0027re at it. I suspect such performance increases in dbus-sensors would require some fundamental changes..\n\nAnd so spinning off a new daemon allows us the luxury of moving forward without much worry about breaking any systems that depend on the quirks of dbus-sensors.",
      "parentUuid": "8a63c2ce_acb8df05",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdd06262_aad87d0c",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-09T02:42:17Z",
      "side": 1,
      "message": "\u003e \u003eIf this daemon supports, say, the adm1266 device fully, that node support should \u003ebe removed entirely from PSUSensor so we maintain the \"one implementation per \u003edevice\" guideline.\n\u003e \n\u003e That sounds reasonable to me , I was thinking that a different Type qualifier would cause the config to be ignored for dbus-sensors and used by this daemon.\n\u003e \n\u003e \u003eBut on that front, with the work required deal with this in a separate daemon that \u003eends up providing the Sensor interface itself, is there a reason why we can\u0027t add \u003egeneric support inside dbus-sensors that could be leveraged by each of the daemon \u003eimplementations? Doesn\u0027t that remove the conflict headache? Have the sensor \u003edaemons provide the Software interface?\n\u003e \n\u003e Yes, that would avoid the headache. one of the reasons we are more interested in spinning off our own daemon is to improve sensor polling performance while we\u0027re at it.\n\nI get that, and I have a lot of context for that, but that needs its own discussion and design doc.\n\n\u003e I suspect such performance increases in dbus-sensors would require some fundamental changes..\n\nSo, make the fundamental changes?  Dbus-sensors as a repo isn\u0027t THAT much code.  If we completely rewrote every line of it a year from now, I would be in no way sad, but we should avoid the \"yet another sensor implementation\" at the moment, when we haven\u0027t even finished the transition to dbus-sensors for all systems.\n\n\u003e \n\u003e And so spinning off a new daemon allows us the luxury of moving forward without much worry about breaking any systems that depend on the quirks of dbus-sensors.\n\nAnd therein lies the problem.  Those quirks (in most cases I would call them features) are in some cases important to having a solution that works for a wide array of systems.  I would much rather we break some systems in minor ways, have the community point it out, and fix the issues than try to maintain a 3rd (or 4th depending on how you count) way to scan sensors.",
      "parentUuid": "d028cf09_9793a8d5",
      "range": {
        "startLine": 85,
        "startChar": 9,
        "endLine": 86,
        "endChar": 12
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d23e92e_67e8ac1d",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 122,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "EM requires that every note has a \"Type\" field (and a Name field, but you got that right).  The way you\u0027re defining this, you need to change I2CDeviceType -\u003e Type and you\u0027d be mostly correct.",
      "range": {
        "startLine": 122,
        "startChar": 7,
        "endLine": 122,
        "endChar": 20
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac227381_54019dc5",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "I think you\u0027re missing a bunch of fields here.  an ADM1266 has multiple rails, multiple sensors, and some optionally implementable features, all of which need named per-system, scaled, and min/maxed per system.  Take a look at the existing PSUsensor devices for examples of how this would work.\n\nGiven you also plan on making control interfaces available, I suspect that will need to be configurable per system.  There are a number of systems that will need to treat the VRs as \"read only\" and that will need to be configurable at some level.",
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c71ec415_7a47f738",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 141,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Nope.  This isn\u0027t a requirement, and as a matter of being precise, entity-manager doesn\u0027t monitor any devices directly.  It does create some devices, but that\u0027s a remnant from a long dead design that I\u0027d really like to see die at some point in the future.",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 141,
        "endChar": 31
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d981f768_ce90d1a0",
        "filename": "designs/i2c-device-mgmt.md",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-03T23:15:31Z",
      "side": 1,
      "message": "Same as above.  \"any generic i2c device\" seems like a huge scope, unless you\u0027re planning on implementing support for OpenBIC, and management engine.  Lets scope this on pmbus devices.",
      "range": {
        "startLine": 156,
        "startChar": 4,
        "endLine": 156,
        "endChar": 22
      },
      "revId": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}