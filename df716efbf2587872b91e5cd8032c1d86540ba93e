{
  "comments": [
    {
      "key": {
        "uuid": "e6bea048_025b2546",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "Looks like Oracle has implemented something along the same lines, but it\u0027s not open source. Maybe they would be willing to open it, if they\u0027re participating in OpenBMC? :)\nhttps://docs.oracle.com/cd/E37444_01/html/E37451/z40000061645388.html",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf289375_807910b4",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "What\u0027s the use in overriding the reserved bits if we can tell that DTLS is supported just by looking at OpenBMC id in bytes 6:8 and some bits in byte 9?\nI\u0027m worried that treating reserved bits in the proposed way may bring some incompatibility with existing BMC implementations for the IPMI tools like ipmitool et. al.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be8b8a7_e04d6aef",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "While I\u0027m also wary of using the reserved bits, tying this to OpenBMC identification may limit the proliferation of this - what if other BMC stack vendors would want to implement this? In addition, not all OpenBMC versions would support this mechanism, so some sort of dynamic discovery is I think preferred.",
      "parentUuid": "cf289375_807910b4",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ec5d795_88b1b112",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 94,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "strictly speaking, it is \"IANA PEN\", not just \"IANA\".",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe704a14_91307937",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 98,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "I would right away define some OEM command to fetch the version of encoding of this byte.\nThat is, if bytes 6-8 are OpenBMC PEN, then fetch the version via an OEM command and then based on that data decode this byte 9. That version could also be used to differentiate other OEM field meanings.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49a83fe3_5a86c2ae",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 101,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "I\u0027d say \"If ... provides OpenBMC IANA PEN in bytes 6-8 and \u003csomething else\u003e\", leaving those reserved bits alone.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ee15bb5_d1889cae",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "Why accept 4 with \u0027STARTTLS\u0027 ? Let\u0027s limit it to just 5.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "65a90c52_eacab947",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "I suppose, if we only leave 5 (OEM proprietary auth), then the BMC would respond with a CCh completion code (Invalid data field in request) if no OEM proprietary auth is supported or with a 81h (invalid user name) indeed if there is some OEM auth, but there was no user named STARTTLS. An IPMI client though should not attempt to request a session challenge for STARTTLS \u0027user\u0027 if Get Channel Auth Capabilities didn\u0027t report an OpenBMC identification and the corresponding OEM command mentioned earlier didn\u0027t indicate support for RMCP+DTLS.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "458d9ece_5efb0de3",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 125,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "I guess we\u0027ll need a separate document to capture all the OEM / Device-specific completion codes (range 01h-7Eh) used by OpenBMC. Also, doesn\u0027t this specific case fall under 06h (No matching authentication payload) ?",
      "range": {
        "startLine": 125,
        "startChar": 49,
        "endLine": 125,
        "endChar": 52
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d675bfd5_af75715c",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 128,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "Looks very much like RMCP+ 04h (Invalid authentication algorithm).",
      "range": {
        "startLine": 128,
        "startChar": 28,
        "endLine": 128,
        "endChar": 66
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7f190b7_e2455181",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 135,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "How exactly that is specified in the request? I suppose auth type 5 (OEM) implies password auth, doesn\u0027t it? I don\u0027t see any other options.",
      "range": {
        "startLine": 135,
        "startChar": 0,
        "endLine": 135,
        "endChar": 40
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a5e9459_a9964ef6",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 136,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "I wonder how does this match the foundational idea of no longer storing passwords on the BMC? Do you mean that something like \"straight password\" would be used here and the BMC would check that against PAM? Just trying to understand the idea.",
      "range": {
        "startLine": 136,
        "startChar": 0,
        "endLine": 136,
        "endChar": 69
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0c8833d_ab35b922",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "Again, how exactly in that command anyone could request a certificate authentication?",
      "range": {
        "startLine": 138,
        "startChar": 3,
        "endLine": 138,
        "endChar": 74
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7138f993_307bf3ee",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:51:54Z",
      "side": 1,
      "message": "And in general, the request for client certificate is a part of the standard TLS handshake, so I don\u0027t think we need to duplicate this piece at the IPMI level.",
      "parentUuid": "c0c8833d_ab35b922",
      "range": {
        "startLine": 138,
        "startChar": 3,
        "endLine": 138,
        "endChar": 74
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d047d5eb_3fa069a1",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "That would be \"TLS\" (the protocol), not OpenSSL (the library)",
      "range": {
        "startLine": 139,
        "startChar": 45,
        "endLine": 139,
        "endChar": 52
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "983f6b69_0219757b",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 143,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "Won\u0027t CCh (Invalid data field in request) or C1h (Invalid command) suffice? I don\u0027t like the idea of hi-jacking reserved entities, be it bits or completion codes.",
      "range": {
        "startLine": 143,
        "startChar": 69,
        "endLine": 143,
        "endChar": 72
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb6b229e_97da7258",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 144,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "nit: this should be \"to\"",
      "range": {
        "startLine": 144,
        "startChar": 14,
        "endLine": 144,
        "endChar": 15
      },
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c439fa3c_ae5c1caf",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 164,
      "author": {
        "id": 1000443
      },
      "writtenOn": "2020-04-23T12:37:45Z",
      "side": 1,
      "message": "In the name of making as few changes into protocols as possible (because that may have unforeseen security consequences), I wonder if we could simply do a first-message analysis at the BMC side and if it\u0027s the DTLS ClientHello - we do RMCP+ over DTLS with appropriate authentication mechanism modifications (because we know it\u0027s the DTLS-enabled client that\u0027s talking to us), but if it\u0027s a standard IPMI RMCP+ message, we then turn to the legacy flows (if enabled by BMC admin). When user runs a tool, they would anyway specify the mode they want to run in explicitly (or the tool would have it in the defaults), so it seems to me we could avoid this dynamic determination/fallback with Get Channel Authentication Capabilities changes.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bee4186_afcfb12f",
        "filename": "designs/ipmi-over-dtls.md",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1000192
      },
      "writtenOn": "2020-04-23T11:26:54Z",
      "side": 1,
      "message": "There is also an option to run OpenVPN on OpenBMC and tunnel all the IPMI traffic inside a VPN. Not very convenient if there are multiple BMCs to communicate with.",
      "revId": "df716efbf2587872b91e5cd8032c1d86540ba93e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}