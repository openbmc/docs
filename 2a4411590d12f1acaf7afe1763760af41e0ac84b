{
  "comments": [
    {
      "key": {
        "uuid": "570f6126_81fb18d9",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "Better to remove \"(non-bridged)\" here (I believe your intention is to say that different networks bridging is not allowed).\n\nBut inside the distinct network there can be bridge too (inside that network system).",
      "range": {
        "startLine": 26,
        "startChar": 24,
        "endLine": 26,
        "endChar": 37
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdcf79e4_4300e491",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "how about I change this to \"(ie., non-bridged)\" ?",
      "parentUuid": "570f6126_81fb18d9",
      "range": {
        "startLine": 26,
        "startChar": 24,
        "endLine": 26,
        "endChar": 37
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6fd9ae9_810ab235",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 29,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "Each network can have multiple physical interfaces too. \n\nI meant, BMC to PCIe Add-on controller can have I2C, and Add-on-controller FW can have it\u0027s own Network to query lot of information internally, and can have I2C, Serial, I3C etc.",
      "range": {
        "startLine": 29,
        "startChar": 26,
        "endLine": 29,
        "endChar": 47
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94a3f23e_7107dff6",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 29,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "\u003e Each network can have multiple physical interfaces too. \n\u003e \n\nThis is covered by the bullet on line 23 right?",
      "parentUuid": "a6fd9ae9_810ab235",
      "range": {
        "startLine": 29,
        "startChar": 26,
        "endLine": 29,
        "endChar": 47
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d65858a_0498db63",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "We do consider the possibility of acting as a bridge.\nI\u0027m aware that MCTP bridge \u003d\u003d router, and this matches \"customizable routing configurations within a network\", but it\u0027s worth spelling this out explicitly here.",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e91da901_8f9ba6af",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Yep, good point, I\u0027ll be explicit about the bridging too.",
      "parentUuid": "3d65858a_0498db63",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc4d8918_2ecbe927",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "Between network bridging is not allowed. Only inside that network it is allowed.",
      "parentUuid": "3d65858a_0498db63",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23b0bd77_fe094fae",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-25T00:02:44Z",
      "side": 1,
      "message": "Richard, I\u0027m reading this part of the document as our actual use cases, so I don\u0027t think we should include the \"between network bridging is not allowed\" statement here, unless we have a strong requirement for keeping this inside the kernel (do we?).\n\nDo we even have enough knowledge inside the kernel to prevent userspace from creating potentially invalid routing configurations?\nBecause I don\u0027t think we do, and I don\u0027t thing we need to. I think it\u0027s similar to allowing userspace to assign a potentially invalid (not assigned by actual bus owner, and not part of \"static\" assignment bus owner point of view) EID to our NIC.\nIn this design, kernel side is just responsible for transport (delivering correct messages to correct sockets, routing) and abstracting away the medium-specific differences. We can\u0027t validate anything, since we don\u0027t implement control protocol. And I do believe this is completely fine (and similar to other in-kernel network protocols), as long as we only allow network configuration to be done by \"trusted\" userspace (think root, or CAP_NET_ADMIN).",
      "parentUuid": "bc4d8918_2ecbe927",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 32,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ffc818a_44a380c8",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 33,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "From the above, I infer that Infrastructure configuration for the following will be supported and expect it should be our goal.\n1. MCTP device acting like a static / dynamic Endpoint\n2. MCTP device acting like B.O and using the programmable EID Pool, or EID pool queried from Topmost B.O.\n(In this providing mechanism to detect new device presence or reset using physical interface logic or through MCTP protocol logic (discovery)).\n3. MCTP device acting as Topmost B.O.\n4. MCTP device working in multiple physical interfaces \u0026 providing Bridging functionality within that network\n5. MCTP device in multiple network (multiple sub-system).",
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "779daa2e_4134f60d",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 33,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "Yes, all of these cases should be supported.",
      "parentUuid": "7ffc818a_44a380c8",
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18809c6b_ed8aec1c",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 33,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "779daa2e_4134f60d",
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43fe387e_e8aadd02",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "We don\u0027t include discovery code in-kernel, right? We just leave it up to the userspace (as described in \"MCTP Control Protocol implementation\" and \"Neighbour and routing implementation\" sections).\nPerhaps you just mean endpoints with static EID here? It\u0027s worth spelling it out explicitly.",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6050bed_0106ac18",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Yes, that\u0027s correct - discovery would be implemented in mctpd. I\u0027ll include the \u0027static\u0027 qualifier there.",
      "parentUuid": "43fe387e_e8aadd02",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43007263_551f169b",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "How about handling all MCTP control through MCTPD process in first phase \u0026 in later phase for better optimization simple commands can be responded (say responding GetEID / GetMCTP message types) etc. with options for MCTPD to configure it in kernel.\n\nI see following is specified to be covered in Kernel\n\n1. MCTP packets assembly / disassembly and accordingly forwarding / receiving to/from user space based on Message Type. \n2. MCTP bridge, and forwarding the packet directly in kernel\n3. Kernel providing configuration facility such that MCTPD process / configuration is sent to Kernel (related to network, Endpoint or Bridge-B.O (or Topmost) - using static EID / EID Pool / dynamic query etc.) with multiple network.\n\nAny way for Peer-to-peer setting static EID configuration is fine and none of the MCTP control packet message needs to be handled?",
      "parentUuid": "43fe387e_e8aadd02",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b847e58_b7269eee",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "\u003e How about handling all MCTP control through MCTPD process in first phase \u0026 in later phase for better optimization simple commands can be responded (say responding GetEID / GetMCTP message types) etc. with options for MCTPD to configure it in kernel.\n\nI\u0027d want to see evidence of needing the lower latency before pushing more complexity into the kernel.",
      "parentUuid": "43007263_551f169b",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6af77895_f820ee81",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "Yes, we\u0027re not excluding an in-kernel control protocol implementation, I just don\u0027t cover it here, nor do I see a need for it just yet.\n\nWe can certainly add a new design for that in future, if the need arises.",
      "parentUuid": "5b847e58_b7269eee",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2af9762b_f1df70da",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-25T00:02:44Z",
      "side": 1,
      "message": "Let\u0027s keep the kernel side responsibilities as small as possible for the initial submission. Thanks for addressing my comment about static EIDs.",
      "parentUuid": "6af77895_f820ee81",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 56,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "57464f89_863140b1",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "We operate directly at the transport layer (L3), and yet we expose the type (L4) both in the address and in the packet. If we include IC bit in the address, we could drop message type byte (with IC bit) from the messages exposed to userspace. The integrity check at the end is problematic. We\u0027re still not separating the layers clearly (because it\u0027s not fully defined in L4 and depends on L5 - we\u0027d need to have knowledge of all L5 protocols in kernel in order to compute the integrity... and as you already mentioned elsewhere in this document - we don\u0027t want to do that), but at least we\u0027re only leaking the \"trailer\" part of L4 and we won\u0027t need to check whether first byte of every sent message matches what\u0027s in the address.\n\nIncluding a drawing as reference for further comments:\n \n+---------------------------------------------------+\n|              medium specific header (L2)          |\n+---------------------------------------------------+\n|               transport header (L3)               |\n+-------------+-------------------------------------+\n|msg type (L4)|     message (L5)                    |\n+-------------+                      +--------------+\n|                                    | msg IC (L4)  |\n+------------------------------------+--------------+\n|            medium specific trailer (L2)           |\n+---------------------------------------------------+",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 114,
        "endChar": 30
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e92b790b_5774b551",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "I\u0027ve been considering a lot of options here; as you\u0027ve mentioned, there\u0027s a bit of difficulty here in that there\u0027s a bit of cross-layer dependencies as defined in the spec. I like your diagram, thanks for that!\n\nI would really prefer for the kernel to strip the message type byte, as it\u0027s redundant if we\u0027re also including it in the addressing information, and slightly more onerous for the applications to have to handle it themselves.\n\nDespite this though, I don\u0027t think that the other options are an improvement. If we\u0027re stripping the msg type byte, but not the IC, then the kernel interface is half-L3, half-L4.\n\nSo, having the kernel/userspace boundary correspond to the L3/L4 boundary seems to be the neatest approach. This has the advantage of corresponding to how the L5 specs are written - they all include the message type \u0026 IC bytes in their message descriptions.\n\nKeep in mind too that the message type specification may be larger than a byte; the vendor-defined types will be up to 5 bytes long. If we can avoid splitting those up, that would be slightly better.\n\nIf we do find a neat way to strip the message-type byte, I\u0027d be keen to adopt it, but all my approaches so far have just involved a whole lot of layering-violations!\n\nMy intention for allowing the kernel to work on the layer-4 data is by adding specific protocol support, via the \u0027protocol\u0027 option to socket(), allowing L4-specific message handling, which may handle the type and IC as required for that protocol. Those implementations aren\u0027t covered by this though, so I don\u0027t want to specify too much there.",
      "parentUuid": "57464f89_863140b1",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 114,
        "endChar": 30
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2739b546_cd85fdce",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Ack (we can go back to this during implementation).",
      "parentUuid": "e92b790b_5774b551",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 114,
        "endChar": 30
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39b6430b_ae65b92e",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 125,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "I understand that we need to expose tag owner bit to the userspace, but what\u0027s the requirement for exposing the tag value?\nYou mention that \"If the `MCTP_TAG_OWNER` bit is set in this field, the `MCTP_TAG_VALUE`\nbits are ignored, and will be set by the kernel.\".\nWhat\u0027s the point of populating it on the receive side? In other words - how is userspace expected to use this information?\nDo we have a use case where both sides are using TO\u003d0 and using TAGs to match requests and responses? Or is it something else entirely?\nIf it\u0027s not needed, perhaps we could keep this limited to tag-owner bit?",
      "range": {
        "startLine": 125,
        "startChar": 1,
        "endLine": 125,
        "endChar": 42
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "637356af_3897be6a",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 125,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "\u003e I understand that we need to expose tag owner bit to the userspace, but what\u0027s the requirement for exposing the tag value?\n\u003e What\u0027s the point of populating it on the receive side? In other words - how is userspace expected to use this information?\n\nUserspace needs to specify the tag value of an outgoing TO\u003d0 message.\n\nConsider a responder, performing a recvmsg() to receive incoming requests. Those request messages will have TO\u003d1, and a tag value generated by the remote peer.\n\nThe responder is required to use the same tag value in the response; so it will pass the incoming tag value, but with TO\u003d0, to the sendmsg() call to transmit the reply. The kernel will transmit this message with the TO and tag value as-is.\n\nEssentially, we need some way for userspace to provide an outgoing TO\u003d0 value, which comes from the original request. So, the struct sockaddr_mctp needs to provide this on the receive side.\n\nBecause there may be multiple requests in-flight, the kernel cannot handle the outgoing tag values automatically; only userspace has the knowledge of which responses correspond to which requests.\n\n\u003e Do we have a use case where both sides are using TO\u003d0 and using TAGs to match requests and responses?\n\nThe tag value needs to come from somewhere, so I can\u0027t see how both sides using TO\u003d0 would be possible...\n\n\u003e If it\u0027s not needed, perhaps we could keep this limited to tag-owner bit?\n\nI can\u0027t see a way to avoid needing it.",
      "parentUuid": "39b6430b_ae65b92e",
      "range": {
        "startLine": 125,
        "startChar": 1,
        "endLine": 125,
        "endChar": 42
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3f98281_77a4059d",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 125,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Thanks for the explanation. I thought about using ordering - but that doesn\u0027t make sense, we don\u0027t strictly require response for each request.",
      "parentUuid": "637356af_3897be6a",
      "range": {
        "startLine": 125,
        "startChar": 1,
        "endLine": 125,
        "endChar": 42
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "29e460cf_cf18a3b1",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 179,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "nit: typo smctp_addr",
      "range": {
        "startLine": 179,
        "startChar": 1,
        "endLine": 179,
        "endChar": 10
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42fd34d7_33642188",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 179,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "29e460cf_cf18a3b1",
      "range": {
        "startLine": 179,
        "startChar": 1,
        "endLine": 179,
        "endChar": 10
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0f159b9f_4d44a0d8",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 185,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "Are we also going to only send messages with TO bit clear (responses) through the bound socket?",
      "range": {
        "startLine": 183,
        "startChar": 0,
        "endLine": 185,
        "endChar": 16
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "695d1276_36fb2bb4",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 185,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Not necessarily; it\u0027s still possible to send TO\u003d1 messages through that bound socket. This will elicit the same behaviour as any other TO\u003d1 transmit.\n\n[it doesn\u0027t sound like a fantastic idea, but no specific reason for the kernel to forbid it]",
      "parentUuid": "0f159b9f_4d44a0d8",
      "range": {
        "startLine": 183,
        "startChar": 0,
        "endLine": 185,
        "endChar": 16
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ffcfbd42_202c075a",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 185,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "695d1276_36fb2bb4",
      "range": {
        "startLine": 183,
        "startChar": 0,
        "endLine": 185,
        "endChar": 16
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "37c2dc6a_6b891094",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "I understand the need for *ANY* on network and source address, but what\u0027s the use case for *ANY* type?\n\nIt feels like we\u0027re trying to fit all of the MCTP layers inside a single protocol.\nIf we\u0027re implementing MCTP L4 - we should leave \"MCTP_TYPE_ANY\" to clients that operate directly on L3, similar to how there\u0027s no \"TCP/UDP wildcard\" for listening on all ports.\nI guess in our case a catch-all type would also mean implementing SOCK_RAW? Or we could also express that using protocol field?\n\nFor example:\n    struct sockaddr_mctp addr;\n\n    int sd \u003d socket(AF_MCTP, SOCK_DGRAM, 0);\n    addr.smctp_network \u003d MCTP_NET_ANY;\n    addr.smctp_addr.s_addr \u003d MCTP_ADDR_ANY;\n    addr.smctp_type \u003d MCTP_TYPE_ANY;\n    int rc \u003d bind(sd, (struct sockaddr *)\u0026addr, sizeof(addr));\n\nCould become:\n    struct sockaddr_mctp addr;\n\n    int sd \u003d socket(AF_MCTP, SOCK_DGRAM, MCTPPROTO_L3);\n    /* Or socket(AF_MCTP, SOCK_RAW, 0) */\n    addr.smctp_network \u003d MCTP_NET_ANY;\n    addr.smctp_addr.s_addr \u003d MCTP_ADDR_ANY;\n    /* This would be ignored by the kernel: addr.smctp_type \u003d MCTP_TYPE_ANY; */\n    int rc \u003d bind(sd, (struct sockaddr *)\u0026addr, sizeof(addr));\n\nThe userspace would need to deal with handling the full transport (L3) header. And we can also require CAP_NET_RAW, similar to IP protocol.",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 199,
        "endChar": 68
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47a7b301_99db34fc",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "A potential use-case for the ANY type is to allow a single application to handle all MCTP traffic. I wouldn\u0027t encourage the design, but some folks may find it useful.\n\nMy original intention for SOCK_RAW was for packet-level headers, but that\u0027s probably better handled by a packet socket instead.\n\nWe could instead do this with SOCK_RAW, yes; I\u0027m OK with either option, and happy to remove the ANY type. In fact, it may be better to remove the ANY type regardless, until we have a solid use-case.",
      "parentUuid": "37c2dc6a_6b891094",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 199,
        "endChar": 68
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15bcb383_882f3863",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "Iwona, in that case how we will specify the needed TYPE? With any full match is possible, but what about restricted. Say PLDM daemon want to monitor only PLDM message types, how that can be specified here? we need to specify smctp_type. \nThe only question is are we plan to map it to the bit position so that multiple combination is possible (Even though not sure, who will use it like that).",
      "parentUuid": "37c2dc6a_6b891094",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 199,
        "endChar": 68
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90ffab20_7e91e6c2",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Jeremy, best way of not encouraging such design would be to not include it in the first place ;) (but keeping things open for extension - if someone *really* requires this). On the other hand, if we add this now and then we realize that we don\u0027t want it - we may not be able to remove it (because someone is already using it without *really* requiring it, but removing it would break their application, and we don\u0027t want to break user applications).\n\nRichard, we won\u0027t. The concept of TYPE is not defined for lower layers - it\u0027s only defined for L4 and above (see my diagram in the previous comments).\n\nMy suggestion was just related to the \"MCTP_TYPE_ANY\" special wildcard value.\nI do believe that kernel-API should be designed based on specific use cases. I can see a use case for using sockets operating on lower layer - I can\u0027t see a use case for doing MCTP_TYPE_ANY.\n\nIf PLDM daemon wants to monitor only PLDM message types - it\u0027s going to just use:\nsocket(AF_MCTP, SOCK_DGRAM, 0), and pass MCTP_TYPE_PLDM as type.\nIf PLDM daemon wants to capture every possible message type - it\u0027s going to operate on the lower layer (where the concept of message type doesn\u0027t exist).\nIf you want to handle multiple types - you create multiple sockets and bind each one to different type.",
      "parentUuid": "15bcb383_882f3863",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 199,
        "endChar": 68
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f94f1b1_e585a5d5",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "Yeah, I\u0027m OK with that approach. I\u0027ll remove the facility to bind on MCTP_TYPE_ANY for now, we can add it later if we find it\u0027s necessary.\n\nYour suggestion of opening the socket on a lower layer has other implications though; as that may mean you don\u0027t get message reassembly or kernel tag handling.",
      "parentUuid": "90ffab20_7e91e6c2",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 199,
        "endChar": 68
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a59611de_7562221c",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 230,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "how about communication in which EID is not set yet. In that case, how the device will be differentiated?",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 230,
        "endChar": 30
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb2575f0_4098a6e0",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 230,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "I think this should be covered by `MCTP_ADDR_EXT`?",
      "parentUuid": "a59611de_7562221c",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 230,
        "endChar": 30
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "495ebb58_7225ec43",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "What if it\u0027s not set?\nSay we\u0027re doing a \"connect()\" with tag owner bit cleared and send a message.\nWhat do we use to get this message on the receive side?",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "184e8932_c6f84bc7",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Like the send functions, specifying a tag value with TO\u003d0 will use the tag value as-is.\n\nI\u0027ll add this case in the text.",
      "parentUuid": "495ebb58_7225ec43",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1de67d3_1a7f8293",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Hm... imagine the situation when one process calls bind() and another one calls connect() (or just uses sendmsg() directly):\n\nProcess A - \"bind() side\"\n    addr.smctp_family \u003d AF_MCTP;\n    addr.smctp_network \u003d 0;\n    addr.smctp_addr.s_addr \u003d 8;\n    addr.smctp_type \u003d MCTP_TYPE_ECHO;\nProcess B - \"connect() side\"\n    addr.smctp_family \u003d AF_MCTP;\n    addr.smctp_network \u003d 0;\n    addr.smctp_addr.s_addr \u003d 8;\n    addr.smctp_type \u003d MCTP_TYPE_ECHO;\n    addr.smctp_tag \u003d \u003cguess_a_value - it\u0027s just 3 bits, shouldn\u0027t be too hard\u003e;\n\nProcess B is free to create a socket and connect it to endpoint 8. Since its TO is 0, it\u0027s free to \"guess\" a tag value that is going to be used as a response by process A and send messages to endpoint 8 using it. Endpoint 8 will get the message from process B, and will interpret it as a response to its message (which was delivered to process A).\n\nIs that a problem? Or just something we have to accept? Or perhaps this can\u0027t happen?",
      "parentUuid": "184e8932_c6f84bc7",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3387f8d8_86433427",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-23T04:50:33Z",
      "side": 1,
      "message": "Let\u0027s assume these processes are using different sockets, i.e. haven\u0027t shared the socket somehow (fork or fd-passing).\n\nI think we could fix this with the same correlation table we use to track TO\u003d0 responses for a connect()ed socket: For bind() sockets, receipt of a TO\u003d1 message has happen before the TO\u003d0 response is sent. For all sockets, we can error out calls to send*() for messages with TO\u003d0 if the socket has no appropriate terminus record with TO\u003d1 for the provided tag. This would prevent transmission of the bogus message in your example.\n\nThoughts?",
      "parentUuid": "b1de67d3_1a7f8293",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d88f7f6_cabfc1a7",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "I\u0027m assuming that for your case here, these processes are on the same machine, and process B is  (potentially maliciously) attempting to receive messages that should be going to process A. Is that correct?\n\nIn that case, we\u0027re still OK. Sending a TO\u003d0 message does not establish any local mapping for the TO\u003d1 pair of that tag to the socket. Only when a tag is allocated by the kernel (through a TO\u003d1 connect or send) do we set up an mapping for the corresponding TO\u003d0 pair (to allow a socket to receive the response).\n\n----\n\nIf my assumption about your case is incorrect, and these processes are on different machines, and want to communicate, then that\u0027s not going to work. You mention:\n\n\u003e Since its TO is 0, it\u0027s free to \"guess\" a tag value that is going to be used as a response by process A and send messages to endpoint 8 using it\n\nbut it\u0027s not free to guess a tag value; if TO\u003d0, that indicates that the tag value came from the peer.\n\nIn this case, the kernel will drop the incoming packet, as it has TO\u003d0, but the tag does not match an existing valid tag value for that destination. From DSP0236, section 8.6:\n\n\u003e Individual packets are dropped (silently discarded) by an endpoint under the following conditions.\n\u003e [...]\n\u003e * A message with TO bit \u003d 0 was received, indicating that the destination endpoint was the originator of the tag value, but the destination endpoint did not originate that value, or is no longer expecting it.",
      "parentUuid": "b1de67d3_1a7f8293",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1157ca6_d94dbad5",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:52:54Z",
      "side": 1,
      "message": "Andrew\u0027s response arrived after I\u0027d started my own, now I see what the potential issue is, as potentially duplicated responses for the receiving endpoint.\n\nWhile this is somewhat of a limitation of the MCTP protocol; in that the tag space is super small, I do like the idea of preventing TO\u003d0 message transmission where no TO\u003d1 message has been received prior to that.",
      "parentUuid": "7d88f7f6_cabfc1a7",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b533c69d_b330f4d0",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T21:16:52Z",
      "side": 1,
      "message": "Yes, this is about the case where two processes on the same machine are using different sockets and one of them is acting \"maliciously\".\nAnd yes - preventing TO\u003d0 message transmission where no TO\u003d1 message has been received makes sense.\nBut (and please correct me if I\u0027m wrong) the only way to receive a TO\u003d1 message is to create a socket and use bind(), right?\nIn other words - the process already has a way to send a response (TO\u003d0 message), and that\u0027s using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we\u0027re going to use connect() with TO\u003d0 (or allow using sendmsg() with TO\u003d0 on a socket that\u0027s not \"bound\")?",
      "parentUuid": "b1157ca6_d94dbad5",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8945126_3281cd8c",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-23T23:59:58Z",
      "side": 1,
      "message": "\u003e But (and please correct me if I\u0027m wrong) the only way to receive a TO\u003d1 message is to create a socket and use bind(), right?\n\nRight, that\u0027s my understanding.\n\n\u003e In other words - the process already has a way to send a response (TO\u003d0 message), and that\u0027s using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we\u0027re going to use connect() with TO\u003d0 (or allow using sendmsg() with TO\u003d0 on a socket that\u0027s not \"bound\")?\n\nSo what you\u0027re suggesting is that the bind() state of a socket is enough to accept or reject send*() calls with TO\u003d0?\n\nJeremy: Does bind() constrain the message type for send*() calls? I don\u0027t think even connect() constrains the message type for subsequent send{to,msg}() calls on the same socket? My understanding is we require that the provided struct sockaddr_mctp smctp_type value matches the bottom 7 bits of the message type byte in the message buffer, right?\n\nI think Iwona\u0027s suggestion could work so long as we specify that bind() will give EADDRINUSE if multiple applications attempt to bind to the same message type (do we want allow SO_REUSEPORT?), _and_ that bound sockets constrain to send{to,msg}() to the bound message type.\n\nHowever, it does leave a class of errors on the table, namely that any bound socket can send a TO\u003d0 message to a terminus from which we haven\u0027t received a TO\u003d1 message. Further, without constraining bound sockets to the one message type, not filtering send*() by TO\u003d1 terminus IDs associated with the socket means (malicious) process B could work around the constraint by just first binding the socket to an arbitrary message type.\n\nSo I still think filtering send*() calls based on the terminus set associated with the socket might be a good idea.",
      "parentUuid": "b533c69d_b330f4d0",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1dda9847_e031ab72",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-24T03:10:40Z",
      "side": 1,
      "message": "\u003e But (and please correct me if I\u0027m wrong) the only way to receive a TO\u003d1 message is to create a socket and use bind(), right?\n\nYes, I think that\u0027s a sensible call. My original intention was to *not* prohibit TO\u003d0 transmission for arbitrary tag values (perhaps the tag value was discovered through some other out-of-band mechanism), but that does cause the problems you\u0027ve outlined above.\n\nSo I\u0027m happy to prohibit sending where the TO\u003d0 tag value does not match an existing terminus, or depending on the bind() state - the choice of which depends on the outcomes of the discussion below. We could relax that later if really necessary.\n\n\u003e \u003e In other words - the process already has a way to send a response (TO\u003d0 message), and that\u0027s using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we\u0027re going to use connect() with TO\u003d0 (or allow using sendmsg() with TO\u003d0 on a socket that\u0027s not \"bound\")?\n\u003e \n\u003e So what you\u0027re suggesting is that the bind() state of a socket is enough to accept or reject send*() calls with TO\u003d0?\n\n[just clarifying here; by \"bound\" I assume you\u0027re referring to an explicit bind() call, rather than the implicit \"binding\" to the TO\u003d0 terminus that happens when you send a TO\u003d1 message]\n\n\u003e Jeremy: Does bind() constrain the message type for send*() calls?\n\nNot currently, but that would make sense to do. Here\u0027s the summary so far:\n\n - the only way that an application will have a valid TO\u003d0 tag value is by receiving a TO\u003d1 message\n - the only way to receive a TO\u003d1 message is to bind()\n\nSo, as Iwona is suggesting, we can disallow TO\u003d0 transmission if the socket has not been explicitly bound (thorough bind()) to the appropriate message type. Unless I\u0027ve missed something?\n\n\u003e My understanding is we require that the provided struct sockaddr_mctp smctp_type value matches the bottom 7 bits of the message type byte in the message buffer, right?\n\nThat\u0027s correct.\n\n\u003e I think Iwona\u0027s suggestion could work so long as we specify that bind() will give EADDRINUSE if multiple applications attempt to bind to the same message type (do we want allow SO_REUSEPORT?), _and_ that bound sockets constrain to send{to,msg}() to the bound message type.\n\nYep, both of those are sensible.\n\n`SO_REUSEPORT` is fine; it requires separate processes to have the same euid.\n\nAlong those lines, we may also want to prohibit a single socket from *ever* sending multiple types, to keep the requirements somewhat consistent for requester-type sockets too.\n\n\u003e \n\u003e However, it does leave a class of errors on the table, namely that any bound socket can send a TO\u003d0 message to a terminus from which we haven\u0027t received a TO\u003d1 message. Further, without constraining bound sockets to the one message type, not filtering send*() by TO\u003d1 terminus IDs associated with the socket means (malicious) process B could work around the constraint by just first binding the socket to an arbitrary message type.\n\nIt sounds like we\u0027ve met all of those preconditions anyway?\n\nI\u0027m happy to start out restrictive, and we may want to rework during development if we find more use-cases.\n \n\u003e So I still think filtering send*() calls based on the terminus set associated with the socket might be a good idea.\n\nThe \"you can\u0027t send TO\u003d0 without bind()\" is a little easier to describe to users :D",
      "parentUuid": "c8945126_3281cd8c",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1533ba26_e2cbf509",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-24T22:56:14Z",
      "side": 1,
      "message": "\u003e The \"you can\u0027t send TO\u003d0 without bind()\" is a little easier to describe to users :D\n\nWell, a description of my proposal to filter based on the terminus correlation set might be:\n\n\"Sockets will only receive responses to requests they have sent (TO\u003d1). Bound sockets may only respond (TO\u003d0) to requests they have received\".\n\nI don\u0027t think that\u0027s particularly complex. Also I feel constraining socket behaviour to meet this criteria gives an implementation of the intuitive behaviour while also mitigating against abusive or buggy usage patterns (responding to an incorrect terminus).",
      "parentUuid": "1dda9847_e031ab72",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "662af444_8b8e9378",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 236,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-25T00:02:44Z",
      "side": 1,
      "message": "Yeah - this covers the usage model without too much details of \"how\" we actually want to achieve it. But shouldn\u0027t we drop the \"bound\"?\n\n\"Sockets will only receive responses to requests they have sent (TO\u003d1) and may only respond (TO\u003d0) to requests they have received\"",
      "parentUuid": "1dda9847_e031ab72",
      "range": {
        "startLine": 236,
        "startChar": 8,
        "endLine": 236,
        "endChar": 56
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be8765a9_d0142ace",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 263,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "thought this will do the substitution to the MCTP message type, so @266 is redundant right? or is it limited only to filtering?",
      "range": {
        "startLine": 263,
        "startChar": 4,
        "endLine": 263,
        "endChar": 37
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6778bd5_87494748",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 263,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "The current thought is to later add more `protocol` options for the socket() call which would include manipulating the message to check the IC and strip the type byte based on the protocol. Conflicting values for addr.smctp_type and the first byte of the message for socket(AF_MCTP, SOCK_DGRAM, 0) is an error.",
      "parentUuid": "be8765a9_d0142ace",
      "range": {
        "startLine": 263,
        "startChar": 4,
        "endLine": 263,
        "endChar": 37
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a77682_6dd36336",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 266,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-21T18:54:16Z",
      "side": 1,
      "message": "nit: You should probably just use MCTP_TYPE_ECHO here ;) Unless this is a \"negative\" example that\u0027s going to return -EPROTO on sendto().",
      "range": {
        "startLine": 266,
        "startChar": 1,
        "endLine": 266,
        "endChar": 28
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bba6e62f_3d7134a9",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 266,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Ah, good catch! This isn\u0027t supposed to be a negative example, I\u0027ll fix this up.",
      "parentUuid": "33a77682_6dd36336",
      "range": {
        "startLine": 266,
        "startChar": 1,
        "endLine": 266,
        "endChar": 28
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7676695_81486195",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 266,
      "author": {
        "id": 1000461
      },
      "writtenOn": "2021-02-23T00:04:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "bba6e62f_3d7134a9",
      "range": {
        "startLine": 266,
        "startChar": 1,
        "endLine": 266,
        "endChar": 28
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bb2fdebc_59964970",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 294,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-19T09:49:31Z",
      "side": 1,
      "message": "Maybe \"The `connect()` address and tag\", which will help out with my next comment",
      "range": {
        "startLine": 294,
        "startChar": 41,
        "endLine": 294,
        "endChar": 64
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b0badda_77cf87e2",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 294,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Good call, changed.",
      "parentUuid": "bb2fdebc_59964970",
      "range": {
        "startLine": 294,
        "startChar": 41,
        "endLine": 294,
        "endChar": 64
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce4a36ec_460d26bb",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 298,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-19T09:49:31Z",
      "side": 1,
      "message": "So as it stands this mostly reiterates the previous sentence. To address my questions on in PS3 I think it would be more useful if it said something like your reply to my comment:\n\n\"The tag allocated through a call to `sendto()` or `sendmsg()` on a connected socket is subject to the same invalidation logic as on an unconnected socket: It is expired either by timeout or by a subsequent `sendto()`.\"",
      "range": {
        "startLine": 295,
        "startChar": 58,
        "endLine": 298,
        "endChar": 31
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9475a7c_3a8e147a",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 298,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "That\u0027s much better, thanks.",
      "parentUuid": "ce4a36ec_460d26bb",
      "range": {
        "startLine": 295,
        "startChar": 58,
        "endLine": 298,
        "endChar": 31
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b768a6b6_f06e94e3",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 352,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "You meant to say for the current sent packet. So, if we do multiple commands are sent, with TagOwner set, then in order to know the tagValue, getsockname() needs to be called after each send()",
      "range": {
        "startLine": 350,
        "startChar": 0,
        "endLine": 352,
        "endChar": 6
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d7171b5_ccf98866",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 352,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "Yeah I think this needs some clarification. Another straw-person idea is only allowing it for connected sockets?",
      "parentUuid": "b768a6b6_f06e94e3",
      "range": {
        "startLine": 350,
        "startChar": 0,
        "endLine": 352,
        "endChar": 6
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01631552_40293d69",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 352,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "The semantics are a bit tricky here; getsockname() is for retrieving the local address, getpeername() is for retrieving the remote address.\n\ngetsockname() can retrieve the address used for a bind() - which, in our case does not include any tag allocation. getpeername() would be for that. I\u0027ll clarify here.",
      "parentUuid": "3d7171b5_ccf98866",
      "range": {
        "startLine": 350,
        "startChar": 0,
        "endLine": 352,
        "endChar": 6
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8aa58a96_ecee2095",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 384,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "to be used in case of NULL EID right?",
      "range": {
        "startLine": 358,
        "startChar": 0,
        "endLine": 384,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94ad7f6e_d687e1be",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 384,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "Yes",
      "parentUuid": "8aa58a96_ecee2095",
      "range": {
        "startLine": 358,
        "startChar": 0,
        "endLine": 384,
        "endChar": 0
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "439cc78d_b170cf41",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 402,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-19T09:49:31Z",
      "side": 1,
      "message": "what do you think about removing \"previous\" here? It caused me some confusion when reading PS3.",
      "range": {
        "startLine": 402,
        "startChar": 0,
        "endLine": 402,
        "endChar": 8
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a71a55b9_337c5e3a",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 402,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Ah yes, I was planning this and it slipped through. Deleted.",
      "parentUuid": "439cc78d_b170cf41",
      "range": {
        "startLine": 402,
        "startChar": 0,
        "endLine": 402,
        "endChar": 8
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef60a17e_521a6ca9",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 404,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-02-22T09:14:08Z",
      "side": 1,
      "message": "Not clear when this is required.\nI meant once response with multiple MCTP Packets(SOM to EOM - i.e. Proper MCTP message response), is received then the tag value can be cleaned and reused as per the timeout. Why do we expect to hold it, even after receiving the response?",
      "range": {
        "startLine": 401,
        "startChar": 0,
        "endLine": 404,
        "endChar": 36
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e52db383_75620f12",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 404,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "See the discussion on line 922 onwards.",
      "parentUuid": "ef60a17e_521a6ca9",
      "range": {
        "startLine": 401,
        "startChar": 0,
        "endLine": 404,
        "endChar": 36
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1c742d3_7b6108ad",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 404,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-23T05:26:02Z",
      "side": 1,
      "message": "Yes, as Andrew has indicated.\n\nIn short, we cannot release the tag value on receiving a response.",
      "parentUuid": "e52db383_75620f12",
      "range": {
        "startLine": 401,
        "startChar": 0,
        "endLine": 404,
        "endChar": 36
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4885f5f_88c71d6e",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 624,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-19T09:49:31Z",
      "side": 1,
      "message": "Thanks for adding the timeout handling.",
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d5d3c3f_b70ea364",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 624,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b4885f5f_88c71d6e",
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5382c7b_fea2856e",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 685,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-19T09:49:31Z",
      "side": 1,
      "message": "I still think this should be something like (\u0027destination EID\u0027, \u0027source EID\u0027, ...) for consistent language and to differentiate from other types of address like physical addresses.\n\nI also asked about the TO bit, but I wasn\u0027t necessarily advocating for it\u0027s inclusion, was just asking whether you intended it to be. So now I have to ask whether we need to capture the TO bit? We don\u0027t need to correlate for a responder, so it seems to me it\u0027s implicit that the tag-owner value is always 1?",
      "range": {
        "startLine": 684,
        "startChar": 66,
        "endLine": 685,
        "endChar": 14
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88ffdd95_d4d5a00c",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 685,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-02-22T04:12:30Z",
      "side": 1,
      "message": "Yep, good call, I\u0027ll adjust the terms there to be consistent.\n\nI think it\u0027s better to include tag-owner in that set there; even though it may not exist in the kernel data structure for these mappings, we do need to match TO on the incoming packets.",
      "parentUuid": "c5382c7b_fea2856e",
      "range": {
        "startLine": 684,
        "startChar": 66,
        "endLine": 685,
        "endChar": 14
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f02c2db7_3135fb81",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 4
      },
      "lineNbr": 685,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-02-22T09:49:20Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "88ffdd95_d4d5a00c",
      "range": {
        "startLine": 684,
        "startChar": 66,
        "endLine": 685,
        "endChar": 14
      },
      "revId": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    }
  ]
}