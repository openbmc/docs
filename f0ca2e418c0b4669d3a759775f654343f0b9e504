{
  "comments": [
    {
      "key": {
        "uuid": "cf29e7e7_9059c2c8",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 200,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "Better to clarify\nAs responder, even with specific local EID, NULL EID \u0026 BROADCAST EID will be accepted, but not others.\n\nAs requester, MCTP_ADDR_ANY can send to multiple and with specific EID, NULL \u0026 BROADCAST EID possibility?",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 200,
        "endChar": 22
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b979d225_96dc0e0d",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "I don\u0027t think MCTP_ADDR_ANY makes sense for requesters.",
      "parentUuid": "cf29e7e7_9059c2c8",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 200,
        "endChar": 22
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a57e8186_c32875ee",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 200,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "As a requester how the first GetEID / SetEID command can be sent esp, for NULL EID.",
      "parentUuid": "b979d225_96dc0e0d",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 200,
        "endChar": 22
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0589d3b7_9dd44b79",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 697,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "Tag behavior for received messages section\n1. Need to explicitly state that TO\u003d1 with any tag value will be accepted\n2. With TO\u003d0, Tag value must match unexpired tag, else the MCTP Message packet will be silently dropped.",
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60153541_4f6ff6e0",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 697,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "\u003e 1. Need to explicitly state that TO\u003d1 with any tag value will be accepted\n\nDo you think we need more than what\u0027s already mentioned in the bind() documentation above?\n\n\u003e 2. With TO\u003d0, Tag value must match unexpired tag, else the MCTP Message packet will be silently dropped.\n\nGood catch. It doesn\u0027t seem like this case is discussed in the text? Jeremy and I had spoken about it, and from my records:\n\n\u003e [2:24 PM] jk-: if the TO\u003d0 tag doesn\u0027t exist, we\u0027d ESOMETHING\n\nSo it\u0027s not quite a silent drop, the caller would at least learn that something had gone wrong.",
      "parentUuid": "0589d3b7_9dd44b79",
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4617a1d_8750a939",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 697,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "we have section for Transmitted, my point is to document it for receive side.\n\nSilent drop is allowed from specification point of it.",
      "parentUuid": "60153541_4f6ff6e0",
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b16cc5c8_62e25f21",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 710,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "shouldn\u0027t be.\nExample, Requester sends request to 2 different EID\u0027s. It can send to both and await for its response. The MsgTag will be different for each different destination EID and tracked separately and shouldn\u0027t expire due to next request.",
      "range": {
        "startLine": 710,
        "startChar": 3,
        "endLine": 710,
        "endChar": 49
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e972577_e969257e",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 710,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "What you\u0027re asking for is handled by the `MCTP_TAG_CONTROL` sockopt documented above. As I understand it, if you set the socket to retain tags it will do so like you\u0027ve requested. It\u0027s just not the default behaviour because asynchronous use of the socket isn\u0027t the \"easy\" use-case in the spirit of the \"Configuration should be simple for a straightforward MCTP endpoint\" guideline from the \"Requirements for a kernel implementation\" section above.",
      "parentUuid": "b16cc5c8_62e25f21",
      "range": {
        "startLine": 710,
        "startChar": 3,
        "endLine": 710,
        "endChar": 49
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90f55e37_22236463",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 710,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "I am not quite clear, you meant to say when kernel is requested to send a new message to the new destination EID, then old tag value needs to expire?\n\nExpiring Msg tag is allowed only with any one of the following cases\n1. If response with the msg tag is received (exception is discussed NVMe-MI and if yes this scenario needs to retain but it seems NVMe-MI will use ROR bit - Will confirm it though)\n2. timeout \n3. user space application which sent the tag is no longer needs the same.\n\nIt can\u0027t expire the msg tag, just because new request is sent to new destination EID.",
      "parentUuid": "5e972577_e969257e",
      "range": {
        "startLine": 710,
        "startChar": 3,
        "endLine": 710,
        "endChar": 49
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8af46ddc_067f277b",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 739,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "Where this is specified in DSP0236. This has not been clearly specified in the specification, and my understanding is to use the physical address mapping with MsgTag in this case (Say with NULL EID / Broadcast EID).\nNote: For Broadcast EID usage MCTP Control type can track the same using Instance ID and same logic must apply for other MCTP message types too.",
      "range": {
        "startLine": 735,
        "startChar": 58,
        "endLine": 739,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1c53e42_be650cb8",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 739,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "The key part is avoiding layering violations while correctly associating assembled messages with sockets.\n\nThe current design doesn\u0027t put any general knowledge of MCTP control packets into the kernel, and as such the Instance ID is opaque. The message terminus is used to associate packets to a specific assembly, and a message terminus is defined as the \"MCTP Source Endpoint ID, Tag Owner bit value, and Message Tag value\" (3.2.40). Given that the terminus is the way to uniquely identify a message we also use it to perform correlation to sockets for message delivery to userspace.\n\nWe have various MCTP control message classes that we need to cater to, including Broadcast Request (11.1.1). If we send a Broadcast Request class message we lose the MCTP Source Endpoint as a useful message-correlation value for the socket (we must correlate responses from multiple endpoints to the socket as a result of the Broadcast Request). This leaves us with just Tag Owner and Message Tag Value as the means to correlate the response message to the socket, and therefore we need the Tag Value to be (locally) unique so as not to mistakenly deliver unrelated responses.\n\n\u003e my understanding is to use the physical address mapping with MsgTag in this case\n\nCan you expand on how this helps resolve the message-to-socket correlation problem? All packets we receive must necessarily be physically addressed to us. We don\u0027t know what physical addresses will respond a-priori when transmitting a Broadcast Request, so we can\u0027t prime the socket metadata with the set of physical addresses we expect to receive responses from.\n\n\u003e For Broadcast EID usage MCTP Control type can track the same using Instance ID and same logic must apply for other MCTP message types too.\n\nThis requires we implement processing of MCTP control messages in the kernel for some message-to-socket correlation, which is something I\u0027d certainly like to avoid.",
      "parentUuid": "8af46ddc_067f277b",
      "range": {
        "startLine": 735,
        "startChar": 58,
        "endLine": 739,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "952e7c50_d3cce0f9",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 739,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-03-05T04:12:33Z",
      "side": 1,
      "message": "This is a consequence of behaviour defined by DSP0236, section 8.5:\n\n\u003e The following fields (and only these fields) are collectively used to identify the packets that belong to a given message for the purpose of message assembly on a particular destination endpoint\n\u003e * Msg Tag (Message Tag)\n\u003e * TO (Tag Owner)\n\u003e * Source Endpoint ID\n\n[emphasis on \"only\" as written in the spec]\n\nThe definition of \"message terminus\" (Section 3.4) in the spec also includes only these fields.\n\nWe\u0027d be violating the spec if we start including other data for this (like phys address or payload-specific fields). The phys address approach also doesn\u0027t work for bindings that have no physical addresses.\n\nSo, if we have a situation where the peer EID is a special value (ie, broadcast, or NULL), the message tag must be unique across all potential responses, for a particular local EID, otherwise there is no way to uniquely identify the local message terminus. \n\nIt could be argued that this is only for message reassembly, and we should leave the message-to-socket correlation to userspace, but then the design that we\u0027re left with makes it no longer possible to implement sockets in a secure manner at all, where messages must be forwarded to multiple processes.",
      "parentUuid": "e1c53e42_be650cb8",
      "range": {
        "startLine": 735,
        "startChar": 58,
        "endLine": 739,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ce20e81_976d2949",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 739,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "Just to make sure we are all the same page. \n\nNote: We need to rely on EID for the MsgTag tracking, and the logic is not to deviate from it.\nWhat i meant to say is in this following condition.\n1. Sending messages to Null EID, in this case, as per Spec, the MsgTag needs to be tracked, but when there are multiple devices in the bus, and not to run out of Msg Tag we can rely on physical address when EID is NULL, during the initialization phase of the platform (Condition may happen, when Topmost B.O is not available during this time etc.). This is not violation of Spec, as we will be able to track it individually(i.e. we are still in compliance with the spec). \n\n2. Related to Broadcast EID --\u003e Again this is special EID, so far mainly used only in Control message type (Note: Some protocol type can still use it, but not seen anything so far). Even in Control ID, the request \u0026 response are tracked using Instance ID. i.e. There is no spec requirement which states that Broadcast EID message must be sent to all the devices with same MsgTag (Also, this is only applicable, when physical layer support address less transfer).",
      "parentUuid": "952e7c50_d3cce0f9",
      "range": {
        "startLine": 735,
        "startChar": 58,
        "endLine": 739,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21f53a60_dfb9cf95",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 782,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "This must be avoided from security point of it. We don\u0027t want to end up doing a different mapping. In short, Physical to EID mapping must be determined through MCTP Control message types.",
      "range": {
        "startLine": 782,
        "startChar": 4,
        "endLine": 782,
        "endChar": 64
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "439655a6_c064ad20",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 782,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "I think you\u0027re interpreting that more broadly than its intent. It\u0027s not the general case, but rather a case specifically for mapping the bus owner. This is described by paragraphs 3 and 4 in 9.1.5 (in DSP0236 1.3.1):\n\n\u003e An endpoint that needs to originate a \"connection\" to another MCTP endpoint does need to know what physical address should be used for messages to be delivered to that endpoint. To get this information, it needs to query the bus owner for it. An endpoint knows the physical address of the bus owner because it saved that information when it got its EID assignment.\n\nParticularly the last sentence above. If we\u0027re going to collect the physical address, we might as well populate the route table with the bus owner\u0027s EID as well.\n\n\u003e \n\u003e The Resolve Endpoint ID command requests a bus owner to return the physical address that is to be used to route packets to a given EID. (This is essentially the MCTP equivalent of the ARP protocol that is used to translate IP addresses to physical addresses.) The address that is returned in the Resolve Endpoint ID command response will either be the actual physical address for the device implementing the endpoint, or it will be the physical address for the bridge to be used to route packets to the desired endpoint.\n\nThis is the bit that you care about, and is taken care of by the next bullet point below:",
      "parentUuid": "21f53a60_dfb9cf95",
      "range": {
        "startLine": 782,
        "startChar": 4,
        "endLine": 782,
        "endChar": 64
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d091166_41a5c0ca",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 782,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-03-05T04:12:33Z",
      "side": 1,
      "message": "\u003e This must be avoided from security point of it\n\nI disagree. What\u0027s your proposed attack vector here? Keep in mind that if it\u0027s possible to poison the neighbour information through this mechanism, then it\u0027s also possible to do the same through a control message response.\n\nThis is also allowed by the spec, see the second paragraph of 9.1.5.\n\n[We could implement a control mechanism to disable this behaviour, but I don\u0027t see a use-case for that at present]",
      "parentUuid": "439655a6_c064ad20",
      "range": {
        "startLine": 782,
        "startChar": 4,
        "endLine": 782,
        "endChar": 64
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d81148a4_ab588e41",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 782,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "With SPDM now in picture, physical-to-Eid mapping must happen only through MCTP Control or with SPDM (more secure way).\nWhat i understand from this line, even with BMC as a Bus owner, if any device just issues a request to BMC (Say GetEID) to BMC, with it\u0027s own EID in the picture, then kernel mapping that will be a problem.\n\nConsider a device went to reset and uses it\u0027s old EID, which is retired and used for other device, now what kernel will do ? \nProper logic will be MCTP control detecting the same, and performing a proper SetEID with NULL EID.",
      "parentUuid": "0d091166_41a5c0ca",
      "range": {
        "startLine": 782,
        "startChar": 4,
        "endLine": 782,
        "endChar": 64
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b79848b7_2da794c6",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 914,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "This will be against DSP0236. i.e. when MCTP packets needs to be assembled it will be based on tag value, and hence the next successive MCTP message, must be with different tag value (else any one packet drop) may cause confusion.",
      "range": {
        "startLine": 913,
        "startChar": 0,
        "endLine": 914,
        "endChar": 31
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4ad8468_2e9c621e",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 914,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "Well, technically reply packets are assembled into messages correlating on the terminus recorded in each packet, which includes the source (remote) EID. So there\u0027s no ambiguity with the limitation that you only have one outstanding message per endpoint. However, for the MCTP control protocol, section 11.6.2 explicitly states that you may not have more than one outstanding request per endpoint, so this implementation requirement in-fact wouldn\u0027t be a limitation for the *MCTP control protocol*.\n\n*Other* protocols may not have this limitation though, so maybe it\u0027s a good idea to have an extra bullet point in the list below?",
      "parentUuid": "b79848b7_2da794c6",
      "range": {
        "startLine": 913,
        "startChar": 0,
        "endLine": 914,
        "endChar": 31
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "288ea48d_32e750be",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 914,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-03-05T04:12:33Z",
      "side": 1,
      "message": "DSP0236 doesn\u0027t require different tags for subsequent messages, I don\u0027t see this as violating the spec. If I\u0027m incorrect though, could you point me to where in the spec you\u0027re referencing?\n\nYes, we need to ensure that the tag can uniquely identify interleaved messages while in-flight, but there are no restrictions that I can see otherwise.",
      "parentUuid": "c4ad8468_2e9c621e",
      "range": {
        "startLine": 913,
        "startChar": 0,
        "endLine": 914,
        "endChar": 31
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6dd2d59b_4e7a7a51",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 914,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "Message Tag + Source EID + TO will be used to identify the MCTP message uniquely. In other words, the subsequent message needs to be different to support interleave for different message types.\nNote: source endpoint can interleave the response and can respond in out of order, hence \n\n\"A source endpoint is allowed to interleave packets from multiple messages to the same destination endpoint concurrently, provided that each of the\nmessages has a unique message tag.\" \n\n\nNote: As this was considered as alternative (My intention is to document this as further limitations to indicate about interleave support will be difficult).\n\nScenario where this option will cause confusion:\n1. B.O sends a MCTP message (multiple MCTP packets with EOM message dropped in physical medium)\n2. Now the same MCTP message can be retried or new MCTP message can be sent out. The device must know the same which is possible using new Msg Tag.\n\n(Pkt sequence is used to differentiate multiple MCTP packets, and MsgTag with source EID, TO will be used to determine Messages).",
      "parentUuid": "288ea48d_32e750be",
      "range": {
        "startLine": 913,
        "startChar": 0,
        "endLine": 914,
        "endChar": 31
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b199225a_8129c7e5",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 950,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-04T12:06:41Z",
      "side": 1,
      "message": "I am not sure, how the response must be handled here. Do you know whether NVMe-MI must send the final reply with TO bit set and Message type body to differentiate it (Say in terms of control Message type we have Datagram bit)\n\nFor all other Message types (Except NVMe-MI), it would be better to expire the MsgTag after the proper message (assembled) is received.",
      "range": {
        "startLine": 946,
        "startChar": 35,
        "endLine": 950,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ba1d69f_2e361303",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 950,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-03-04T13:39:54Z",
      "side": 1,
      "message": "There\u0027s still the case of the Broadcast Request message class described below. Ignoring NVMe unfortunately doesn\u0027t make this proposal feasible.",
      "parentUuid": "b199225a_8129c7e5",
      "range": {
        "startLine": 946,
        "startChar": 35,
        "endLine": 950,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ac1e9a7_2ea5cfae",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 950,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2021-03-05T04:12:33Z",
      "side": 1,
      "message": "Implementing immediate tag expiry on a reply requires us to assume that *all* upper-layer protocols have a 1:1 request-to-reply correlation, *including all future protocols*.\n\nI\u0027m not willing to make that guarantee, especially given that we have one counterexample already. And as Andrew says, this also applies to broadcasts.",
      "parentUuid": "1ba1d69f_2e361303",
      "range": {
        "startLine": 946,
        "startChar": 35,
        "endLine": 950,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07ac2134_682be709",
        "filename": "designs/mctp/mctp-kernel.md",
        "patchSetId": 12
      },
      "lineNbr": 950,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2021-03-08T08:48:17Z",
      "side": 1,
      "message": "I didn\u0027t got a chance to check any of the existing NVMe-MI device yet, but in NVMe-MI specification, they are not relying the TO to determine the Request / Response and NVMe-MI message type internally uses ROR bit to determine the same.\n\nThe problem with not expiring the  Msg Tag value is, it requires all message type to expire the same. \nRegarding the future protocols, MCTP doesn\u0027t have any partial response other than the NVMe-MI. Will raise this in PMCI-DMTF and get back with apt data.",
      "parentUuid": "7ac1e9a7_2ea5cfae",
      "range": {
        "startLine": 946,
        "startChar": 35,
        "endLine": 950,
        "endChar": 0
      },
      "revId": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}