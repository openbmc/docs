{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "51290c0e_28eadda7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-05-13T21:44:55Z",
      "side": 1,
      "message": "Ah, I think this proposal helps solve my old stuff too: https://gerrit.openbmc-project.xyz/q/topic:bmc-boot-indicator",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec1eebbc_66cbb046",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001322
      },
      "writtenOn": "2022-05-19T10:52:59Z",
      "side": 1,
      "message": "do we really need a new state? Rather we can just check for necessary services and either boot or not boot.",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84b0f9ca_572d094b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-25T20:27:02Z",
      "side": 1,
      "message": "From the discord conversation:\n\n\u0027\u0027\u0027\nI think the options are between:\n1. Objects don\u0027t exist until the backend is prepared to handle them (in which case they don\u0027t appear in Redfish)\n2. If a user tries to do something that you\u0027re not in the proper state for, return an error code. (in which case bmcweb will transform into a retry-after and preconditionfailed message)\n3. If a user tries to do something you\u0027re not in the proper state for, queue it until it can be processed, which is the most user friendly (the thing you asked for just happens, response code is 200 OK, but the action might not happen the moment you asked for it.)\n\n... \n\nand I\u0027m kind of of the opinion that we push that to the power-control daemons themselves to decide.\n\u0027\u0027\u0027\n\n(off discord)\n#1 in bmcweb, the implementation for, and we have to do regardless (the power state interfaces might not exist).\n#2 is maybe 3 lines of code extra to add the message and set the return code, and we have to agree on a dbus response code for \"not yet ready\" which seems doable.\n#3 is the most user friendly, and bmcweb only has to implement the golden path.\n\nThe ideal priority would IMO be #3 (because it\u0027s most user friendly) then #1 (because the user is required to check for an action anyway, and presumably handle the error), then #2 (which requires the most sophisticated client implementation).\n\nOnce we have that, it\u0027s on each system to decide what it can and can\u0027t do in its backend, and the redfish tree is correct and standards compliant in all cases.\n\nOne thing to consider is that we have multi-host coming, and it seems likely that there\u0027s one host thats backend services fail, while the others don\u0027t.  Being flexible here means we can in those cases pick the best possible implementation the backend is able.\n",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "832b35ec_c1584a23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-08-01T18:17:25Z",
      "side": 1,
      "message": "Yeah, seems general feedback here has been to just do 3. One goal we have is to get Tasks implemented for power on operations in bmcweb. This would provide some feedback to the user on the status of their request and could potentially show the queued-up nature of the request.",
      "parentUuid": "84b0f9ca_572d094b",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9bb4c0e_7073813b",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-25T20:27:02Z",
      "side": 1,
      "message": "Not sure I agree with it.  Yes, there are implementations that have undefined behavior, but the normal practices of:\n1. Declare your dependencies.\n2. Only list the objects that have dependencies on dbus once those dependencies have been met.\n\nI think resolve this?",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 57
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b728ae8b_3c5ea14b",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-08-01T18:17:25Z",
      "side": 1,
      "message": "Yeah, I think this is another alternative solution. It would have similar complexity on client apps to wait for the interface. One complexity here is that you could provide the read-only state earlier, it\u0027s only the action that is not permitted. We don\u0027t have an easy way though with sdbusplus to only implement certain properties on d-bus but not others.",
      "parentUuid": "d9bb4c0e_7073813b",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 57
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfdedd67_946c5cd0",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-02T15:31:15Z",
      "side": 1,
      "message": "\u003e Yeah, I think this is another alternative solution. It would have similar complexity on client apps to wait for the interface.\n\nAgreed;  I\u0027m not a fan of the client complexity there.\n\n\u003e One complexity here is that you could provide the read-only state earlier, it\u0027s only the action that is not permitted. We don\u0027t have an easy way though with sdbusplus to only implement certain properties on d-bus but not others.\n\nsdubplus asio has support for that FWIW, although it technically breaks the dbus intent, so probably best to avoid it.  In theory having a read-only interface up before the read write doesn\u0027t help anything though?",
      "parentUuid": "b728ae8b_3c5ea14b",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 57
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37722fac_45e31809",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-25T20:27:02Z",
      "side": 1,
      "message": "nit, interfaces, not objects.  There could be multiples of Chassis or Host.",
      "range": {
        "startLine": 29,
        "startChar": 34,
        "endLine": 29,
        "endChar": 41
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a65aec9_da5af89e",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-08-01T18:17:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "37722fac_45e31809",
      "range": {
        "startLine": 29,
        "startChar": 34,
        "endLine": 29,
        "endChar": 41
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf184035_c852b8f2",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1001322
      },
      "writtenOn": "2022-05-19T10:52:59Z",
      "side": 1,
      "message": "do we really need a new state? Rather we can just check for necessary services and either boot or not boot.",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f96d798e_bb4cd8ea",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-05-23T17:33:51Z",
      "side": 1,
      "message": "Yeah, I think a new state provides a mechanism for external clients (using Redfish) to know whether they can request a power on. If we go with an approach where we just queue up the request, we may not need it.\n\nThe state-manager design is to monitor for systemd targets to reflect state. This allows a layer of abstraction in that different system owners can put different services in the corresponding target. If we hard code state-manager to monitor specific services, we\u0027re hamstringing out ability to support a multitude of system types.",
      "parentUuid": "bf184035_c852b8f2",
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7582c30b_632ddca2",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-05-17T13:02:00Z",
      "side": 1,
      "message": "This isn\u0027t really a state of the BMC though.  It is a state about the Chassis/Host, isn\u0027t it?  How do you handle multi-host designs?  Maybe there is a VRM in each compute blade that needs its data collected, but only to block the single compute blade from booting.",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 60,
        "endChar": 31
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc01706f_feda42c9",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-05-17T19:29:09Z",
      "side": 1,
      "message": "Yeah, basically all chassis/host instances have to wait for the basic BMC services to be started. We have a basic issue that certain BMC services are required to power on and boot your system. So this design is saying you have to wait for those base services to be started before any chassis or host operation is valid.",
      "parentUuid": "7582c30b_632ddca2",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 60,
        "endChar": 31
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "177fbee2_24d54ec8",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-25T20:27:02Z",
      "side": 1,
      "message": "Not quite understanding this statement.  If the bmc never reaches boot ready, no action is ever taken.  Does that even require code?\n\n\n1 request can either be queued, or dropped with a \"conflicting requests\" response, at the decision of the implementation.  \"queue one power request\" probably covers the 99% use case, but even if that\u0027s imperfect, it seems like there\u0027s reasonable behavior that could be defined.",
      "range": {
        "startLine": 83,
        "startChar": 32,
        "endLine": 85,
        "endChar": 58
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44c0cec9_d8c86d02",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-08-01T18:17:25Z",
      "side": 1,
      "message": "Yeah, it feels like the general feedback here in this review is that just queuing it is better and something the user (and client apps) would appreciate.",
      "parentUuid": "177fbee2_24d54ec8",
      "range": {
        "startLine": 83,
        "startChar": 32,
        "endLine": 85,
        "endChar": 58
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0b5bf0e_975ed61b",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-05-17T13:02:00Z",
      "side": 1,
      "message": "I don\u0027t really follow this.  What errors are there?  \n\nThis seems like the most obvious solution.  We already have:\n\n- obmc-power-start-pre@.target\n- obmc-host-start-pre@.target\n\nWhy wouldn\u0027t you have any service that needs to insert itself as \"required before boot\" into the Wants/Required of these existing targets?  I\u0027m not convinced that a new target (+ state) is warranted.",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 91,
        "endChar": 39
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c5656e2_19933dbc",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-05-17T19:29:09Z",
      "side": 1,
      "message": "This leads into your next question. I think there are two options here. Either we have a clear way to tell the user when the required BMC services have started and the system can be powered on, or we go with what you\u0027re leaning towards which is we queue up the request from the user, have the required services block around the target you indicate here, and have it power on once the services are done.\n\nThe issue I have with the queue option is that what happens when the services never complete? Or one fails and the BMC gets stuck in the Quiesced state (which is what started this whole design for IBM). We don\u0027t want to try and power on if a critical service has not started or failed, and we have no way to asynchronously tell the caller we\u0027ve failed and will not be honoring their queued power on request. This design is leaning towards just failing the call and letting the user deal with the retry/error handling logic because they\u0027re going to know the behavior they want best. Otherwise what do we say to the clients? Make the request, start some arbitrary timeout, and wait for the system to actually power on? What do they do when the timeout hits? It just seems more clear to give them a \"NotReadyToBoot\" error code at the time of the request.",
      "parentUuid": "d0b5bf0e_975ed61b",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 91,
        "endChar": 39
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f45b50f3_afd0dce9",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-05-17T13:02:00Z",
      "side": 1,
      "message": "This also seems much worse.  We\u0027re pushing this off into all the users of the power on sequence rather than just automatically queuing it up into the normal power on sequence.  I mentioned in your first code review that you\u0027d be making external interfaces like the power button have to implement some kind of queueing behavior or otherwise inform the user that \"you can\u0027t actually power on yet\".  It is much better from a user experience, to me, to keep the current \"start the sequence\" path that I\"m recommending because we can insert LED behavior into that sequence to clearly inform the user \"I heard you and am working on it\".  This goes for post codes + op-panel displays too.",
      "range": {
        "startLine": 95,
        "startChar": 0,
        "endLine": 98,
        "endChar": 26
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfba9b23_05f557be",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1000004
      },
      "writtenOn": "2022-05-17T19:29:09Z",
      "side": 1,
      "message": "More details above, but yes, the power button either handles it or they just throw away the error and the lack of powering on is a clear sign to the user something is up. But the alternative...the system never powers on anyway, or just starts at some random time in the future seems worse to me. Someone hits the button, it\u0027s not ready, so they go fiddling with the power supplies or something and it randomly turns on a few minutes later??",
      "parentUuid": "f45b50f3_afd0dce9",
      "range": {
        "startLine": 95,
        "startChar": 0,
        "endLine": 98,
        "endChar": 26
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82d779b8_e8377b78",
        "filename": "designs/bmc-boot-ready.md",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-05-24T01:01:41Z",
      "side": 1,
      "message": "I\u0027d agree that a lengthy, silent delay between pushing the power button and it actually taking effect isn\u0027t great.  It sounds like Patrick\u0027s suggestion is that we could make it less silent via LED feedback, but I\u0027m not sure how likely it is that trying to convey \"I heard you and am working on it\" via an LED would really be achievable in a clear, self-explanatory way; anything I can think of seems like it would be more likely to be completely cryptic or misinterpreted as buggy behavior by someone not already intimately familiar with OpenBMC.  Conveying \"sorry, no can do\" via an LED seems a lot more tractable (though the implicit \"try again in a minute or two\" is admittedly non-obvious).\n\nThis is of course completely tangential, but it seems like a lot of the problems we\u0027re grappling with here would be substantially reduced if we solved the long-standing \"OpenBMC takes way too long to boot\" problem (though it\u0027d need to be a pretty dramatic improvement I suppose).",
      "parentUuid": "dfba9b23_05f557be",
      "range": {
        "startLine": 95,
        "startChar": 0,
        "endLine": 98,
        "endChar": 26
      },
      "revId": "d1a72d0da3a4cee65a87b682e0f57231749a4805",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}